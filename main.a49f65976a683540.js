"use strict"; (self.webpackChunkwebapp = self.webpackChunkwebapp || []).push([[179], { 6: () => { function ye(n) { return "function" == typeof n } function Ds(n) { const e = n(i => { Error.call(i), i.stack = (new Error).stack }); return e.prototype = Object.create(Error.prototype), e.prototype.constructor = e, e } const sl = Ds(n => function(e) { n(this), this.message = e ? `${e.length} errors occurred during unsubscription:\n${e.map((i, r) => `${r + 1}) ${i.toString()}`).join("\n  ")}` : "", this.name = "UnsubscriptionError", this.errors = e }); function Jr(n, t) { if (n) { const e = n.indexOf(t); 0 <= e && n.splice(e, 1) } } class Ze { constructor(t) { this.initialTeardown = t, this.closed = !1, this._parentage = null, this._teardowns = null } unsubscribe() { let t; if (!this.closed) { this.closed = !0; const { _parentage: e } = this; if (e) if (this._parentage = null, Array.isArray(e)) for (const o of e) o.remove(this); else e.remove(this); const { initialTeardown: i } = this; if (ye(i)) try { i() } catch (o) { t = o instanceof sl ? o.errors : [o] } const { _teardowns: r } = this; if (r) { this._teardowns = null; for (const o of r) try { p_(o) } catch (s) { t = null != t ? t : [], s instanceof sl ? t = [...t, ...s.errors] : t.push(s) } } if (t) throw new sl(t) } } add(t) { var e; if (t && t !== this) if (this.closed) p_(t); else { if (t instanceof Ze) { if (t.closed || t._hasParent(this)) return; t._addParent(this) } (this._teardowns = null !== (e = this._teardowns) && void 0 !== e ? e : []).push(t) } } _hasParent(t) { const { _parentage: e } = this; return e === t || Array.isArray(e) && e.includes(t) } _addParent(t) { const { _parentage: e } = this; this._parentage = Array.isArray(e) ? (e.push(t), e) : e ? [e, t] : t } _removeParent(t) { const { _parentage: e } = this; e === t ? this._parentage = null : Array.isArray(e) && Jr(e, t) } remove(t) { const { _teardowns: e } = this; e && Jr(e, t), t instanceof Ze && t._removeParent(this) } } Ze.EMPTY = (() => { const n = new Ze; return n.closed = !0, n })(); const h_ = Ze.EMPTY; function f_(n) { return n instanceof Ze || n && "closed" in n && ye(n.remove) && ye(n.add) && ye(n.unsubscribe) } function p_(n) { ye(n) ? n() : n.unsubscribe() } const dr = { onUnhandledError: null, onStoppedNotification: null, Promise: void 0, useDeprecatedSynchronousErrorHandling: !1, useDeprecatedNextContext: !1 }, al = { setTimeout(...n) { const { delegate: t } = al; return ((null == t ? void 0 : t.setTimeout) || setTimeout)(...n) }, clearTimeout(n) { const { delegate: t } = al; return ((null == t ? void 0 : t.clearTimeout) || clearTimeout)(n) }, delegate: void 0 }; function g_(n) { al.setTimeout(() => { const { onUnhandledError: t } = dr; if (!t) throw n; t(n) }) } function Bi() { } const jS = Wu("C", void 0, void 0); function Wu(n, t, e) { return { kind: n, value: t, error: e } } let hr = null; function ll(n) { if (dr.useDeprecatedSynchronousErrorHandling) { const t = !hr; if (t && (hr = { errorThrown: !1, error: null }), n(), t) { const { errorThrown: e, error: i } = hr; if (hr = null, e) throw i } } else n() } class zu extends Ze { constructor(t) { super(), this.isStopped = !1, t ? (this.destination = t, f_(t) && t.add(this)) : this.destination = WS } static create(t, e, i) { return new Ku(t, e, i) } next(t) { this.isStopped ? Yu(function $S(n) { return Wu("N", n, void 0) }(t), this) : this._next(t) } error(t) { this.isStopped ? Yu(function US(n) { return Wu("E", void 0, n) }(t), this) : (this.isStopped = !0, this._error(t)) } complete() { this.isStopped ? Yu(jS, this) : (this.isStopped = !0, this._complete()) } unsubscribe() { this.closed || (this.isStopped = !0, super.unsubscribe(), this.destination = null) } _next(t) { this.destination.next(t) } _error(t) { try { this.destination.error(t) } finally { this.unsubscribe() } } _complete() { try { this.destination.complete() } finally { this.unsubscribe() } } } class Ku extends zu { constructor(t, e, i) { let r; if (super(), ye(t)) r = t; else if (t) { let o; ({ next: r, error: e, complete: i } = t), this && dr.useDeprecatedNextContext ? (o = Object.create(t), o.unsubscribe = () => this.unsubscribe()) : o = t, r = null == r ? void 0 : r.bind(o), e = null == e ? void 0 : e.bind(o), i = null == i ? void 0 : i.bind(o) } this.destination = { next: r ? qu(r) : Bi, error: qu(null != e ? e : __), complete: i ? qu(i) : Bi } } } function qu(n, t) { return (...e) => { try { n(...e) } catch (i) { dr.useDeprecatedSynchronousErrorHandling ? function GS(n) { dr.useDeprecatedSynchronousErrorHandling && hr && (hr.errorThrown = !0, hr.error = n) }(i) : g_(i) } } } function __(n) { throw n } function Yu(n, t) { const { onStoppedNotification: e } = dr; e && al.setTimeout(() => e(n, t)) } const WS = { closed: !0, next: Bi, error: __, complete: Bi }, Qu = "function" == typeof Symbol && Symbol.observable || "@@observable"; function gi(n) { return n } let Ce = (() => { class n { constructor(e) { e && (this._subscribe = e) } lift(e) { const i = new n; return i.source = this, i.operator = e, i } subscribe(e, i, r) { const o = function KS(n) { return n && n instanceof zu || function zS(n) { return n && ye(n.next) && ye(n.error) && ye(n.complete) }(n) && f_(n) }(e) ? e : new Ku(e, i, r); return ll(() => { const { operator: s, source: a } = this; o.add(s ? s.call(o, a) : a ? this._subscribe(o) : this._trySubscribe(o)) }), o } _trySubscribe(e) { try { return this._subscribe(e) } catch (i) { e.error(i) } } forEach(e, i) { return new (i = y_(i))((r, o) => { let s; s = this.subscribe(a => { try { e(a) } catch (l) { o(l), null == s || s.unsubscribe() } }, o, r) }) } _subscribe(e) { var i; return null === (i = this.source) || void 0 === i ? void 0 : i.subscribe(e) } [Qu]() { return this } pipe(...e) { return function m_(n) { return 0 === n.length ? gi : 1 === n.length ? n[0] : function(e) { return n.reduce((i, r) => r(i), e) } }(e)(this) } toPromise(e) { return new (e = y_(e))((i, r) => { let o; this.subscribe(s => o = s, s => r(s), () => i(o)) }) } } return n.create = t => new n(t), n })(); function y_(n) { var t; return null !== (t = null != n ? n : dr.Promise) && void 0 !== t ? t : Promise } const qS = Ds(n => function() { n(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed" }); let be = (() => { class n extends Ce { constructor() { super(), this.closed = !1, this.observers = [], this.isStopped = !1, this.hasError = !1, this.thrownError = null } lift(e) { const i = new b_(this, this); return i.operator = e, i } _throwIfClosed() { if (this.closed) throw new qS } next(e) { ll(() => { if (this._throwIfClosed(), !this.isStopped) { const i = this.observers.slice(); for (const r of i) r.next(e) } }) } error(e) { ll(() => { if (this._throwIfClosed(), !this.isStopped) { this.hasError = this.isStopped = !0, this.thrownError = e; const { observers: i } = this; for (; i.length;)i.shift().error(e) } }) } complete() { ll(() => { if (this._throwIfClosed(), !this.isStopped) { this.isStopped = !0; const { observers: e } = this; for (; e.length;)e.shift().complete() } }) } unsubscribe() { this.isStopped = this.closed = !0, this.observers = null } get observed() { var e; return (null === (e = this.observers) || void 0 === e ? void 0 : e.length) > 0 } _trySubscribe(e) { return this._throwIfClosed(), super._trySubscribe(e) } _subscribe(e) { return this._throwIfClosed(), this._checkFinalizedStatuses(e), this._innerSubscribe(e) } _innerSubscribe(e) { const { hasError: i, isStopped: r, observers: o } = this; return i || r ? h_ : (o.push(e), new Ze(() => Jr(o, e))) } _checkFinalizedStatuses(e) { const { hasError: i, thrownError: r, isStopped: o } = this; i ? e.error(r) : o && e.complete() } asObservable() { const e = new Ce; return e.source = this, e } } return n.create = (t, e) => new b_(t, e), n })(); class b_ extends be { constructor(t, e) { super(), this.destination = t, this.source = e } next(t) { var e, i; null === (i = null === (e = this.destination) || void 0 === e ? void 0 : e.next) || void 0 === i || i.call(e, t) } error(t) { var e, i; null === (i = null === (e = this.destination) || void 0 === e ? void 0 : e.error) || void 0 === i || i.call(e, t) } complete() { var t, e; null === (e = null === (t = this.destination) || void 0 === t ? void 0 : t.complete) || void 0 === e || e.call(t) } _subscribe(t) { var e, i; return null !== (i = null === (e = this.source) || void 0 === e ? void 0 : e.subscribe(t)) && void 0 !== i ? i : h_ } } function v_(n) { return ye(null == n ? void 0 : n.lift) } function Ge(n) { return t => { if (v_(t)) return t.lift(function(e) { try { return n(e, this) } catch (i) { this.error(i) } }); throw new TypeError("Unable to lift unknown Observable type") } } class Ie extends zu { constructor(t, e, i, r, o) { super(t), this.onFinalize = o, this._next = e ? function(s) { try { e(s) } catch (a) { t.error(a) } } : super._next, this._error = r ? function(s) { try { r(s) } catch (a) { t.error(a) } finally { this.unsubscribe() } } : super._error, this._complete = i ? function() { try { i() } catch (s) { t.error(s) } finally { this.unsubscribe() } } : super._complete } unsubscribe() { var t; const { closed: e } = this; super.unsubscribe(), !e && (null === (t = this.onFinalize) || void 0 === t || t.call(this)) } } function W(n, t) { return Ge((e, i) => { let r = 0; e.subscribe(new Ie(i, o => { i.next(n.call(t, o, r++)) })) }) } function fr(n) { return this instanceof fr ? (this.v = n, this) : new fr(n) } function JS(n, t, e) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var r, i = e.apply(n, t || []), o = []; return r = {}, s("next"), s("throw"), s("return"), r[Symbol.asyncIterator] = function() { return this }, r; function s(h) { i[h] && (r[h] = function(f) { return new Promise(function(p, _) { o.push([h, f, p, _]) > 1 || a(h, f) }) }) } function a(h, f) { try { !function l(h) { h.value instanceof fr ? Promise.resolve(h.value.v).then(c, u) : d(o[0][2], h) }(i[h](f)) } catch (p) { d(o[0][3], p) } } function c(h) { a("next", h) } function u(h) { a("throw", h) } function d(h, f) { h(f), o.shift(), o.length && a(o[0][0], o[0][1]) } } function ZS(n) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var e, t = n[Symbol.asyncIterator]; return t ? t.call(n) : (n = function E_(n) { var t = "function" == typeof Symbol && Symbol.iterator, e = t && n[t], i = 0; if (e) return e.call(n); if (n && "number" == typeof n.length) return { next: function() { return n && i >= n.length && (n = void 0), { value: n && n[i++], done: !n } } }; throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.") }(n), e = {}, i("next"), i("throw"), i("return"), e[Symbol.asyncIterator] = function() { return this }, e); function i(o) { e[o] = n[o] && function(s) { return new Promise(function(a, l) { !function r(o, s, a, l) { Promise.resolve(l).then(function(c) { o({ value: c, done: a }) }, s) }(a, l, (s = n[o](s)).done, s.value) }) } } } const Zu = n => n && "number" == typeof n.length && "function" != typeof n; function w_(n) { return ye(null == n ? void 0 : n.then) } function T_(n) { return ye(n[Qu]) } function S_(n) { return Symbol.asyncIterator && ye(null == n ? void 0 : n[Symbol.asyncIterator]) } function A_(n) { return new TypeError(`You provided ${null !== n && "object" == typeof n ? "an invalid object" : `'${n}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`) } const M_ = function eA() { return "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator" }(); function N_(n) { return ye(null == n ? void 0 : n[M_]) } function I_(n) { return JS(this, arguments, function*() { const e = n.getReader(); try { for (; ;) { const { value: i, done: r } = yield fr(e.read()); if (r) return yield fr(void 0); yield yield fr(i) } } finally { e.releaseLock() } }) } function R_(n) { return ye(null == n ? void 0 : n.getReader) } function Et(n) { if (n instanceof Ce) return n; if (null != n) { if (T_(n)) return function tA(n) { return new Ce(t => { const e = n[Qu](); if (ye(e.subscribe)) return e.subscribe(t); throw new TypeError("Provided object does not correctly implement Symbol.observable") }) }(n); if (Zu(n)) return function nA(n) { return new Ce(t => { for (let e = 0; e < n.length && !t.closed; e++)t.next(n[e]); t.complete() }) }(n); if (w_(n)) return function iA(n) { return new Ce(t => { n.then(e => { t.closed || (t.next(e), t.complete()) }, e => t.error(e)).then(null, g_) }) }(n); if (S_(n)) return O_(n); if (N_(n)) return function rA(n) { return new Ce(t => { for (const e of n) if (t.next(e), t.closed) return; t.complete() }) }(n); if (R_(n)) return function oA(n) { return O_(I_(n)) }(n) } throw A_(n) } function O_(n) { return new Ce(t => { (function sA(n, t) { var e, i, r, o; return function YS(n, t, e, i) { return new (e || (e = Promise))(function(o, s) { function a(u) { try { c(i.next(u)) } catch (d) { s(d) } } function l(u) { try { c(i.throw(u)) } catch (d) { s(d) } } function c(u) { u.done ? o(u.value) : function r(o) { return o instanceof e ? o : new e(function(s) { s(o) }) }(u.value).then(a, l) } c((i = i.apply(n, t || [])).next()) }) }(this, void 0, void 0, function*() { try { for (e = ZS(n); !(i = yield e.next()).done;)if (t.next(i.value), t.closed) return } catch (s) { r = { error: s } } finally { try { i && !i.done && (o = e.return) && (yield o.call(e)) } finally { if (r) throw r.error } } t.complete() }) })(n, t).catch(e => t.error(e)) }) } function _i(n, t, e, i = 0, r = !1) { const o = t.schedule(function() { e(), r ? n.add(this.schedule(null, i)) : this.unsubscribe() }, i); if (n.add(o), !r) return o } function it(n, t, e = 1 / 0) { return ye(t) ? it((i, r) => W((o, s) => t(i, o, r, s))(Et(n(i, r))), e) : ("number" == typeof t && (e = t), Ge((i, r) => function aA(n, t, e, i, r, o, s, a) { const l = []; let c = 0, u = 0, d = !1; const h = () => { d && !l.length && !c && t.complete() }, f = _ => c < i ? p(_) : l.push(_), p = _ => { o && t.next(_), c++; let y = !1; Et(e(_, u++)).subscribe(new Ie(t, b => { null == r || r(b), o ? f(b) : t.next(b) }, () => { y = !0 }, void 0, () => { if (y) try { for (c--; l.length && c < i;) { const b = l.shift(); s ? _i(t, s, () => p(b)) : p(b) } h() } catch (b) { t.error(b) } })) }; return n.subscribe(new Ie(t, f, () => { d = !0, h() })), () => { null == a || a() } }(i, r, n, e))) } function Cs(n = 1 / 0) { return it(gi, n) } const Mn = new Ce(n => n.complete()); function x_(n) { return n && ye(n.schedule) } function Xu(n) { return n[n.length - 1] } function cl(n) { return ye(Xu(n)) ? n.pop() : void 0 } function Es(n) { return x_(Xu(n)) ? n.pop() : void 0 } function P_(n, t = 0) { return Ge((e, i) => { e.subscribe(new Ie(i, r => _i(i, n, () => i.next(r), t), () => _i(i, n, () => i.complete(), t), r => _i(i, n, () => i.error(r), t))) }) } function k_(n, t = 0) { return Ge((e, i) => { i.add(n.schedule(() => e.subscribe(i), t)) }) } function F_(n, t) { if (!n) throw new Error("Iterable cannot be null"); return new Ce(e => { _i(e, t, () => { const i = n[Symbol.asyncIterator](); _i(e, t, () => { i.next().then(r => { r.done ? e.complete() : e.next(r.value) }) }, 0, !0) }) }) } function bt(n, t) { return t ? function gA(n, t) { if (null != n) { if (T_(n)) return function uA(n, t) { return Et(n).pipe(k_(t), P_(t)) }(n, t); if (Zu(n)) return function hA(n, t) { return new Ce(e => { let i = 0; return t.schedule(function() { i === n.length ? e.complete() : (e.next(n[i++]), e.closed || this.schedule()) }) }) }(n, t); if (w_(n)) return function dA(n, t) { return Et(n).pipe(k_(t), P_(t)) }(n, t); if (S_(n)) return F_(n, t); if (N_(n)) return function fA(n, t) { return new Ce(e => { let i; return _i(e, t, () => { i = n[M_](), _i(e, t, () => { let r, o; try { ({ value: r, done: o } = i.next()) } catch (s) { return void e.error(s) } o ? e.complete() : e.next(r) }, 0, !0) }), () => ye(null == i ? void 0 : i.return) && i.return() }) }(n, t); if (R_(n)) return function pA(n, t) { return F_(I_(n), t) }(n, t) } throw A_(n) }(n, t) : Et(n) } function ul(...n) { const t = Es(n), e = function cA(n, t) { return "number" == typeof Xu(n) ? n.pop() : t }(n, 1 / 0), i = n; return i.length ? 1 === i.length ? Et(i[0]) : Cs(e)(bt(i, t)) : Mn } function ct(n) { return n <= 0 ? () => Mn : Ge((t, e) => { let i = 0; t.subscribe(new Ie(e, r => { ++i <= n && (e.next(r), n <= i && e.complete()) })) }) } function L_(n = {}) { const { connector: t = (() => new be), resetOnError: e = !0, resetOnComplete: i = !0, resetOnRefCountZero: r = !0 } = n; return o => { let s = null, a = null, l = null, c = 0, u = !1, d = !1; const h = () => { null == a || a.unsubscribe(), a = null }, f = () => { h(), s = l = null, u = d = !1 }, p = () => { const _ = s; f(), null == _ || _.unsubscribe() }; return Ge((_, y) => { c++, !d && !u && h(); const b = l = null != l ? l : t(); y.add(() => { c--, 0 === c && !d && !u && (a = ed(p, r)) }), b.subscribe(y), s || (s = new Ku({ next: m => b.next(m), error: m => { d = !0, h(), a = ed(f, e, m), b.error(m) }, complete: () => { u = !0, h(), a = ed(f, i), b.complete() } }), bt(_).subscribe(s)) })(o) } } function ed(n, t, ...e) { return !0 === t ? (n(), null) : !1 === t ? null : t(...e).pipe(ct(1)).subscribe(() => n()) } function Oe(n) { for (let t in n) if (n[t] === Oe) return t; throw Error("Could not find renamed property on target object.") } function td(n, t) { for (const e in t) t.hasOwnProperty(e) && !n.hasOwnProperty(e) && (n[e] = t[e]) } function Me(n) { if ("string" == typeof n) return n; if (Array.isArray(n)) return "[" + n.map(Me).join(", ") + "]"; if (null == n) return "" + n; if (n.overriddenName) return `${n.overriddenName}`; if (n.name) return `${n.name}`; const t = n.toString(); if (null == t) return "" + t; const e = t.indexOf("\n"); return -1 === e ? t : t.substring(0, e) } function nd(n, t) { return null == n || "" === n ? null === t ? "" : t : null == t || "" === t ? n : n + " " + t } const _A = Oe({ __forward_ref__: Oe }); function ge(n) { return n.__forward_ref__ = ge, n.toString = function() { return Me(this()) }, n } function ee(n) { return B_(n) ? n() : n } function B_(n) { return "function" == typeof n && n.hasOwnProperty(_A) && n.__forward_ref__ === ge } class _e extends Error { constructor(t, e) { super(function id(n, t) { return `NG0${Math.abs(n)}${t ? ": " + t : ""}` }(t, e)), this.code = t } } function Y(n) { return "string" == typeof n ? n : null == n ? "" : String(n) } function kt(n) { return "function" == typeof n ? n.name || n.toString() : "object" == typeof n && null != n && "function" == typeof n.type ? n.type.name || n.type.toString() : Y(n) } function dl(n, t) { const e = t ? ` in ${t}` : ""; throw new _e(-201, `No provider for ${kt(n)} found${e}`) } function Xt(n, t) { null == n && function Be(n, t, e, i) { throw new Error(`ASSERTION ERROR: ${n}` + (null == i ? "" : ` [Expected=> ${e} ${i} ${t} <=Actual]`)) }(t, n, null, "!=") } function R(n) { return { token: n.token, providedIn: n.providedIn || null, factory: n.factory, value: void 0 } } function te(n) { return { providers: n.providers || [], imports: n.imports || [] } } function rd(n) { return V_(n, hl) || V_(n, j_) } function V_(n, t) { return n.hasOwnProperty(t) ? n[t] : null } function H_(n) { return n && (n.hasOwnProperty(od) || n.hasOwnProperty(EA)) ? n[od] : null } const hl = Oe({ \u0275prov: Oe }), od = Oe({ \u0275inj: Oe }), j_ = Oe({ ngInjectableDef: Oe }), EA = Oe({ ngInjectorDef: Oe }); var Z = (() => ((Z = Z || {})[Z.Default = 0] = "Default", Z[Z.Host = 1] = "Host", Z[Z.Self = 2] = "Self", Z[Z.SkipSelf = 4] = "SkipSelf", Z[Z.Optional = 8] = "Optional", Z))(); let sd; function Vi(n) { const t = sd; return sd = n, t } function U_(n, t, e) { const i = rd(n); return i && "root" == i.providedIn ? void 0 === i.value ? i.value = i.factory() : i.value : e & Z.Optional ? null : void 0 !== t ? t : void dl(Me(n), "Injector") } function Hi(n) { return { toString: n }.toString() } var Nn = (() => ((Nn = Nn || {})[Nn.OnPush = 0] = "OnPush", Nn[Nn.Default = 1] = "Default", Nn))(), In = (() => { return (n = In || (In = {}))[n.Emulated = 0] = "Emulated", n[n.None = 2] = "None", n[n.ShadowDom = 3] = "ShadowDom", In; var n })(); const TA = "undefined" != typeof globalThis && globalThis, SA = "undefined" != typeof window && window, AA = "undefined" != typeof self && "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && self, Re = TA || "undefined" != typeof global && global || SA || AA, Zr = {}, xe = [], fl = Oe({ \u0275cmp: Oe }), ad = Oe({ \u0275dir: Oe }), ld = Oe({ \u0275pipe: Oe }), $_ = Oe({ \u0275mod: Oe }), yi = Oe({ \u0275fac: Oe }), ws = Oe({ __NG_ELEMENT_ID__: Oe }); let MA = 0; function We(n) { return Hi(() => { const e = {}, i = { type: n.type, providersResolver: null, decls: n.decls, vars: n.vars, factory: null, template: n.template || null, consts: n.consts || null, ngContentSelectors: n.ngContentSelectors, hostBindings: n.hostBindings || null, hostVars: n.hostVars || 0, hostAttrs: n.hostAttrs || null, contentQueries: n.contentQueries || null, declaredInputs: e, inputs: null, outputs: null, exportAs: n.exportAs || null, onPush: n.changeDetection === Nn.OnPush, directiveDefs: null, pipeDefs: null, selectors: n.selectors || xe, viewQuery: n.viewQuery || null, features: n.features || null, data: n.data || {}, encapsulation: n.encapsulation || In.Emulated, id: "c", styles: n.styles || xe, _: null, setInput: null, schemas: n.schemas || null, tView: null }, r = n.directives, o = n.features, s = n.pipes; return i.id += MA++, i.inputs = K_(n.inputs, e), i.outputs = K_(n.outputs), o && o.forEach(a => a(i)), i.directiveDefs = r ? () => ("function" == typeof r ? r() : r).map(G_) : null, i.pipeDefs = s ? () => ("function" == typeof s ? s() : s).map(W_) : null, i }) } function G_(n) { return At(n) || function ji(n) { return n[ad] || null }(n) } function W_(n) { return function pr(n) { return n[ld] || null }(n) } const z_ = {}; function se(n) { return Hi(() => { const t = { type: n.type, bootstrap: n.bootstrap || xe, declarations: n.declarations || xe, imports: n.imports || xe, exports: n.exports || xe, transitiveCompileScopes: null, schemas: n.schemas || null, id: n.id || null }; return null != n.id && (z_[n.id] = n.type), t }) } function K_(n, t) { if (null == n) return Zr; const e = {}; for (const i in n) if (n.hasOwnProperty(i)) { let r = n[i], o = r; Array.isArray(r) && (o = r[1], r = r[0]), e[r] = i, t && (t[r] = o) } return e } const S = We; function At(n) { return n[fl] || null } function dn(n, t) { const e = n[$_] || null; if (!e && !0 === t) throw new Error(`Type ${Me(n)} does not have '\u0275mod' property.`); return e } function Qn(n) { return Array.isArray(n) && "object" == typeof n[1] } function On(n) { return Array.isArray(n) && !0 === n[1] } function dd(n) { return 0 != (8 & n.flags) } function ml(n) { return 2 == (2 & n.flags) } function yl(n) { return 1 == (1 & n.flags) } function xn(n) { return null !== n.template } function PA(n) { return 0 != (512 & n[2]) } function yr(n, t) { return n.hasOwnProperty(yi) ? n[yi] : null } class LA { constructor(t, e, i) { this.previousValue = t, this.currentValue = e, this.firstChange = i } isFirstChange() { return this.firstChange } } function wt() { return Y_ } function Y_(n) { return n.type.prototype.ngOnChanges && (n.setInput = VA), BA } function BA() { const n = J_(this), t = null == n ? void 0 : n.current; if (t) { const e = n.previous; if (e === Zr) n.previous = t; else for (let i in t) e[i] = t[i]; n.current = null, this.ngOnChanges(t) } } function VA(n, t, e, i) { const r = J_(n) || function HA(n, t) { return n[Q_] = t }(n, { previous: Zr, current: null }), o = r.current || (r.current = {}), s = r.previous, a = this.declaredInputs[e], l = s[a]; o[a] = new LA(l && l.currentValue, t, s === Zr), n[i] = t } wt.ngInherit = !0; const Q_ = "__ngSimpleChanges__"; function J_(n) { return n[Q_] || null } let pd; function Ye(n) { return !!n.listen } const em = { createRenderer: (n, t) => function gd() { return void 0 !== pd ? pd : "undefined" != typeof document ? document : void 0 }() }; function rt(n) { for (; Array.isArray(n);)n = n[0]; return n } function bl(n, t) { return rt(t[n]) } function pn(n, t) { return rt(t[n.index]) } function _d(n, t) { return n.data[t] } function tn(n, t) { const e = t[n]; return Qn(e) ? e : e[0] } function tm(n) { return 4 == (4 & n[2]) } function md(n) { return 128 == (128 & n[2]) } function Ui(n, t) { return null == t ? null : n[t] } function nm(n) { n[18] = 0 } function yd(n, t) { n[5] += t; let e = n, i = n[3]; for (; null !== i && (1 === t && 1 === e[5] || -1 === t && 0 === e[5]);)i[5] += t, e = i, i = i[3] } const z = { lFrame: um(null), bindingsEnabled: !0, isInCheckNoChangesMode: !1 }; function im() { return z.bindingsEnabled } function w() { return z.lFrame.lView } function me() { return z.lFrame.tView } function ze(n) { return z.lFrame.contextLView = n, n[8] } function ut() { let n = rm(); for (; null !== n && 64 === n.type;)n = n.parent; return n } function rm() { return z.lFrame.currentTNode } function Jn(n, t) { const e = z.lFrame; e.currentTNode = n, e.isParent = t } function bd() { return z.lFrame.isParent } function vd() { z.lFrame.isParent = !1 } function vl() { return z.isInCheckNoChangesMode } function Dl(n) { z.isInCheckNoChangesMode = n } function Ft() { const n = z.lFrame; let t = n.bindingRootIndex; return -1 === t && (t = n.bindingRootIndex = n.tView.bindingStartIndex), t } function ro() { return z.lFrame.bindingIndex++ } function vi(n) { const t = z.lFrame, e = t.bindingIndex; return t.bindingIndex = t.bindingIndex + n, e } function eM(n, t) { const e = z.lFrame; e.bindingIndex = e.bindingRootIndex = n, Dd(t) } function Dd(n) { z.lFrame.currentDirectiveIndex = n } function am() { return z.lFrame.currentQueryIndex } function Ed(n) { z.lFrame.currentQueryIndex = n } function nM(n) { const t = n[1]; return 2 === t.type ? t.declTNode : 1 === t.type ? n[6] : null } function lm(n, t, e) { if (e & Z.SkipSelf) { let r = t, o = n; for (; !(r = r.parent, null !== r || e & Z.Host || (r = nM(o), null === r || (o = o[15], 10 & r.type)));); if (null === r) return !1; t = r, n = o } const i = z.lFrame = cm(); return i.currentTNode = t, i.lView = n, !0 } function Cl(n) { const t = cm(), e = n[1]; z.lFrame = t, t.currentTNode = e.firstChild, t.lView = n, t.tView = e, t.contextLView = n, t.bindingIndex = e.bindingStartIndex, t.inI18n = !1 } function cm() { const n = z.lFrame, t = null === n ? null : n.child; return null === t ? um(n) : t } function um(n) { const t = { currentTNode: null, isParent: !0, lView: null, tView: null, selectedIndex: -1, contextLView: null, elementDepthCount: 0, currentNamespace: null, currentDirectiveIndex: -1, bindingRootIndex: -1, bindingIndex: -1, currentQueryIndex: 0, parent: n, child: null, inI18n: !1 }; return null !== n && (n.child = t), t } function dm() { const n = z.lFrame; return z.lFrame = n.parent, n.currentTNode = null, n.lView = null, n } const hm = dm; function El() { const n = dm(); n.isParent = !0, n.tView = null, n.selectedIndex = -1, n.contextLView = null, n.elementDepthCount = 0, n.currentDirectiveIndex = -1, n.currentNamespace = null, n.bindingRootIndex = -1, n.bindingIndex = -1, n.currentQueryIndex = 0 } function Lt() { return z.lFrame.selectedIndex } function $i(n) { z.lFrame.selectedIndex = n } function Qe() { const n = z.lFrame; return _d(n.tView, n.selectedIndex) } function wl(n, t) { for (let e = t.directiveStart, i = t.directiveEnd; e < i; e++) { const o = n.data[e].type.prototype, { ngAfterContentInit: s, ngAfterContentChecked: a, ngAfterViewInit: l, ngAfterViewChecked: c, ngOnDestroy: u } = o; s && (n.contentHooks || (n.contentHooks = [])).push(-e, s), a && ((n.contentHooks || (n.contentHooks = [])).push(e, a), (n.contentCheckHooks || (n.contentCheckHooks = [])).push(e, a)), l && (n.viewHooks || (n.viewHooks = [])).push(-e, l), c && ((n.viewHooks || (n.viewHooks = [])).push(e, c), (n.viewCheckHooks || (n.viewCheckHooks = [])).push(e, c)), null != u && (n.destroyHooks || (n.destroyHooks = [])).push(e, u) } } function Tl(n, t, e) { fm(n, t, 3, e) } function Sl(n, t, e, i) { (3 & n[2]) === e && fm(n, t, e, i) } function wd(n, t) { let e = n[2]; (3 & e) === t && (e &= 2047, e += 1, n[2] = e) } function fm(n, t, e, i) { const o = null != i ? i : -1, s = t.length - 1; let a = 0; for (let l = void 0 !== i ? 65535 & n[18] : 0; l < s; l++)if ("number" == typeof t[l + 1]) { if (a = t[l], null != i && a >= i) break } else t[l] < 0 && (n[18] += 65536), (a < o || -1 == o) && (dM(n, e, t, l), n[18] = (4294901760 & n[18]) + l + 2), l++ } function dM(n, t, e, i) { const r = e[i] < 0, o = e[i + 1], a = n[r ? -e[i] : e[i]]; if (r) { if (n[2] >> 11 < n[18] >> 16 && (3 & n[2]) === t) { n[2] += 2048; try { o.call(a) } finally { } } } else try { o.call(a) } finally { } } class Ns { constructor(t, e, i) { this.factory = t, this.resolving = !1, this.canSeeViewProviders = e, this.injectImpl = i } } function Al(n, t, e) { const i = Ye(n); let r = 0; for (; r < e.length;) { const o = e[r]; if ("number" == typeof o) { if (0 !== o) break; r++; const s = e[r++], a = e[r++], l = e[r++]; i ? n.setAttribute(t, a, l, s) : t.setAttributeNS(s, a, l) } else { const s = o, a = e[++r]; Sd(s) ? i && n.setProperty(t, s, a) : i ? n.setAttribute(t, s, a) : t.setAttribute(s, a), r++ } } return r } function pm(n) { return 3 === n || 4 === n || 6 === n } function Sd(n) { return 64 === n.charCodeAt(0) } function Ml(n, t) { if (null !== t && 0 !== t.length) if (null === n || 0 === n.length) n = t.slice(); else { let e = -1; for (let i = 0; i < t.length; i++) { const r = t[i]; "number" == typeof r ? e = r : 0 === e || gm(n, e, r, null, -1 === e || 2 === e ? t[++i] : null) } } return n } function gm(n, t, e, i, r) { let o = 0, s = n.length; if (-1 === t) s = -1; else for (; o < n.length;) { const a = n[o++]; if ("number" == typeof a) { if (a === t) { s = -1; break } if (a > t) { s = o - 1; break } } } for (; o < n.length;) { const a = n[o]; if ("number" == typeof a) break; if (a === e) { if (null === i) return void (null !== r && (n[o + 1] = r)); if (i === n[o + 1]) return void (n[o + 2] = r) } o++, null !== i && o++, null !== r && o++ } -1 !== s && (n.splice(s, 0, t), o = s + 1), n.splice(o++, 0, e), null !== i && n.splice(o++, 0, i), null !== r && n.splice(o++, 0, r) } function _m(n) { return -1 !== n } function oo(n) { return 32767 & n } function so(n, t) { let e = function _M(n) { return n >> 16 }(n), i = t; for (; e > 0;)i = i[15], e--; return i } let Ad = !0; function Nl(n) { const t = Ad; return Ad = n, t } let mM = 0; function Rs(n, t) { const e = Nd(n, t); if (-1 !== e) return e; const i = t[1]; i.firstCreatePass && (n.injectorIndex = t.length, Md(i.data, n), Md(t, null), Md(i.blueprint, null)); const r = Il(n, t), o = n.injectorIndex; if (_m(r)) { const s = oo(r), a = so(r, t), l = a[1].data; for (let c = 0; c < 8; c++)t[o + c] = a[s + c] | l[s + c] } return t[o + 8] = r, o } function Md(n, t) { n.push(0, 0, 0, 0, 0, 0, 0, 0, t) } function Nd(n, t) { return -1 === n.injectorIndex || n.parent && n.parent.injectorIndex === n.injectorIndex || null === t[n.injectorIndex + 8] ? -1 : n.injectorIndex } function Il(n, t) { if (n.parent && -1 !== n.parent.injectorIndex) return n.parent.injectorIndex; let e = 0, i = null, r = t; for (; null !== r;) { const o = r[1], s = o.type; if (i = 2 === s ? o.declTNode : 1 === s ? r[6] : null, null === i) return -1; if (e++, r = r[15], -1 !== i.injectorIndex) return i.injectorIndex | e << 16 } return -1 } function Rl(n, t, e) { !function yM(n, t, e) { let i; "string" == typeof e ? i = e.charCodeAt(0) || 0 : e.hasOwnProperty(ws) && (i = e[ws]), null == i && (i = e[ws] = mM++); const r = 255 & i; t.data[n + (r >> 5)] |= 1 << r }(n, t, e) } function bm(n, t, e) { if (e & Z.Optional) return n; dl(t, "NodeInjector") } function vm(n, t, e, i) { if (e & Z.Optional && void 0 === i && (i = null), 0 == (e & (Z.Self | Z.Host))) { const r = n[9], o = Vi(void 0); try { return r ? r.get(t, i, e & Z.Optional) : U_(t, i, e & Z.Optional) } finally { Vi(o) } } return bm(i, t, e) } function Dm(n, t, e, i = Z.Default, r) { if (null !== n) { const o = function CM(n) { if ("string" == typeof n) return n.charCodeAt(0) || 0; const t = n.hasOwnProperty(ws) ? n[ws] : void 0; return "number" == typeof t ? t >= 0 ? 255 & t : vM : t }(e); if ("function" == typeof o) { if (!lm(t, n, i)) return i & Z.Host ? bm(r, e, i) : vm(t, e, i, r); try { const s = o(i); if (null != s || i & Z.Optional) return s; dl(e) } finally { hm() } } else if ("number" == typeof o) { let s = null, a = Nd(n, t), l = -1, c = i & Z.Host ? t[16][6] : null; for ((-1 === a || i & Z.SkipSelf) && (l = -1 === a ? Il(n, t) : t[a + 8], -1 !== l && wm(i, !1) ? (s = t[1], a = oo(l), t = so(l, t)) : a = -1); -1 !== a;) { const u = t[1]; if (Em(o, a, u.data)) { const d = DM(a, t, e, s, i, c); if (d !== Cm) return d } l = t[a + 8], -1 !== l && wm(i, t[1].data[a + 8] === c) && Em(o, a, t) ? (s = u, a = oo(l), t = so(l, t)) : a = -1 } } } return vm(t, e, i, r) } const Cm = {}; function vM() { return new ao(ut(), w()) } function DM(n, t, e, i, r, o) { const s = t[1], a = s.data[n + 8], u = Ol(a, s, e, null == i ? ml(a) && Ad : i != s && 0 != (3 & a.type), r & Z.Host && o === a); return null !== u ? Os(t, s, u, a) : Cm } function Ol(n, t, e, i, r) { const o = n.providerIndexes, s = t.data, a = 1048575 & o, l = n.directiveStart, u = o >> 20, h = r ? a + u : n.directiveEnd; for (let f = i ? a : a + u; f < h; f++) { const p = s[f]; if (f < l && e === p || f >= l && p.type === e) return f } if (r) { const f = s[l]; if (f && xn(f) && f.type === e) return l } return null } function Os(n, t, e, i) { let r = n[e]; const o = t.data; if (function hM(n) { return n instanceof Ns }(r)) { const s = r; s.resolving && function mA(n, t) { const e = t ? `. Dependency path: ${t.join(" > ")} > ${n}` : ""; throw new _e(-200, `Circular dependency in DI detected for ${n}${e}`) }(kt(o[e])); const a = Nl(s.canSeeViewProviders); s.resolving = !0; const l = s.injectImpl ? Vi(s.injectImpl) : null; lm(n, i, Z.Default); try { r = n[e] = s.factory(void 0, o, n, i), t.firstCreatePass && e >= i.directiveStart && function uM(n, t, e) { const { ngOnChanges: i, ngOnInit: r, ngDoCheck: o } = t.type.prototype; if (i) { const s = Y_(t); (e.preOrderHooks || (e.preOrderHooks = [])).push(n, s), (e.preOrderCheckHooks || (e.preOrderCheckHooks = [])).push(n, s) } r && (e.preOrderHooks || (e.preOrderHooks = [])).push(0 - n, r), o && ((e.preOrderHooks || (e.preOrderHooks = [])).push(n, o), (e.preOrderCheckHooks || (e.preOrderCheckHooks = [])).push(n, o)) }(e, o[e], t) } finally { null !== l && Vi(l), Nl(a), s.resolving = !1, hm() } } return r } function Em(n, t, e) { return !!(e[t + (n >> 5)] & 1 << n) } function wm(n, t) { return !(n & Z.Self || n & Z.Host && t) } class ao { constructor(t, e) { this._tNode = t, this._lView = e } get(t, e, i) { return Dm(this._tNode, this._lView, t, i, e) } } function Id(n) { return B_(n) ? () => { const t = Id(ee(n)); return t && t() } : yr(n) } function Wi(n) { return function bM(n, t) { if ("class" === t) return n.classes; if ("style" === t) return n.styles; const e = n.attrs; if (e) { const i = e.length; let r = 0; for (; r < i;) { const o = e[r]; if (pm(o)) break; if (0 === o) r += 2; else if ("number" == typeof o) for (r++; r < i && "string" == typeof e[r];)r++; else { if (o === t) return e[r + 1]; r += 2 } } } return null }(ut(), n) } const co = "__parameters__"; function ho(n, t, e) { return Hi(() => { const i = function Rd(n) { return function(...e) { if (n) { const i = n(...e); for (const r in i) this[r] = i[r] } } }(t); function r(...o) { if (this instanceof r) return i.apply(this, o), this; const s = new r(...o); return a.annotation = s, a; function a(l, c, u) { const d = l.hasOwnProperty(co) ? l[co] : Object.defineProperty(l, co, { value: [] })[co]; for (; d.length <= u;)d.push(null); return (d[u] = d[u] || []).push(s), l } } return e && (r.prototype = Object.create(e.prototype)), r.prototype.ngMetadataName = n, r.annotationCls = r, r }) } class P { constructor(t, e) { this._desc = t, this.ngMetadataName = "InjectionToken", this.\u0275prov = void 0, "number" == typeof e ? this.__NG_ELEMENT_ID__ = e : void 0 !== e && (this.\u0275prov = R({ token: this, providedIn: e.providedIn || "root", factory: e.factory })) } toString() { return `InjectionToken ${this._desc}` } } const wM = new P("AnalyzeForEntryComponents"); function gn(n, t) { void 0 === t && (t = n); for (let e = 0; e < n.length; e++) { let i = n[e]; Array.isArray(i) ? (t === n && (t = n.slice(0, e)), gn(i, t)) : t !== n && t.push(i) } return t } function Zn(n, t) { n.forEach(e => Array.isArray(e) ? Zn(e, t) : t(e)) } function Sm(n, t, e) { t >= n.length ? n.push(e) : n.splice(t, 0, e) } function xl(n, t) { return t >= n.length - 1 ? n.pop() : n.splice(t, 1)[0] } function ks(n, t) { const e = []; for (let i = 0; i < n; i++)e.push(t); return e } function nn(n, t, e) { let i = fo(n, t); return i >= 0 ? n[1 | i] = e : (i = ~i, function AM(n, t, e, i) { let r = n.length; if (r == t) n.push(e, i); else if (1 === r) n.push(i, n[0]), n[0] = e; else { for (r--, n.push(n[r - 1], n[r]); r > t;)n[r] = n[r - 2], r--; n[t] = e, n[t + 1] = i } }(n, i, t, e)), i } function xd(n, t) { const e = fo(n, t); if (e >= 0) return n[1 | e] } function fo(n, t) { return function Nm(n, t, e) { let i = 0, r = n.length >> e; for (; r !== i;) { const o = i + (r - i >> 1), s = n[o << e]; if (t === s) return o << e; s > t ? r = o : i = o + 1 } return ~(r << e) }(n, t, 1) } const Fs = {}, kd = "__NG_DI_FLAG__", kl = "ngTempTokenPath", PM = /\n/gm, Rm = "__source", FM = Oe({ provide: String, useValue: Oe }); let Ls; function Om(n) { const t = Ls; return Ls = n, t } function LM(n, t = Z.Default) { if (void 0 === Ls) throw new _e(203, ""); return null === Ls ? U_(n, void 0, t) : Ls.get(n, t & Z.Optional ? null : void 0, t) } function E(n, t = Z.Default) { return (function wA() { return sd }() || LM)(ee(n), t) } const Fd = E; function Ld(n) { const t = []; for (let e = 0; e < n.length; e++) { const i = ee(n[e]); if (Array.isArray(i)) { if (0 === i.length) throw new _e(900, ""); let r, o = Z.Default; for (let s = 0; s < i.length; s++) { const a = i[s], l = BM(a); "number" == typeof l ? -1 === l ? r = a.token : o |= l : r = a } t.push(E(r, o)) } else t.push(E(i)) } return t } function Bs(n, t) { return n[kd] = t, n.prototype[kd] = t, n } function BM(n) { return n[kd] } const Vs = Bs(ho("Inject", n => ({ token: n })), -1), rn = Bs(ho("Optional"), 8), br = Bs(ho("SkipSelf"), 4); let Ll; function go(n) { var t; return (null === (t = function Vd() { if (void 0 === Ll && (Ll = null, Re.trustedTypes)) try { Ll = Re.trustedTypes.createPolicy("angular", { createHTML: n => n, createScript: n => n, createScriptURL: n => n }) } catch (n) { } return Ll }()) || void 0 === t ? void 0 : t.createHTML(n)) || n } class vr { constructor(t) { this.changingThisBreaksApplicationSecurity = t } toString() { return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see https://g.co/ng/security#xss)` } } class JM extends vr { getTypeName() { return "HTML" } } class ZM extends vr { getTypeName() { return "Style" } } class XM extends vr { getTypeName() { return "Script" } } class eN extends vr { getTypeName() { return "URL" } } class tN extends vr { getTypeName() { return "ResourceURL" } } function on(n) { return n instanceof vr ? n.changingThisBreaksApplicationSecurity : n } function Xn(n, t) { const e = jm(n); if (null != e && e !== t) { if ("ResourceURL" === e && "URL" === t) return !0; throw new Error(`Required a safe ${t}, got a ${e} (see https://g.co/ng/security#xss)`) } return e === t } function jm(n) { return n instanceof vr && n.getTypeName() || null } class aN { constructor(t) { this.inertDocumentHelper = t } getInertBodyElement(t) { t = "<body><remove></remove>" + t; try { const e = (new window.DOMParser).parseFromString(go(t), "text/html").body; return null === e ? this.inertDocumentHelper.getInertBodyElement(t) : (e.removeChild(e.firstChild), e) } catch (e) { return null } } } class lN { constructor(t) { if (this.defaultDoc = t, this.inertDocument = this.defaultDoc.implementation.createHTMLDocument("sanitization-inert"), null == this.inertDocument.body) { const e = this.inertDocument.createElement("html"); this.inertDocument.appendChild(e); const i = this.inertDocument.createElement("body"); e.appendChild(i) } } getInertBodyElement(t) { const e = this.inertDocument.createElement("template"); if ("content" in e) return e.innerHTML = go(t), e; const i = this.inertDocument.createElement("body"); return i.innerHTML = go(t), this.defaultDoc.documentMode && this.stripCustomNsAttrs(i), i } stripCustomNsAttrs(t) { const e = t.attributes; for (let r = e.length - 1; 0 < r; r--) { const s = e.item(r).name; ("xmlns:ns1" === s || 0 === s.indexOf("ns1:")) && t.removeAttribute(s) } let i = t.firstChild; for (; i;)i.nodeType === Node.ELEMENT_NODE && this.stripCustomNsAttrs(i), i = i.nextSibling } } const uN = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^&:/?#]*(?:[/?#]|$))/gi, dN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i; function js(n) { return (n = String(n)).match(uN) || n.match(dN) ? n : "unsafe:" + n } function ei(n) { const t = {}; for (const e of n.split(",")) t[e] = !0; return t } function Us(...n) { const t = {}; for (const e of n) for (const i in e) e.hasOwnProperty(i) && (t[i] = !0); return t } const Gm = ei("area,br,col,hr,img,wbr"), Wm = ei("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"), zm = ei("rp,rt"), jd = Us(Gm, Us(Wm, ei("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul")), Us(zm, ei("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video")), Us(zm, Wm)), Ud = ei("background,cite,href,itemtype,longdesc,poster,src,xlink:href"), $d = ei("srcset"), Km = Us(Ud, $d, ei("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width"), ei("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext")), hN = ei("script,style,template"); class fN { constructor() { this.sanitizedSomething = !1, this.buf = [] } sanitizeChildren(t) { let e = t.firstChild, i = !0; for (; e;)if (e.nodeType === Node.ELEMENT_NODE ? i = this.startElement(e) : e.nodeType === Node.TEXT_NODE ? this.chars(e.nodeValue) : this.sanitizedSomething = !0, i && e.firstChild) e = e.firstChild; else for (; e;) { e.nodeType === Node.ELEMENT_NODE && this.endElement(e); let r = this.checkClobberedElement(e, e.nextSibling); if (r) { e = r; break } e = this.checkClobberedElement(e, e.parentNode) } return this.buf.join("") } startElement(t) { const e = t.nodeName.toLowerCase(); if (!jd.hasOwnProperty(e)) return this.sanitizedSomething = !0, !hN.hasOwnProperty(e); this.buf.push("<"), this.buf.push(e); const i = t.attributes; for (let r = 0; r < i.length; r++) { const o = i.item(r), s = o.name, a = s.toLowerCase(); if (!Km.hasOwnProperty(a)) { this.sanitizedSomething = !0; continue } let l = o.value; Ud[a] && (l = js(l)), $d[a] && (n = l, l = (n = String(n)).split(",").map(t => js(t.trim())).join(", ")), this.buf.push(" ", s, '="', qm(l), '"') } var n; return this.buf.push(">"), !0 } endElement(t) { const e = t.nodeName.toLowerCase(); jd.hasOwnProperty(e) && !Gm.hasOwnProperty(e) && (this.buf.push("</"), this.buf.push(e), this.buf.push(">")) } chars(t) { this.buf.push(qm(t)) } checkClobberedElement(t, e) { if (e && (t.compareDocumentPosition(e) & Node.DOCUMENT_POSITION_CONTAINED_BY) === Node.DOCUMENT_POSITION_CONTAINED_BY) throw new Error(`Failed to sanitize html because the element is clobbered: ${t.outerHTML}`); return e } } const pN = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, gN = /([^\#-~ |!])/g; function qm(n) { return n.replace(/&/g, "&amp;").replace(pN, function(t) { return "&#" + (1024 * (t.charCodeAt(0) - 55296) + (t.charCodeAt(1) - 56320) + 65536) + ";" }).replace(gN, function(t) { return "&#" + t.charCodeAt(0) + ";" }).replace(/</g, "&lt;").replace(/>/g, "&gt;") } let Vl; function Ym(n, t) { let e = null; try { Vl = Vl || function Um(n) { const t = new lN(n); return function cN() { try { return !!(new window.DOMParser).parseFromString(go(""), "text/html") } catch (n) { return !1 } }() ? new aN(t) : t }(n); let i = t ? String(t) : ""; e = Vl.getInertBodyElement(i); let r = 5, o = i; do { if (0 === r) throw new Error("Failed to sanitize html because the input is unstable"); r--, i = o, o = e.innerHTML, e = Vl.getInertBodyElement(i) } while (i !== o); return go((new fN).sanitizeChildren(Gd(e) || e)) } finally { if (e) { const i = Gd(e) || e; for (; i.firstChild;)i.removeChild(i.firstChild) } } } function Gd(n) { return "content" in n && function _N(n) { return n.nodeType === Node.ELEMENT_NODE && "TEMPLATE" === n.nodeName }(n) ? n.content : null } var Ee = (() => ((Ee = Ee || {})[Ee.NONE = 0] = "NONE", Ee[Ee.HTML = 1] = "HTML", Ee[Ee.STYLE = 2] = "STYLE", Ee[Ee.SCRIPT = 3] = "SCRIPT", Ee[Ee.URL = 4] = "URL", Ee[Ee.RESOURCE_URL = 5] = "RESOURCE_URL", Ee))(); function Wd(n) { const t = function $s() { const n = w(); return n && n[12] }(); return t ? t.sanitize(Ee.URL, n) || "" : Xn(n, "URL") ? on(n) : js(Y(n)) } const Zm = "__ngContext__"; function Nt(n, t) { n[Zm] = t } function Kd(n) { const t = function Gs(n) { return n[Zm] || null }(n); return t ? Array.isArray(t) ? t : t.lView : null } function Yd(n) { return n.ngOriginalError } function xN(n, ...t) { n.error(...t) } class Di { constructor() { this._console = console } handleError(t) { const e = this._findOriginalError(t), i = function ON(n) { return n && n.ngErrorLogger || xN }(t); i(this._console, "ERROR", t), e && i(this._console, "ORIGINAL ERROR", e) } _findOriginalError(t) { let e = t && Yd(t); for (; e && Yd(e);)e = Yd(e); return e || null } } const iy = (() => ("undefined" != typeof requestAnimationFrame && requestAnimationFrame || setTimeout).bind(Re))(); function ti(n) { return n instanceof Function ? n() : n } var sn = (() => ((sn = sn || {})[sn.Important = 1] = "Important", sn[sn.DashCase = 2] = "DashCase", sn))(); function Jd(n, t) { return undefined(n, t) } function Ws(n) { const t = n[3]; return On(t) ? t[3] : t } function Zd(n) { return ly(n[13]) } function Xd(n) { return ly(n[4]) } function ly(n) { for (; null !== n && !On(n);)n = n[4]; return n } function mo(n, t, e, i, r) { if (null != i) { let o, s = !1; On(i) ? o = i : Qn(i) && (s = !0, i = i[0]); const a = rt(i); 0 === n && null !== e ? null == r ? py(t, e, a) : Dr(t, e, a, r || null, !0) : 1 === n && null !== e ? Dr(t, e, a, r || null, !0) : 2 === n ? function Dy(n, t, e) { const i = Hl(n, t); i && function nI(n, t, e, i) { Ye(n) ? n.removeChild(t, e, i) : t.removeChild(e) }(n, i, t, e) }(t, a, s) : 3 === n && t.destroyNode(a), null != o && function oI(n, t, e, i, r) { const o = e[7]; o !== rt(e) && mo(t, n, i, o, r); for (let a = 10; a < e.length; a++) { const l = e[a]; zs(l[1], l, n, t, i, o) } }(t, n, o, e, r) } } function th(n, t, e) { return Ye(n) ? n.createElement(t, e) : null === e ? n.createElement(t) : n.createElementNS(e, t) } function uy(n, t) { const e = n[9], i = e.indexOf(t), r = t[3]; 1024 & t[2] && (t[2] &= -1025, yd(r, -1)), e.splice(i, 1) } function nh(n, t) { if (n.length <= 10) return; const e = 10 + t, i = n[e]; if (i) { const r = i[17]; null !== r && r !== n && uy(r, i), t > 0 && (n[e - 1][4] = i[4]); const o = xl(n, 10 + t); !function qN(n, t) { zs(n, t, t[11], 2, null, null), t[0] = null, t[6] = null }(i[1], i); const s = o[19]; null !== s && s.detachView(o[1]), i[3] = null, i[4] = null, i[2] &= -129 } return i } function dy(n, t) { if (!(256 & t[2])) { const e = t[11]; Ye(e) && e.destroyNode && zs(n, t, e, 3, null, null), function JN(n) { let t = n[13]; if (!t) return ih(n[1], n); for (; t;) { let e = null; if (Qn(t)) e = t[13]; else { const i = t[10]; i && (e = i) } if (!e) { for (; t && !t[4] && t !== n;)Qn(t) && ih(t[1], t), t = t[3]; null === t && (t = n), Qn(t) && ih(t[1], t), e = t && t[4] } t = e } }(t) } } function ih(n, t) { if (!(256 & t[2])) { t[2] &= -129, t[2] |= 256, function tI(n, t) { let e; if (null != n && null != (e = n.destroyHooks)) for (let i = 0; i < e.length; i += 2) { const r = t[e[i]]; if (!(r instanceof Ns)) { const o = e[i + 1]; if (Array.isArray(o)) for (let s = 0; s < o.length; s += 2) { const a = r[o[s]], l = o[s + 1]; try { l.call(a) } finally { } } else try { o.call(r) } finally { } } } }(n, t), function eI(n, t) { const e = n.cleanup, i = t[7]; let r = -1; if (null !== e) for (let o = 0; o < e.length - 1; o += 2)if ("string" == typeof e[o]) { const s = e[o + 1], a = "function" == typeof s ? s(t) : rt(t[s]), l = i[r = e[o + 2]], c = e[o + 3]; "boolean" == typeof c ? a.removeEventListener(e[o], l, c) : c >= 0 ? i[r = c]() : i[r = -c].unsubscribe(), o += 2 } else { const s = i[r = e[o + 1]]; e[o].call(s) } if (null !== i) { for (let o = r + 1; o < i.length; o++)i[o](); t[7] = null } }(n, t), 1 === t[1].type && Ye(t[11]) && t[11].destroy(); const e = t[17]; if (null !== e && On(t[3])) { e !== t[3] && uy(e, t); const i = t[19]; null !== i && i.detachView(n) } } } function hy(n, t, e) { return function fy(n, t, e) { let i = t; for (; null !== i && 40 & i.type;)i = (t = i).parent; if (null === i) return e[0]; if (2 & i.flags) { const r = n.data[i.directiveStart].encapsulation; if (r === In.None || r === In.Emulated) return null } return pn(i, e) }(n, t.parent, e) } function Dr(n, t, e, i, r) { Ye(n) ? n.insertBefore(t, e, i, r) : t.insertBefore(e, i, r) } function py(n, t, e) { Ye(n) ? n.appendChild(t, e) : t.appendChild(e) } function gy(n, t, e, i, r) { null !== i ? Dr(n, t, e, i, r) : py(n, t, e) } function Hl(n, t) { return Ye(n) ? n.parentNode(t) : t.parentNode } function _y(n, t, e) { return yy(n, t, e) } let yy = function my(n, t, e) { return 40 & n.type ? pn(n, e) : null }; function jl(n, t, e, i) { const r = hy(n, i, t), o = t[11], a = _y(i.parent || t[6], i, t); if (null != r) if (Array.isArray(e)) for (let l = 0; l < e.length; l++)gy(o, r, e[l], a, !1); else gy(o, r, e, a, !1) } function Ul(n, t) { if (null !== t) { const e = t.type; if (3 & e) return pn(t, n); if (4 & e) return oh(-1, n[t.index]); if (8 & e) { const i = t.child; if (null !== i) return Ul(n, i); { const r = n[t.index]; return On(r) ? oh(-1, r) : rt(r) } } if (32 & e) return Jd(t, n)() || rt(n[t.index]); { const i = vy(n, t); return null !== i ? Array.isArray(i) ? i[0] : Ul(Ws(n[16]), i) : Ul(n, t.next) } } return null } function vy(n, t) { return null !== t ? n[16][6].projection[t.projection] : null } function oh(n, t) { const e = 10 + n + 1; if (e < t.length) { const i = t[e], r = i[1].firstChild; if (null !== r) return Ul(i, r) } return t[7] } function sh(n, t, e, i, r, o, s) { for (; null != e;) { const a = i[e.index], l = e.type; if (s && 0 === t && (a && Nt(rt(a), i), e.flags |= 4), 64 != (64 & e.flags)) if (8 & l) sh(n, t, e.child, i, r, o, !1), mo(t, n, r, a, o); else if (32 & l) { const c = Jd(e, i); let u; for (; u = c();)mo(t, n, r, u, o); mo(t, n, r, a, o) } else 16 & l ? Cy(n, t, i, e, r, o) : mo(t, n, r, a, o); e = s ? e.projectionNext : e.next } } function zs(n, t, e, i, r, o) { sh(e, i, n.firstChild, t, r, o, !1) } function Cy(n, t, e, i, r, o) { const s = e[16], l = s[6].projection[i.projection]; if (Array.isArray(l)) for (let c = 0; c < l.length; c++)mo(t, n, r, l[c], o); else sh(n, t, l, s[3], r, o, !0) } function Ey(n, t, e) { Ye(n) ? n.setAttribute(t, "style", e) : t.style.cssText = e } function ah(n, t, e) { Ye(n) ? "" === e ? n.removeAttribute(t, "class") : n.setAttribute(t, "class", e) : t.className = e } function wy(n, t, e) { let i = n.length; for (; ;) { const r = n.indexOf(t, e); if (-1 === r) return r; if (0 === r || n.charCodeAt(r - 1) <= 32) { const o = t.length; if (r + o === i || n.charCodeAt(r + o) <= 32) return r } e = r + 1 } } const Ty = "ng-template"; function aI(n, t, e) { let i = 0; for (; i < n.length;) { let r = n[i++]; if (e && "class" === r) { if (r = n[i], -1 !== wy(r.toLowerCase(), t, 0)) return !0 } else if (1 === r) { for (; i < n.length && "string" == typeof (r = n[i++]);)if (r.toLowerCase() === t) return !0; return !1 } } return !1 } function Sy(n) { return 4 === n.type && n.value !== Ty } function lI(n, t, e) { return t === (4 !== n.type || e ? n.value : Ty) } function cI(n, t, e) { let i = 4; const r = n.attrs || [], o = function hI(n) { for (let t = 0; t < n.length; t++)if (pm(n[t])) return t; return n.length }(r); let s = !1; for (let a = 0; a < t.length; a++) { const l = t[a]; if ("number" != typeof l) { if (!s) if (4 & i) { if (i = 2 | 1 & i, "" !== l && !lI(n, l, e) || "" === l && 1 === t.length) { if (Pn(i)) return !1; s = !0 } } else { const c = 8 & i ? l : t[++a]; if (8 & i && null !== n.attrs) { if (!aI(n.attrs, c, e)) { if (Pn(i)) return !1; s = !0 } continue } const d = uI(8 & i ? "class" : l, r, Sy(n), e); if (-1 === d) { if (Pn(i)) return !1; s = !0; continue } if ("" !== c) { let h; h = d > o ? "" : r[d + 1].toLowerCase(); const f = 8 & i ? h : null; if (f && -1 !== wy(f, c, 0) || 2 & i && c !== h) { if (Pn(i)) return !1; s = !0 } } } } else { if (!s && !Pn(i) && !Pn(l)) return !1; if (s && Pn(l)) continue; s = !1, i = l | 1 & i } } return Pn(i) || s } function Pn(n) { return 0 == (1 & n) } function uI(n, t, e, i) { if (null === t) return -1; let r = 0; if (i || !e) { let o = !1; for (; r < t.length;) { const s = t[r]; if (s === n) return r; if (3 === s || 6 === s) o = !0; else { if (1 === s || 2 === s) { let a = t[++r]; for (; "string" == typeof a;)a = t[++r]; continue } if (4 === s) break; if (0 === s) { r += 4; continue } } r += o ? 1 : 2 } return -1 } return function fI(n, t) { let e = n.indexOf(4); if (e > -1) for (e++; e < n.length;) { const i = n[e]; if ("number" == typeof i) return -1; if (i === t) return e; e++ } return -1 }(t, n) } function Ay(n, t, e = !1) { for (let i = 0; i < t.length; i++)if (cI(n, t[i], e)) return !0; return !1 } function pI(n, t) { e: for (let e = 0; e < t.length; e++) { const i = t[e]; if (n.length === i.length) { for (let r = 0; r < n.length; r++)if (n[r] !== i[r]) continue e; return !0 } } return !1 } function My(n, t) { return n ? ":not(" + t.trim() + ")" : t } function gI(n) { let t = n[0], e = 1, i = 2, r = "", o = !1; for (; e < n.length;) { let s = n[e]; if ("string" == typeof s) if (2 & i) { const a = n[++e]; r += "[" + s + (a.length > 0 ? '="' + a + '"' : "") + "]" } else 8 & i ? r += "." + s : 4 & i && (r += " " + s); else "" !== r && !Pn(s) && (t += My(o, r), r = ""), i = s, o = o || !Pn(i); e++ } return "" !== r && (t += My(o, r)), t } const Q = {}; function O(n) { Ny(me(), w(), Lt() + n, vl()) } function Ny(n, t, e, i) { if (!i) if (3 == (3 & t[2])) { const o = n.preOrderCheckHooks; null !== o && Tl(t, o, e) } else { const o = n.preOrderHooks; null !== o && Sl(t, o, 0, e) } $i(e) } function $l(n, t) { return n << 17 | t << 2 } function kn(n) { return n >> 17 & 32767 } function lh(n) { return 2 | n } function Ci(n) { return (131068 & n) >> 2 } function ch(n, t) { return -131069 & n | t << 2 } function uh(n) { return 1 | n } function Hy(n, t) { const e = n.contentQueries; if (null !== e) for (let i = 0; i < e.length; i += 2) { const r = e[i], o = e[i + 1]; if (-1 !== o) { const s = n.data[o]; Ed(r), s.contentQueries(2, t[o], o) } } } function Ks(n, t, e, i, r, o, s, a, l, c) { const u = t.blueprint.slice(); return u[0] = r, u[2] = 140 | i, nm(u), u[3] = u[15] = n, u[8] = e, u[10] = s || n && n[10], u[11] = a || n && n[11], u[12] = l || n && n[12] || null, u[9] = c || n && n[9] || null, u[6] = o, u[16] = 2 == t.type ? n[16] : u, u } function yo(n, t, e, i, r) { let o = n.data[t]; if (null === o) o = function bh(n, t, e, i, r) { const o = rm(), s = bd(), l = n.data[t] = function xI(n, t, e, i, r, o) { return { type: e, index: i, insertBeforeIndex: null, injectorIndex: t ? t.injectorIndex : -1, directiveStart: -1, directiveEnd: -1, directiveStylingLast: -1, propertyBindings: null, flags: 0, providerIndexes: 0, value: r, attrs: o, mergedAttrs: null, localNames: null, initialInputs: void 0, inputs: null, outputs: null, tViews: null, next: null, projectionNext: null, child: null, parent: t, projection: null, styles: null, stylesWithoutHost: null, residualStyles: void 0, classes: null, classesWithoutHost: null, residualClasses: void 0, classBindings: 0, styleBindings: 0 } }(0, s ? o : o && o.parent, e, t, i, r); return null === n.firstChild && (n.firstChild = l), null !== o && (s ? null == o.child && null !== l.parent && (o.child = l) : null === o.next && (o.next = l)), l }(n, t, e, i, r), function XA() { return z.lFrame.inI18n }() && (o.flags |= 64); else if (64 & o.type) { o.type = e, o.value = i, o.attrs = r; const s = function Ms() { const n = z.lFrame, t = n.currentTNode; return n.isParent ? t : t.parent }(); o.injectorIndex = null === s ? -1 : s.injectorIndex } return Jn(o, !0), o } function bo(n, t, e, i) { if (0 === e) return -1; const r = t.length; for (let o = 0; o < e; o++)t.push(i), n.blueprint.push(i), n.data.push(null); return r } function qs(n, t, e) { Cl(t); try { const i = n.viewQuery; null !== i && Mh(1, i, e); const r = n.template; null !== r && jy(n, t, r, 1, e), n.firstCreatePass && (n.firstCreatePass = !1), n.staticContentQueries && Hy(n, t), n.staticViewQueries && Mh(2, n.viewQuery, e); const o = n.components; null !== o && function II(n, t) { for (let e = 0; e < t.length; e++)JI(n, t[e]) }(t, o) } catch (i) { throw n.firstCreatePass && (n.incompleteFirstPass = !0, n.firstCreatePass = !1), i } finally { t[2] &= -5, El() } } function vo(n, t, e, i) { const r = t[2]; if (256 == (256 & r)) return; Cl(t); const o = vl(); try { nm(t), function om(n) { return z.lFrame.bindingIndex = n }(n.bindingStartIndex), null !== e && jy(n, t, e, 2, i); const s = 3 == (3 & r); if (!o) if (s) { const c = n.preOrderCheckHooks; null !== c && Tl(t, c, null) } else { const c = n.preOrderHooks; null !== c && Sl(t, c, 0, null), wd(t, 0) } if (function YI(n) { for (let t = Zd(n); null !== t; t = Xd(t)) { if (!t[2]) continue; const e = t[9]; for (let i = 0; i < e.length; i++) { const r = e[i], o = r[3]; 0 == (1024 & r[2]) && yd(o, 1), r[2] |= 1024 } } }(t), function qI(n) { for (let t = Zd(n); null !== t; t = Xd(t))for (let e = 10; e < t.length; e++) { const i = t[e], r = i[1]; md(i) && vo(r, i, r.template, i[8]) } }(t), null !== n.contentQueries && Hy(n, t), !o) if (s) { const c = n.contentCheckHooks; null !== c && Tl(t, c) } else { const c = n.contentHooks; null !== c && Sl(t, c, 1), wd(t, 1) } !function MI(n, t) { const e = n.hostBindingOpCodes; if (null !== e) try { for (let i = 0; i < e.length; i++) { const r = e[i]; if (r < 0) $i(~r); else { const o = r, s = e[++i], a = e[++i]; eM(s, o), a(2, t[o]) } } } finally { $i(-1) } }(n, t); const a = n.components; null !== a && function NI(n, t) { for (let e = 0; e < t.length; e++)QI(n, t[e]) }(t, a); const l = n.viewQuery; if (null !== l && Mh(2, l, i), !o) if (s) { const c = n.viewCheckHooks; null !== c && Tl(t, c) } else { const c = n.viewHooks; null !== c && Sl(t, c, 2), wd(t, 2) } !0 === n.firstUpdatePass && (n.firstUpdatePass = !1), o || (t[2] &= -73), 1024 & t[2] && (t[2] &= -1025, yd(t[3], -1)) } finally { El() } } function RI(n, t, e, i) { const r = t[10], o = !vl(), s = tm(t); try { o && !s && r.begin && r.begin(), s && qs(n, t, i), vo(n, t, e, i) } finally { o && !s && r.end && r.end() } } function jy(n, t, e, i, r) { const o = Lt(), s = 2 & i; try { $i(-1), s && t.length > 20 && Ny(n, t, 20, vl()), e(i, r) } finally { $i(o) } } function vh(n, t, e) { !im() || (function HI(n, t, e, i) { const r = e.directiveStart, o = e.directiveEnd; n.firstCreatePass || Rs(e, t), Nt(i, t); const s = e.initialInputs; for (let a = r; a < o; a++) { const l = n.data[a], c = xn(l); c && WI(t, e, l); const u = Os(t, n, a, e); Nt(u, t), null !== s && zI(0, a - r, u, l, 0, s), c && (tn(e.index, t)[8] = u) } }(n, t, e, pn(e, t)), 128 == (128 & e.flags) && function jI(n, t, e) { const i = e.directiveStart, r = e.directiveEnd, s = e.index, a = function tM() { return z.lFrame.currentDirectiveIndex }(); try { $i(s); for (let l = i; l < r; l++) { const c = n.data[l], u = t[l]; Dd(l), (null !== c.hostBindings || 0 !== c.hostVars || null !== c.hostAttrs) && Qy(c, u) } } finally { $i(-1), Dd(a) } }(n, t, e)) } function Dh(n, t, e = pn) { const i = t.localNames; if (null !== i) { let r = t.index + 1; for (let o = 0; o < i.length; o += 2) { const s = i[o + 1], a = -1 === s ? e(t, n) : n[s]; n[r++] = a } } } function $y(n) { const t = n.tView; return null === t || t.incompleteFirstPass ? n.tView = zl(1, null, n.template, n.decls, n.vars, n.directiveDefs, n.pipeDefs, n.viewQuery, n.schemas, n.consts) : t } function zl(n, t, e, i, r, o, s, a, l, c) { const u = 20 + i, d = u + r, h = function OI(n, t) { const e = []; for (let i = 0; i < t; i++)e.push(i < n ? null : Q); return e }(u, d), f = "function" == typeof c ? c() : c; return h[1] = { type: n, blueprint: h, template: e, queries: null, viewQuery: a, declTNode: t, data: h.slice().fill(null, u), bindingStartIndex: u, expandoStartIndex: d, hostBindingOpCodes: null, firstCreatePass: !0, firstUpdatePass: !0, staticViewQueries: !1, staticContentQueries: !1, preOrderHooks: null, preOrderCheckHooks: null, contentHooks: null, contentCheckHooks: null, viewHooks: null, viewCheckHooks: null, destroyHooks: null, cleanup: null, contentQueries: null, components: null, directiveRegistry: "function" == typeof o ? o() : o, pipeRegistry: "function" == typeof s ? s() : s, firstChild: null, schemas: l, consts: f, incompleteFirstPass: !1 } } function zy(n, t, e, i) { const r = nb(t); null === e ? r.push(i) : (r.push(e), n.firstCreatePass && ib(n).push(i, r.length - 1)) } function Ky(n, t, e) { for (let i in n) if (n.hasOwnProperty(i)) { const r = n[i]; (e = null === e ? {} : e).hasOwnProperty(i) ? e[i].push(t, r) : e[i] = [t, r] } return e } function an(n, t, e, i, r, o, s, a) { const l = pn(t, e); let u, c = t.inputs; !a && null != c && (u = c[i]) ? (sb(n, e, u, i, r), ml(t) && function FI(n, t) { const e = tn(t, n); 16 & e[2] || (e[2] |= 64) }(e, t.index)) : 3 & t.type && (i = function kI(n) { return "class" === n ? "className" : "for" === n ? "htmlFor" : "formaction" === n ? "formAction" : "innerHtml" === n ? "innerHTML" : "readonly" === n ? "readOnly" : "tabindex" === n ? "tabIndex" : n }(i), r = null != s ? s(r, t.value || "", i) : r, Ye(o) ? o.setProperty(l, i, r) : Sd(i) || (l.setProperty ? l.setProperty(i, r) : l[i] = r)) } function Ch(n, t, e, i) { let r = !1; if (im()) { const o = function UI(n, t, e) { const i = n.directiveRegistry; let r = null; if (i) for (let o = 0; o < i.length; o++) { const s = i[o]; Ay(e, s.selectors, !1) && (r || (r = []), Rl(Rs(e, t), n, s.type), xn(s) ? (Jy(n, e), r.unshift(s)) : r.push(s)) } return r }(n, t, e), s = null === i ? null : { "": -1 }; if (null !== o) { r = !0, Zy(e, n.data.length, o.length); for (let u = 0; u < o.length; u++) { const d = o[u]; d.providersResolver && d.providersResolver(d) } let a = !1, l = !1, c = bo(n, t, o.length, null); for (let u = 0; u < o.length; u++) { const d = o[u]; e.mergedAttrs = Ml(e.mergedAttrs, d.hostAttrs), Xy(n, e, t, c, d), GI(c, d, s), null !== d.contentQueries && (e.flags |= 8), (null !== d.hostBindings || null !== d.hostAttrs || 0 !== d.hostVars) && (e.flags |= 128); const h = d.type.prototype; !a && (h.ngOnChanges || h.ngOnInit || h.ngDoCheck) && ((n.preOrderHooks || (n.preOrderHooks = [])).push(e.index), a = !0), !l && (h.ngOnChanges || h.ngDoCheck) && ((n.preOrderCheckHooks || (n.preOrderCheckHooks = [])).push(e.index), l = !0), c++ } !function PI(n, t) { const i = t.directiveEnd, r = n.data, o = t.attrs, s = []; let a = null, l = null; for (let c = t.directiveStart; c < i; c++) { const u = r[c], d = u.inputs, h = null === o || Sy(t) ? null : KI(d, o); s.push(h), a = Ky(d, c, a), l = Ky(u.outputs, c, l) } null !== a && (a.hasOwnProperty("class") && (t.flags |= 16), a.hasOwnProperty("style") && (t.flags |= 32)), t.initialInputs = s, t.inputs = a, t.outputs = l }(n, e) } s && function $I(n, t, e) { if (t) { const i = n.localNames = []; for (let r = 0; r < t.length; r += 2) { const o = e[t[r + 1]]; if (null == o) throw new _e(-301, `Export of name '${t[r + 1]}' not found!`); i.push(t[r], o) } } }(e, i, s) } return e.mergedAttrs = Ml(e.mergedAttrs, e.attrs), r } function Yy(n, t, e, i, r, o) { const s = o.hostBindings; if (s) { let a = n.hostBindingOpCodes; null === a && (a = n.hostBindingOpCodes = []); const l = ~t.index; (function VI(n) { let t = n.length; for (; t > 0;) { const e = n[--t]; if ("number" == typeof e && e < 0) return e } return 0 })(a) != l && a.push(l), a.push(i, r, s) } } function Qy(n, t) { null !== n.hostBindings && n.hostBindings(1, t) } function Jy(n, t) { t.flags |= 2, (n.components || (n.components = [])).push(t.index) } function GI(n, t, e) { if (e) { if (t.exportAs) for (let i = 0; i < t.exportAs.length; i++)e[t.exportAs[i]] = n; xn(t) && (e[""] = n) } } function Zy(n, t, e) { n.flags |= 1, n.directiveStart = t, n.directiveEnd = t + e, n.providerIndexes = t } function Xy(n, t, e, i, r) { n.data[i] = r; const o = r.factory || (r.factory = yr(r.type)), s = new Ns(o, xn(r), null); n.blueprint[i] = s, e[i] = s, Yy(n, t, 0, i, bo(n, e, r.hostVars, Q), r) } function WI(n, t, e) { const i = pn(t, n), r = $y(e), o = n[10], s = Kl(n, Ks(n, r, null, e.onPush ? 64 : 16, i, t, o, o.createRenderer(i, e), null, null)); n[t.index] = s } function ni(n, t, e, i, r, o) { const s = pn(n, t); !function Eh(n, t, e, i, r, o, s) { if (null == o) Ye(n) ? n.removeAttribute(t, r, e) : t.removeAttribute(r); else { const a = null == s ? Y(o) : s(o, i || "", r); Ye(n) ? n.setAttribute(t, r, a, e) : e ? t.setAttributeNS(e, r, a) : t.setAttribute(r, a) } }(t[11], s, o, n.value, e, i, r) } function zI(n, t, e, i, r, o) { const s = o[t]; if (null !== s) { const a = i.setInput; for (let l = 0; l < s.length;) { const c = s[l++], u = s[l++], d = s[l++]; null !== a ? i.setInput(e, d, c, u) : e[u] = d } } } function KI(n, t) { let e = null, i = 0; for (; i < t.length;) { const r = t[i]; if (0 !== r) if (5 !== r) { if ("number" == typeof r) break; n.hasOwnProperty(r) && (null === e && (e = []), e.push(r, n[r], t[i + 1])), i += 2 } else i += 2; else i += 4 } return e } function eb(n, t, e, i) { return new Array(n, !0, !1, t, null, 0, i, e, null, null) } function QI(n, t) { const e = tn(t, n); if (md(e)) { const i = e[1]; 80 & e[2] ? vo(i, e, i.template, e[8]) : e[5] > 0 && wh(e) } } function wh(n) { for (let i = Zd(n); null !== i; i = Xd(i))for (let r = 10; r < i.length; r++) { const o = i[r]; if (1024 & o[2]) { const s = o[1]; vo(s, o, s.template, o[8]) } else o[5] > 0 && wh(o) } const e = n[1].components; if (null !== e) for (let i = 0; i < e.length; i++) { const r = tn(e[i], n); md(r) && r[5] > 0 && wh(r) } } function JI(n, t) { const e = tn(t, n), i = e[1]; (function ZI(n, t) { for (let e = t.length; e < n.blueprint.length; e++)t.push(n.blueprint[e]) })(i, e), qs(i, e, e[8]) } function Kl(n, t) { return n[13] ? n[14][4] = t : n[13] = t, n[14] = t, t } function Th(n) { for (; n;) { n[2] |= 64; const t = Ws(n); if (PA(n) && !t) return n; n = t } return null } function Ah(n, t, e) { const i = t[10]; i.begin && i.begin(); try { vo(n, t, n.template, e) } catch (r) { throw ob(t, r), r } finally { i.end && i.end() } } function tb(n) { !function Sh(n) { for (let t = 0; t < n.components.length; t++) { const e = n.components[t], i = Kd(e), r = i[1]; RI(r, i, r.template, e) } }(n[8]) } function Mh(n, t, e) { Ed(0), t(n, e) } const nR = (() => Promise.resolve(null))(); function nb(n) { return n[7] || (n[7] = []) } function ib(n) { return n.cleanup || (n.cleanup = []) } function ob(n, t) { const e = n[9], i = e ? e.get(Di, null) : null; i && i.handleError(t) } function sb(n, t, e, i, r) { for (let o = 0; o < e.length;) { const s = e[o++], a = e[o++], l = t[s], c = n.data[s]; null !== c.setInput ? c.setInput(l, r, i, a) : l[a] = r } } function Ei(n, t, e) { const i = bl(t, n); !function cy(n, t, e) { Ye(n) ? n.setValue(t, e) : t.textContent = e }(n[11], i, e) } function ql(n, t, e) { let i = e ? n.styles : null, r = e ? n.classes : null, o = 0; if (null !== t) for (let s = 0; s < t.length; s++) { const a = t[s]; "number" == typeof a ? o = a : 1 == o ? r = nd(r, a) : 2 == o && (i = nd(i, a + ": " + t[++s] + ";")) } e ? n.styles = i : n.stylesWithoutHost = i, e ? n.classes = r : n.classesWithoutHost = r } const Nh = new P("INJECTOR", -1); class ab { get(t, e = Fs) { if (e === Fs) { const i = new Error(`NullInjectorError: No provider for ${Me(t)}!`); throw i.name = "NullInjectorError", i } return e } } const Ih = new P("Set Injector scope."), Ys = {}, oR = {}; let Rh; function lb() { return void 0 === Rh && (Rh = new ab), Rh } function cb(n, t = null, e = null, i) { const r = ub(n, t, e, i); return r._resolveInjectorDefTypes(), r } function ub(n, t = null, e = null, i) { return new sR(n, e, t || lb(), i) } class sR { constructor(t, e, i, r = null) { this.parent = i, this.records = new Map, this.injectorDefTypes = new Set, this.onDestroy = new Set, this._destroyed = !1; const o = []; e && Zn(e, a => this.processProvider(a, t, e)), Zn([t], a => this.processInjectorType(a, [], o)), this.records.set(Nh, Do(void 0, this)); const s = this.records.get(Ih); this.scope = null != s ? s.value : null, this.source = r || ("object" == typeof t ? null : Me(t)) } get destroyed() { return this._destroyed } destroy() { this.assertNotDestroyed(), this._destroyed = !0; try { this.onDestroy.forEach(t => t.ngOnDestroy()) } finally { this.records.clear(), this.onDestroy.clear(), this.injectorDefTypes.clear() } } get(t, e = Fs, i = Z.Default) { this.assertNotDestroyed(); const r = Om(this), o = Vi(void 0); try { if (!(i & Z.SkipSelf)) { let a = this.records.get(t); if (void 0 === a) { const l = function pR(n) { return "function" == typeof n || "object" == typeof n && n instanceof P }(t) && rd(t); a = l && this.injectableDefInScope(l) ? Do(Oh(t), Ys) : null, this.records.set(t, a) } if (null != a) return this.hydrate(t, a) } return (i & Z.Self ? lb() : this.parent).get(t, e = i & Z.Optional && e === Fs ? null : e) } catch (s) { if ("NullInjectorError" === s.name) { if ((s[kl] = s[kl] || []).unshift(Me(t)), r) throw s; return function VM(n, t, e, i) { const r = n[kl]; throw t[Rm] && r.unshift(t[Rm]), n.message = function HM(n, t, e, i = null) { n = n && "\n" === n.charAt(0) && "\u0275" == n.charAt(1) ? n.substr(2) : n; let r = Me(t); if (Array.isArray(t)) r = t.map(Me).join(" -> "); else if ("object" == typeof t) { let o = []; for (let s in t) if (t.hasOwnProperty(s)) { let a = t[s]; o.push(s + ":" + ("string" == typeof a ? JSON.stringify(a) : Me(a))) } r = `{${o.join(", ")}}` } return `${e}${i ? "(" + i + ")" : ""}[${r}]: ${n.replace(PM, "\n  ")}` }("\n" + n.message, r, e, i), n.ngTokenPath = r, n[kl] = null, n }(s, t, "R3InjectorError", this.source) } throw s } finally { Vi(o), Om(r) } } _resolveInjectorDefTypes() { this.injectorDefTypes.forEach(t => this.get(t)) } toString() { const t = []; return this.records.forEach((i, r) => t.push(Me(r))), `R3Injector[${t.join(", ")}]` } assertNotDestroyed() { if (this._destroyed) throw new _e(205, "") } processInjectorType(t, e, i) { if (!(t = ee(t))) return !1; let r = H_(t); const o = null == r && t.ngModule || void 0, s = void 0 === o ? t : o, a = -1 !== i.indexOf(s); if (void 0 !== o && (r = H_(o)), null == r) return !1; if (null != r.imports && !a) { let u; i.push(s); try { Zn(r.imports, d => { this.processInjectorType(d, e, i) && (void 0 === u && (u = []), u.push(d)) }) } finally { } if (void 0 !== u) for (let d = 0; d < u.length; d++) { const { ngModule: h, providers: f } = u[d]; Zn(f, p => this.processProvider(p, h, f || xe)) } } this.injectorDefTypes.add(s); const l = yr(s) || (() => new s); this.records.set(s, Do(l, Ys)); const c = r.providers; if (null != c && !a) { const u = t; Zn(c, d => this.processProvider(d, u, c)) } return void 0 !== o && void 0 !== t.providers } processProvider(t, e, i) { let r = Co(t = ee(t)) ? t : ee(t && t.provide); const o = function lR(n, t, e) { return hb(n) ? Do(void 0, n.useValue) : Do(db(n), Ys) }(t); if (Co(t) || !0 !== t.multi) this.records.get(r); else { let s = this.records.get(r); s || (s = Do(void 0, Ys, !0), s.factory = () => Ld(s.multi), this.records.set(r, s)), r = t, s.multi.push(t) } this.records.set(r, o) } hydrate(t, e) { return e.value === Ys && (e.value = oR, e.value = e.factory()), "object" == typeof e.value && e.value && function fR(n) { return null !== n && "object" == typeof n && "function" == typeof n.ngOnDestroy }(e.value) && this.onDestroy.add(e.value), e.value } injectableDefInScope(t) { if (!t.providedIn) return !1; const e = ee(t.providedIn); return "string" == typeof e ? "any" === e || e === this.scope : this.injectorDefTypes.has(e) } } function Oh(n) { const t = rd(n), e = null !== t ? t.factory : yr(n); if (null !== e) return e; if (n instanceof P) throw new _e(204, ""); if (n instanceof Function) return function aR(n) { const t = n.length; if (t > 0) throw ks(t, "?"), new _e(204, ""); const e = function DA(n) { const t = n && (n[hl] || n[j_]); if (t) { const e = function CA(n) { if (n.hasOwnProperty("name")) return n.name; const t = ("" + n).match(/^function\s*([^\s(]+)/); return null === t ? "" : t[1] }(n); return console.warn(`DEPRECATED: DI is instantiating a token "${e}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${e}" class.`), t } return null }(n); return null !== e ? () => e.factory(n) : () => new n }(n); throw new _e(204, "") } function db(n, t, e) { let i; if (Co(n)) { const r = ee(n); return yr(r) || Oh(r) } if (hb(n)) i = () => ee(n.useValue); else if (function uR(n) { return !(!n || !n.useFactory) }(n)) i = () => n.useFactory(...Ld(n.deps || [])); else if (function cR(n) { return !(!n || !n.useExisting) }(n)) i = () => E(ee(n.useExisting)); else { const r = ee(n && (n.useClass || n.provide)); if (!function hR(n) { return !!n.deps }(n)) return yr(r) || Oh(r); i = () => new r(...Ld(n.deps)) } return i } function Do(n, t, e = !1) { return { factory: n, value: t, multi: e ? [] : void 0 } } function hb(n) { return null !== n && "object" == typeof n && FM in n } function Co(n) { return "function" == typeof n } let et = (() => { class n { static create(e, i) { var r; if (Array.isArray(e)) return cb({ name: "" }, i, e, ""); { const o = null !== (r = e.name) && void 0 !== r ? r : ""; return cb({ name: o }, e.parent, e.providers, o) } } } return n.THROW_IF_NOT_FOUND = Fs, n.NULL = new ab, n.\u0275prov = R({ token: n, providedIn: "any", factory: () => E(Nh) }), n.__NG_ELEMENT_ID__ = -1, n })(); function CR(n, t) { wl(Kd(n)[1], ut()) } function ie(n) { let t = function wb(n) { return Object.getPrototypeOf(n.prototype).constructor }(n.type), e = !0; const i = [n]; for (; t;) { let r; if (xn(n)) r = t.\u0275cmp || t.\u0275dir; else { if (t.\u0275cmp) throw new _e(903, ""); r = t.\u0275dir } if (r) { if (e) { i.push(r); const s = n; s.inputs = kh(n.inputs), s.declaredInputs = kh(n.declaredInputs), s.outputs = kh(n.outputs); const a = r.hostBindings; a && SR(n, a); const l = r.viewQuery, c = r.contentQueries; if (l && wR(n, l), c && TR(n, c), td(n.inputs, r.inputs), td(n.declaredInputs, r.declaredInputs), td(n.outputs, r.outputs), xn(r) && r.data.animation) { const u = n.data; u.animation = (u.animation || []).concat(r.data.animation) } } const o = r.features; if (o) for (let s = 0; s < o.length; s++) { const a = o[s]; a && a.ngInherit && a(n), a === ie && (e = !1) } } t = Object.getPrototypeOf(t) } !function ER(n) { let t = 0, e = null; for (let i = n.length - 1; i >= 0; i--) { const r = n[i]; r.hostVars = t += r.hostVars, r.hostAttrs = Ml(r.hostAttrs, e = Ml(e, r.hostAttrs)) } }(i) } function kh(n) { return n === Zr ? {} : n === xe ? [] : n } function wR(n, t) { const e = n.viewQuery; n.viewQuery = e ? (i, r) => { t(i, r), e(i, r) } : t } function TR(n, t) { const e = n.contentQueries; n.contentQueries = e ? (i, r, o) => { t(i, r, o), e(i, r, o) } : t } function SR(n, t) { const e = n.hostBindings; n.hostBindings = e ? (i, r) => { t(i, r), e(i, r) } : t } let Yl = null; function Eo() { if (!Yl) { const n = Re.Symbol; if (n && n.iterator) Yl = n.iterator; else { const t = Object.getOwnPropertyNames(Map.prototype); for (let e = 0; e < t.length; ++e) { const i = t[e]; "entries" !== i && "size" !== i && Map.prototype[i] === Map.prototype.entries && (Yl = i) } } } return Yl } function Qs(n) { return !!Fh(n) && (Array.isArray(n) || !(n instanceof Map) && Eo() in n) } function Fh(n) { return null !== n && ("function" == typeof n || "object" == typeof n) } function ii(n, t, e) { return n[t] = e } function It(n, t, e) { return !Object.is(n[t], e) && (n[t] = e, !0) } function ve(n, t, e, i) { const r = w(); return It(r, ro(), t) && (me(), ni(Qe(), r, n, t, e, i)), ve } function To(n, t, e, i) { return It(n, ro(), e) ? t + Y(e) + i : Q } function j(n, t, e, i, r, o, s, a) { const l = w(), c = me(), u = n + 20, d = c.firstCreatePass ? function xR(n, t, e, i, r, o, s, a, l) { const c = t.consts, u = yo(t, n, 4, s || null, Ui(c, a)); Ch(t, e, u, Ui(c, l)), wl(t, u); const d = u.tViews = zl(2, u, i, r, o, t.directiveRegistry, t.pipeRegistry, null, t.schemas, c); return null !== t.queries && (t.queries.template(t, u), d.queries = t.queries.embeddedTView(u)), u }(u, c, l, t, e, i, r, o, s) : c.data[u]; Jn(d, !1); const h = l[11].createComment(""); jl(c, l, h, d), Nt(h, l), Kl(l, l[u] = eb(h, l, h, d)), yl(d) && vh(c, l, d), null != s && Dh(l, d, a) } function ht(n) { return function io(n, t) { return n[t] }(function ZA() { return z.lFrame.contextLView }(), 20 + n) } function g(n, t = Z.Default) { const e = w(); return null === e ? E(n, t) : Dm(ut(), e, ee(n), t) } function jh() { throw new Error("invalid") } function F(n, t, e) { const i = w(); return It(i, ro(), t) && an(me(), Qe(), i, n, t, i[11], e, !1), F } function Uh(n, t, e, i, r) { const s = r ? "class" : "style"; sb(n, e, t.inputs[s], s, i) } function v(n, t, e, i) { const r = w(), o = me(), s = 20 + n, a = r[11], l = r[s] = th(a, t, function cM() { return z.lFrame.currentNamespace }()), c = o.firstCreatePass ? function eO(n, t, e, i, r, o, s) { const a = t.consts, c = yo(t, n, 2, r, Ui(a, o)); return Ch(t, e, c, Ui(a, s)), null !== c.attrs && ql(c, c.attrs, !1), null !== c.mergedAttrs && ql(c, c.mergedAttrs, !0), null !== t.queries && t.queries.elementStart(t, c), c }(s, o, r, 0, t, e, i) : o.data[s]; Jn(c, !0); const u = c.mergedAttrs; null !== u && Al(a, l, u); const d = c.classes; null !== d && ah(a, l, d); const h = c.styles; null !== h && Ey(a, l, h), 64 != (64 & c.flags) && jl(o, r, l, c), 0 === function KA() { return z.lFrame.elementDepthCount }() && Nt(l, r), function qA() { z.lFrame.elementDepthCount++ }(), yl(c) && (vh(o, r, c), function Uy(n, t, e) { if (dd(t)) { const r = t.directiveEnd; for (let o = t.directiveStart; o < r; o++) { const s = n.data[o]; s.contentQueries && s.contentQueries(1, e[o], o) } } }(o, c, r)), null !== i && Dh(r, c) } function D() { let n = ut(); bd() ? vd() : (n = n.parent, Jn(n, !1)); const t = n; !function YA() { z.lFrame.elementDepthCount-- }(); const e = me(); e.firstCreatePass && (wl(e, n), dd(n) && e.queries.elementEnd(n)), null != t.classesWithoutHost && function pM(n) { return 0 != (16 & n.flags) }(t) && Uh(e, t, w(), t.classesWithoutHost, !0), null != t.stylesWithoutHost && function gM(n) { return 0 != (32 & n.flags) }(t) && Uh(e, t, w(), t.stylesWithoutHost, !1) } function Ue(n, t, e, i) { v(n, t, e, i), D() } function Dt() { return w() } function Zs(n) { return !!n && "function" == typeof n.then } const $h = function zb(n) { return !!n && "function" == typeof n.subscribe }; function B(n, t, e, i) { const r = w(), o = me(), s = ut(); return function qb(n, t, e, i, r, o, s, a) { const l = yl(i), u = n.firstCreatePass && ib(n), d = t[8], h = nb(t); let f = !0; if (3 & i.type || a) { const y = pn(i, t), b = a ? a(y) : y, m = h.length, C = a ? T => a(rt(T[i.index])) : i.index; if (Ye(e)) { let T = null; if (!a && l && (T = function iO(n, t, e, i) { const r = n.cleanup; if (null != r) for (let o = 0; o < r.length - 1; o += 2) { const s = r[o]; if (s === e && r[o + 1] === i) { const a = t[7], l = r[o + 2]; return a.length > l ? a[l] : null } "string" == typeof s && (o += 2) } return null }(n, t, r, i.index)), null !== T) (T.__ngLastListenerFn__ || T).__ngNextListenerFn__ = o, T.__ngLastListenerFn__ = o, f = !1; else { o = Gh(i, t, d, o, !1); const M = e.listen(b, r, o); h.push(o, M), u && u.push(r, C, m, m + 1) } } else o = Gh(i, t, d, o, !0), b.addEventListener(r, o, s), h.push(o), u && u.push(r, C, m, s) } else o = Gh(i, t, d, o, !1); const p = i.outputs; let _; if (f && null !== p && (_ = p[r])) { const y = _.length; if (y) for (let b = 0; b < y; b += 2) { const k = t[_[b]][_[b + 1]].subscribe(o), H = h.length; h.push(o, k), u && u.push(r, i.index, H, -(H + 1)) } } }(o, r, r[11], s, n, t, !!e, i), B } function Yb(n, t, e, i) { try { return !1 !== e(i) } catch (r) { return ob(n, r), !1 } } function Gh(n, t, e, i, r) { return function o(s) { if (s === Function) return i; const a = 2 & n.flags ? tn(n.index, t) : t; 0 == (32 & t[2]) && Th(a); let l = Yb(t, 0, i, s), c = o.__ngNextListenerFn__; for (; c;)l = Yb(t, 0, c, s) && l, c = c.__ngNextListenerFn__; return r && !1 === l && (s.preventDefault(), s.returnValue = !1), l } } function K(n = 1) { return function iM(n) { return (z.lFrame.contextLView = function rM(n, t) { for (; n > 0;)t = t[15], n--; return t }(n, z.lFrame.contextLView))[8] }(n) } function rO(n, t) { let e = null; const i = function dI(n) { const t = n.attrs; if (null != t) { const e = t.indexOf(5); if (0 == (1 & e)) return t[e + 1] } return null }(n); for (let r = 0; r < t.length; r++) { const o = t[r]; if ("*" !== o) { if (null === i ? Ay(n, o, !0) : pI(i, o)) return r } else e = r } return e } function Po(n) { const t = w()[16][6]; if (!t.projection) { const i = t.projection = ks(n ? n.length : 1, null), r = i.slice(); let o = t.child; for (; null !== o;) { const s = n ? rO(o, n) : 0; null !== s && (r[s] ? r[s].projectionNext = o : i[s] = o, r[s] = o), o = o.next } } } function ko(n, t = 0, e) { const i = w(), r = me(), o = yo(r, 20 + n, 16, null, e || null); null === o.projection && (o.projection = t), vd(), 64 != (64 & o.flags) && function rI(n, t, e) { Cy(t[11], 0, t, e, hy(n, e, t), _y(e.parent || t[6], e, t)) }(r, i, o) } function Er(n, t, e) { return Zl(n, "", t, "", e), Er } function Zl(n, t, e, i, r) { const o = w(), s = To(o, t, e, i); return s !== Q && an(me(), Qe(), o, n, s, o[11], r, !1), Zl } function rv(n, t, e, i, r) { const o = n[e + 1], s = null === t; let a = i ? kn(o) : Ci(o), l = !1; for (; 0 !== a && (!1 === l || s);) { const u = n[a + 1]; aO(n[a], t) && (l = !0, n[a + 1] = i ? uh(u) : lh(u)), a = i ? kn(u) : Ci(u) } l && (n[e + 1] = i ? lh(o) : uh(o)) } function aO(n, t) { return null === n || null == t || (Array.isArray(n) ? n[1] : n) === t || !(!Array.isArray(n) || "string" != typeof t) && fo(n, t) >= 0 } const ft = { textEnd: 0, key: 0, keyEnd: 0, value: 0, valueEnd: 0 }; function ov(n) { return n.substring(ft.key, ft.keyEnd) } function sv(n, t) { const e = ft.textEnd; return e === t ? -1 : (t = ft.keyEnd = function dO(n, t, e) { for (; t < e && n.charCodeAt(t) > 32;)t++; return t }(n, ft.key = t, e), Fo(n, t, e)) } function Fo(n, t, e) { for (; t < e && n.charCodeAt(t) <= 32;)t++; return t } function de(n, t) { return function Ln(n, t, e, i) { const r = w(), o = me(), s = vi(2); o.firstUpdatePass && hv(o, n, s, i), t !== Q && It(r, s, t) && pv(o, o.data[Lt()], r, r[11], n, r[s + 1] = function DO(n, t) { return null == n || ("string" == typeof t ? n += t : "object" == typeof n && (n = Me(on(n)))), n }(t, e), i, s) }(n, t, null, !0), de } function wr(n) { !function Bn(n, t, e, i) { const r = me(), o = vi(2); r.firstUpdatePass && hv(r, null, o, i); const s = w(); if (e !== Q && It(s, o, e)) { const a = r.data[Lt()]; if (_v(a, i) && !dv(r, o)) { let l = i ? a.classesWithoutHost : a.stylesWithoutHost; null !== l && (e = nd(l, e || "")), Uh(r, a, s, e, i) } else !function vO(n, t, e, i, r, o, s, a) { r === Q && (r = xe); let l = 0, c = 0, u = 0 < r.length ? r[0] : null, d = 0 < o.length ? o[0] : null; for (; null !== u || null !== d;) { const h = l < r.length ? r[l + 1] : void 0, f = c < o.length ? o[c + 1] : void 0; let _, p = null; u === d ? (l += 2, c += 2, h !== f && (p = d, _ = f)) : null === d || null !== u && u < d ? (l += 2, p = u) : (c += 2, p = d, _ = f), null !== p && pv(n, t, e, i, p, _, s, a), u = l < r.length ? r[l] : null, d = c < o.length ? o[c] : null } }(r, a, s, s[11], s[o + 1], s[o + 1] = function bO(n, t, e) { if (null == e || "" === e) return xe; const i = [], r = on(e); if (Array.isArray(r)) for (let o = 0; o < r.length; o++)n(i, r[o], !0); else if ("object" == typeof r) for (const o in r) r.hasOwnProperty(o) && n(i, o, r[o]); else "string" == typeof r && t(i, r); return i }(n, t, e), i, o) } }(nn, oi, n, !0) } function oi(n, t) { for (let e = function cO(n) { return function lv(n) { ft.key = 0, ft.keyEnd = 0, ft.value = 0, ft.valueEnd = 0, ft.textEnd = n.length }(n), sv(n, Fo(n, 0, ft.textEnd)) }(t); e >= 0; e = sv(t, e))nn(n, ov(t), !0) } function dv(n, t) { return t >= n.expandoStartIndex } function hv(n, t, e, i) { const r = n.data; if (null === r[e + 1]) { const o = r[Lt()], s = dv(n, e); _v(o, i) && null === t && !s && (t = !1), t = function gO(n, t, e, i) { const r = function Cd(n) { const t = z.lFrame.currentDirectiveIndex; return -1 === t ? null : n[t] }(n); let o = i ? t.residualClasses : t.residualStyles; if (null === r) 0 === (i ? t.classBindings : t.styleBindings) && (e = Xs(e = zh(null, n, t, e, i), t.attrs, i), o = null); else { const s = t.directiveStylingLast; if (-1 === s || n[s] !== r) if (e = zh(r, n, t, e, i), null === o) { let l = function _O(n, t, e) { const i = e ? t.classBindings : t.styleBindings; if (0 !== Ci(i)) return n[kn(i)] }(n, t, i); void 0 !== l && Array.isArray(l) && (l = zh(null, n, t, l[1], i), l = Xs(l, t.attrs, i), function mO(n, t, e, i) { n[kn(e ? t.classBindings : t.styleBindings)] = i }(n, t, i, l)) } else o = function yO(n, t, e) { let i; const r = t.directiveEnd; for (let o = 1 + t.directiveStylingLast; o < r; o++)i = Xs(i, n[o].hostAttrs, e); return Xs(i, t.attrs, e) }(n, t, i) } return void 0 !== o && (i ? t.residualClasses = o : t.residualStyles = o), e }(r, o, t, i), function oO(n, t, e, i, r, o) { let s = o ? t.classBindings : t.styleBindings, a = kn(s), l = Ci(s); n[i] = e; let u, c = !1; if (Array.isArray(e)) { const d = e; u = d[1], (null === u || fo(d, u) > 0) && (c = !0) } else u = e; if (r) if (0 !== l) { const h = kn(n[a + 1]); n[i + 1] = $l(h, a), 0 !== h && (n[h + 1] = ch(n[h + 1], i)), n[a + 1] = function yI(n, t) { return 131071 & n | t << 17 }(n[a + 1], i) } else n[i + 1] = $l(a, 0), 0 !== a && (n[a + 1] = ch(n[a + 1], i)), a = i; else n[i + 1] = $l(l, 0), 0 === a ? a = i : n[l + 1] = ch(n[l + 1], i), l = i; c && (n[i + 1] = lh(n[i + 1])), rv(n, u, i, !0), rv(n, u, i, !1), function sO(n, t, e, i, r) { const o = r ? n.residualClasses : n.residualStyles; null != o && "string" == typeof t && fo(o, t) >= 0 && (e[i + 1] = uh(e[i + 1])) }(t, u, n, i, o), s = $l(a, l), o ? t.classBindings = s : t.styleBindings = s }(r, o, t, e, s, i) } } function zh(n, t, e, i, r) { let o = null; const s = e.directiveEnd; let a = e.directiveStylingLast; for (-1 === a ? a = e.directiveStart : a++; a < s && (o = t[a], i = Xs(i, o.hostAttrs, r), o !== n);)a++; return null !== n && (e.directiveStylingLast = a), i } function Xs(n, t, e) { const i = e ? 1 : 2; let r = -1; if (null !== t) for (let o = 0; o < t.length; o++) { const s = t[o]; "number" == typeof s ? r = s : r === i && (Array.isArray(n) || (n = void 0 === n ? [] : ["", n]), nn(n, s, !!e || t[++o])) } return void 0 === n ? null : n } function pv(n, t, e, i, r, o, s, a) { if (!(3 & t.type)) return; const l = n.data, c = l[a + 1]; Xl(function Oy(n) { return 1 == (1 & n) }(c) ? gv(l, t, e, r, Ci(c), s) : void 0) || (Xl(o) || function Ry(n) { return 2 == (2 & n) }(c) && (o = gv(l, null, e, r, a, s)), function sI(n, t, e, i, r) { const o = Ye(n); if (t) r ? o ? n.addClass(e, i) : e.classList.add(i) : o ? n.removeClass(e, i) : e.classList.remove(i); else { let s = -1 === i.indexOf("-") ? void 0 : sn.DashCase; if (null == r) o ? n.removeStyle(e, i, s) : e.style.removeProperty(i); else { const a = "string" == typeof r && r.endsWith("!important"); a && (r = r.slice(0, -10), s |= sn.Important), o ? n.setStyle(e, i, r, s) : e.style.setProperty(i, r, a ? "important" : "") } } }(i, s, bl(Lt(), e), r, o)) } function gv(n, t, e, i, r, o) { const s = null === t; let a; for (; r > 0;) { const l = n[r], c = Array.isArray(l), u = c ? l[1] : l, d = null === u; let h = e[r + 1]; h === Q && (h = d ? xe : void 0); let f = d ? xd(h, i) : u === i ? h : void 0; if (c && !Xl(f) && (f = xd(l, i)), Xl(f) && (a = f, s)) return a; const p = n[r + 1]; r = s ? kn(p) : Ci(p) } if (null !== t) { let l = o ? t.residualClasses : t.residualStyles; null != l && (a = xd(l, i)) } return a } function Xl(n) { return void 0 !== n } function _v(n, t) { return 0 != (n.flags & (t ? 16 : 32)) } function q(n, t = "") { const e = w(), i = me(), r = n + 20, o = i.firstCreatePass ? yo(i, r, 1, t, null) : i.data[r], s = e[r] = function eh(n, t) { return Ye(n) ? n.createText(t) : n.createTextNode(t) }(e[11], t); jl(i, e, s, o), Jn(o, !1) } function Vn(n) { return qi("", n, ""), Vn } function qi(n, t, e) { const i = w(), r = To(i, n, t, e); return r !== Q && Ei(i, Lt(), r), qi } const Sr = void 0; var jO = ["en", [["a", "p"], ["AM", "PM"], Sr], [["AM", "PM"], Sr, Sr], [["S", "M", "T", "W", "T", "F", "S"], ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]], Sr, [["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]], Sr, [["B", "A"], ["BC", "AD"], ["Before Christ", "Anno Domini"]], 0, [6, 0], ["M/d/yy", "MMM d, y", "MMMM d, y", "EEEE, MMMM d, y"], ["h:mm a", "h:mm:ss a", "h:mm:ss a z", "h:mm:ss a zzzz"], ["{1}, {0}", Sr, "{1} 'at' {0}", Sr], [".", ",", ";", "%", "+", "-", "E", "\xd7", "\u2030", "\u221e", "NaN", ":"], ["#,##0.###", "#,##0%", "\xa4#,##0.00", "#E0"], "USD", "$", "US Dollar", {}, "ltr", function HO(n) { const e = Math.floor(Math.abs(n)), i = n.toString().replace(/^[^.]*\.?/, "").length; return 1 === e && 0 === i ? 1 : 5 }]; let Lo = {}; function Fv(n) { return n in Lo || (Lo[n] = Re.ng && Re.ng.common && Re.ng.common.locales && Re.ng.common.locales[n]), Lo[n] } var I = (() => ((I = I || {})[I.LocaleId = 0] = "LocaleId", I[I.DayPeriodsFormat = 1] = "DayPeriodsFormat", I[I.DayPeriodsStandalone = 2] = "DayPeriodsStandalone", I[I.DaysFormat = 3] = "DaysFormat", I[I.DaysStandalone = 4] = "DaysStandalone", I[I.MonthsFormat = 5] = "MonthsFormat", I[I.MonthsStandalone = 6] = "MonthsStandalone", I[I.Eras = 7] = "Eras", I[I.FirstDayOfWeek = 8] = "FirstDayOfWeek", I[I.WeekendRange = 9] = "WeekendRange", I[I.DateFormat = 10] = "DateFormat", I[I.TimeFormat = 11] = "TimeFormat", I[I.DateTimeFormat = 12] = "DateTimeFormat", I[I.NumberSymbols = 13] = "NumberSymbols", I[I.NumberFormats = 14] = "NumberFormats", I[I.CurrencyCode = 15] = "CurrencyCode", I[I.CurrencySymbol = 16] = "CurrencySymbol", I[I.CurrencyName = 17] = "CurrencyName", I[I.Currencies = 18] = "Currencies", I[I.Directionality = 19] = "Directionality", I[I.PluralCase = 20] = "PluralCase", I[I.ExtraData = 21] = "ExtraData", I))(); const ec = "en-US"; let Lv = ec; function Qh(n, t, e, i, r) { if (n = ee(n), Array.isArray(n)) for (let o = 0; o < n.length; o++)Qh(n[o], t, e, i, r); else { const o = me(), s = w(); let a = Co(n) ? n : ee(n.provide), l = db(n); const c = ut(), u = 1048575 & c.providerIndexes, d = c.directiveStart, h = c.providerIndexes >> 20; if (Co(n) || !n.multi) { const f = new Ns(l, r, g), p = Zh(a, t, r ? u : u + h, d); -1 === p ? (Rl(Rs(c, s), o, a), Jh(o, n, t.length), t.push(a), c.directiveStart++, c.directiveEnd++, r && (c.providerIndexes += 1048576), e.push(f), s.push(f)) : (e[p] = f, s[p] = f) } else { const f = Zh(a, t, u + h, d), p = Zh(a, t, u, u + h), _ = f >= 0 && e[f], y = p >= 0 && e[p]; if (r && !y || !r && !_) { Rl(Rs(c, s), o, a); const b = function Bx(n, t, e, i, r) { const o = new Ns(n, e, g); return o.multi = [], o.index = t, o.componentProviders = 0, l0(o, r, i && !e), o }(r ? Lx : Fx, e.length, r, i, l); !r && y && (e[p].providerFactory = b), Jh(o, n, t.length, 0), t.push(a), c.directiveStart++, c.directiveEnd++, r && (c.providerIndexes += 1048576), e.push(b), s.push(b) } else Jh(o, n, f > -1 ? f : p, l0(e[r ? p : f], l, !r && i)); !r && i && y && e[p].componentProviders++ } } } function Jh(n, t, e, i) { const r = Co(t), o = function dR(n) { return !!n.useClass }(t); if (r || o) { const l = (o ? ee(t.useClass) : t).prototype.ngOnDestroy; if (l) { const c = n.destroyHooks || (n.destroyHooks = []); if (!r && t.multi) { const u = c.indexOf(e); -1 === u ? c.push(e, [i, l]) : c[u + 1].push(i, l) } else c.push(e, l) } } } function l0(n, t, e) { return e && n.componentProviders++, n.multi.push(t) - 1 } function Zh(n, t, e, i) { for (let r = e; r < i; r++)if (t[r] === n) return r; return -1 } function Fx(n, t, e, i) { return Xh(this.multi, []) } function Lx(n, t, e, i) { const r = this.multi; let o; if (this.providerFactory) { const s = this.providerFactory.componentProviders, a = Os(e, e[1], this.providerFactory.index, i); o = a.slice(0, s), Xh(r, o); for (let l = s; l < a.length; l++)o.push(a[l]) } else o = [], Xh(r, o); return o } function Xh(n, t) { for (let e = 0; e < n.length; e++)t.push((0, n[e])()); return t } function Se(n, t = []) { return e => { e.providersResolver = (i, r) => function kx(n, t, e) { const i = me(); if (i.firstCreatePass) { const r = xn(n); Qh(e, i.data, i.blueprint, r, !0), Qh(t, i.data, i.blueprint, r, !1) } }(i, r ? r(n) : n, t) } } class c0 { } class jx { resolveComponentFactory(t) { throw function Hx(n) { const t = Error(`No component factory found for ${Me(n)}. Did you add it to @NgModule.entryComponents?`); return t.ngComponent = n, t }(t) } } let wi = (() => { class n { } return n.NULL = new jx, n })(); function Ux() { return Vo(ut(), w()) } function Vo(n, t) { return new X(pn(n, t)) } let X = (() => { class n { constructor(e) { this.nativeElement = e } } return n.__NG_ELEMENT_ID__ = Ux, n })(); function $x(n) { return n instanceof X ? n.nativeElement : n } class Ho { } let Hn = (() => { class n { } return n.__NG_ELEMENT_ID__ = () => function Wx() { const n = w(), e = tn(ut().index, n); return function Gx(n) { return n[11] }(Qn(e) ? e : n) }(), n })(), zx = (() => { class n { } return n.\u0275prov = R({ token: n, providedIn: "root", factory: () => null }), n })(); class Ar { constructor(t) { this.full = t, this.major = t.split(".")[0], this.minor = t.split(".")[1], this.patch = t.split(".").slice(2).join(".") } } const Kx = new Ar("13.1.3"), ef = {}; function oc(n, t, e, i, r = !1) { for (; null !== e;) { const o = t[e.index]; if (null !== o && i.push(rt(o)), On(o)) for (let a = 10; a < o.length; a++) { const l = o[a], c = l[1].firstChild; null !== c && oc(l[1], l, c, i) } const s = e.type; if (8 & s) oc(n, t, e.child, i); else if (32 & s) { const a = Jd(e, t); let l; for (; l = a();)i.push(l) } else if (16 & s) { const a = vy(t, e); if (Array.isArray(a)) i.push(...a); else { const l = Ws(t[16]); oc(l[1], l, a, i, !0) } } e = r ? e.projectionNext : e.next } return i } class ra { constructor(t, e) { this._lView = t, this._cdRefInjectingView = e, this._appRef = null, this._attachedToViewContainer = !1 } get rootNodes() { const t = this._lView, e = t[1]; return oc(e, t, e.firstChild, []) } get context() { return this._lView[8] } set context(t) { this._lView[8] = t } get destroyed() { return 256 == (256 & this._lView[2]) } destroy() { if (this._appRef) this._appRef.detachView(this); else if (this._attachedToViewContainer) { const t = this._lView[3]; if (On(t)) { const e = t[8], i = e ? e.indexOf(this) : -1; i > -1 && (nh(t, i), xl(e, i)) } this._attachedToViewContainer = !1 } dy(this._lView[1], this._lView) } onDestroy(t) { zy(this._lView[1], this._lView, null, t) } markForCheck() { Th(this._cdRefInjectingView || this._lView) } detach() { this._lView[2] &= -129 } reattach() { this._lView[2] |= 128 } detectChanges() { Ah(this._lView[1], this._lView, this.context) } checkNoChanges() { !function eR(n, t, e) { Dl(!0); try { Ah(n, t, e) } finally { Dl(!1) } }(this._lView[1], this._lView, this.context) } attachToViewContainerRef() { if (this._appRef) throw new _e(902, ""); this._attachedToViewContainer = !0 } detachFromAppRef() { this._appRef = null, function QN(n, t) { zs(n, t, t[11], 2, null, null) }(this._lView[1], this._lView) } attachToAppRef(t) { if (this._attachedToViewContainer) throw new _e(902, ""); this._appRef = t } } class qx extends ra { constructor(t) { super(t), this._view = t } detectChanges() { tb(this._view) } checkNoChanges() { !function tR(n) { Dl(!0); try { tb(n) } finally { Dl(!1) } }(this._view) } get context() { return null } } class d0 extends wi { constructor(t) { super(), this.ngModule = t } resolveComponentFactory(t) { const e = At(t); return new tf(e, this.ngModule) } } function h0(n) { const t = []; for (let e in n) n.hasOwnProperty(e) && t.push({ propName: n[e], templateName: e }); return t } const Qx = new P("SCHEDULER_TOKEN", { providedIn: "root", factory: () => iy }); class tf extends c0 { constructor(t, e) { super(), this.componentDef = t, this.ngModule = e, this.componentType = t.type, this.selector = function _I(n) { return n.map(gI).join(",") }(t.selectors), this.ngContentSelectors = t.ngContentSelectors ? t.ngContentSelectors : [], this.isBoundToModule = !!e } get inputs() { return h0(this.componentDef.inputs) } get outputs() { return h0(this.componentDef.outputs) } create(t, e, i, r) { const o = (r = r || this.ngModule) ? function Jx(n, t) { return { get: (e, i, r) => { const o = n.get(e, ef, r); return o !== ef || i === ef ? o : t.get(e, i, r) } } }(t, r.injector) : t, s = o.get(Ho, em), a = o.get(zx, null), l = s.createRenderer(null, this.componentDef), c = this.componentDef.selectors[0][0] || "div", u = i ? function Wy(n, t, e) { if (Ye(n)) return n.selectRootElement(t, e === In.ShadowDom); let i = "string" == typeof t ? n.querySelector(t) : t; return i.textContent = "", i }(l, i, this.componentDef.encapsulation) : th(s.createRenderer(null, this.componentDef), c, function Yx(n) { const t = n.toLowerCase(); return "svg" === t ? "http://www.w3.org/2000/svg" : "math" === t ? "http://www.w3.org/1998/MathML/" : null }(c)), d = this.componentDef.onPush ? 576 : 528, h = function Eb(n, t) { return { components: [], scheduler: n || iy, clean: nR, playerHandler: t || null, flags: 0 } }(), f = zl(0, null, null, 1, 0, null, null, null, null, null), p = Ks(null, f, h, d, null, null, s, l, a, o); let _, y; Cl(p); try { const b = function Db(n, t, e, i, r, o) { const s = e[1]; e[20] = n; const l = yo(s, 20, 2, "#host", null), c = l.mergedAttrs = t.hostAttrs; null !== c && (ql(l, c, !0), null !== n && (Al(r, n, c), null !== l.classes && ah(r, n, l.classes), null !== l.styles && Ey(r, n, l.styles))); const u = i.createRenderer(n, t), d = Ks(e, $y(t), null, t.onPush ? 64 : 16, e[20], l, i, u, o || null, null); return s.firstCreatePass && (Rl(Rs(l, e), s, t.type), Jy(s, l), Zy(l, e.length, 1)), Kl(e, d), e[20] = d }(u, this.componentDef, p, s, l); if (u) if (i) Al(l, u, ["ng-version", Kx.full]); else { const { attrs: m, classes: C } = function mI(n) { const t = [], e = []; let i = 1, r = 2; for (; i < n.length;) { let o = n[i]; if ("string" == typeof o) 2 === r ? "" !== o && t.push(o, n[++i]) : 8 === r && e.push(o); else { if (!Pn(r)) break; r = o } i++ } return { attrs: t, classes: e } }(this.componentDef.selectors[0]); m && Al(l, u, m), C && C.length > 0 && ah(l, u, C.join(" ")) } if (y = _d(f, 20), void 0 !== e) { const m = y.projection = []; for (let C = 0; C < this.ngContentSelectors.length; C++) { const T = e[C]; m.push(null != T ? Array.from(T) : null) } } _ = function Cb(n, t, e, i, r) { const o = e[1], s = function BI(n, t, e) { const i = ut(); n.firstCreatePass && (e.providersResolver && e.providersResolver(e), Xy(n, i, t, bo(n, t, 1, null), e)); const r = Os(t, n, i.directiveStart, i); Nt(r, t); const o = pn(i, t); return o && Nt(o, t), r }(o, e, t); if (i.components.push(s), n[8] = s, r && r.forEach(l => l(s, t)), t.contentQueries) { const l = ut(); t.contentQueries(1, s, l.directiveStart) } const a = ut(); return !o.firstCreatePass || null === t.hostBindings && null === t.hostAttrs || ($i(a.index), Yy(e[1], a, 0, a.directiveStart, a.directiveEnd, t), Qy(t, s)), s }(b, this.componentDef, p, h, [CR]), qs(f, p, null) } finally { El() } return new Xx(this.componentType, _, Vo(y, p), p, y) } } class Xx extends class Vx { }{ constructor(t, e, i, r, o) { super(), this.location = i, this._rootLView = r, this._tNode = o, this.instance = e, this.hostView = this.changeDetectorRef = new qx(r), this.componentType = t } get injector() { return new ao(this._tNode, this._rootLView) } destroy() { this.hostView.destroy() } onDestroy(t) { this.hostView.onDestroy(t) } } class Ti { } class f0 { } const jo = new Map; class _0 extends Ti { constructor(t, e) { super(), this._parent = e, this._bootstrapComponents = [], this.injector = this, this.destroyCbs = [], this.componentFactoryResolver = new d0(this); const i = dn(t); this._bootstrapComponents = ti(i.bootstrap), this._r3Injector = ub(t, e, [{ provide: Ti, useValue: this }, { provide: wi, useValue: this.componentFactoryResolver }], Me(t)), this._r3Injector._resolveInjectorDefTypes(), this.instance = this.get(t) } get(t, e = et.THROW_IF_NOT_FOUND, i = Z.Default) { return t === et || t === Ti || t === Nh ? this : this._r3Injector.get(t, e, i) } destroy() { const t = this._r3Injector; !t.destroyed && t.destroy(), this.destroyCbs.forEach(e => e()), this.destroyCbs = null } onDestroy(t) { this.destroyCbs.push(t) } } class nf extends f0 { constructor(t) { super(), this.moduleType = t, null !== dn(t) && function tP(n) { const t = new Set; !function e(i) { const r = dn(i, !0), o = r.id; null !== o && (function p0(n, t, e) { if (t && t !== e) throw new Error(`Duplicate module registered for ${n} - ${Me(t)} vs ${Me(t.name)}`) }(o, jo.get(o), i), jo.set(o, i)); const s = ti(r.imports); for (const a of s) t.has(a) || (t.add(a), e(a)) }(n) }(t) } create(t) { return new _0(this.moduleType, t) } } function oa(n, t, e, i) { return function m0(n, t, e, i, r, o) { const s = t + e; return It(n, s, r) ? ii(n, s + 1, o ? i.call(o, r) : i(r)) : sa(n, s + 1) }(w(), Ft(), n, t, e, i) } function Uo(n, t, e, i, r) { return function y0(n, t, e, i, r, o, s) { const a = t + e; return function Cr(n, t, e, i) { const r = It(n, t, e); return It(n, t + 1, i) || r }(n, a, r, o) ? ii(n, a + 2, s ? i.call(s, r, o) : i(r, o)) : sa(n, a + 2) }(w(), Ft(), n, t, e, i, r) } function sa(n, t) { const e = n[t]; return e === Q ? void 0 : e } function sf(n) { return t => { setTimeout(n, void 0, t) } } const L = class _P extends be { constructor(t = !1) { super(), this.__isAsync = t } emit(t) { super.next(t) } subscribe(t, e, i) { var r, o, s; let a = t, l = e || (() => null), c = i; if (t && "object" == typeof t) { const d = t; a = null === (r = d.next) || void 0 === r ? void 0 : r.bind(d), l = null === (o = d.error) || void 0 === o ? void 0 : o.bind(d), c = null === (s = d.complete) || void 0 === s ? void 0 : s.bind(d) } this.__isAsync && (l = sf(l), a && (a = sf(a)), c && (c = sf(c))); const u = super.subscribe({ next: a, error: l, complete: c }); return t instanceof Ze && t.add(u), u } }; function mP() { return this._results[Eo()]() } class $o { constructor(t = !1) { this._emitDistinctChangesOnly = t, this.dirty = !0, this._results = [], this._changesDetected = !1, this._changes = null, this.length = 0, this.first = void 0, this.last = void 0; const e = Eo(), i = $o.prototype; i[e] || (i[e] = mP) } get changes() { return this._changes || (this._changes = new L) } get(t) { return this._results[t] } map(t) { return this._results.map(t) } filter(t) { return this._results.filter(t) } find(t) { return this._results.find(t) } reduce(t, e) { return this._results.reduce(t, e) } forEach(t) { this._results.forEach(t) } some(t) { return this._results.some(t) } toArray() { return this._results.slice() } toString() { return this._results.toString() } reset(t, e) { const i = this; i.dirty = !1; const r = gn(t); (this._changesDetected = !function TM(n, t, e) { if (n.length !== t.length) return !1; for (let i = 0; i < n.length; i++) { let r = n[i], o = t[i]; if (e && (r = e(r), o = e(o)), o !== r) return !1 } return !0 }(i._results, r, e)) && (i._results = r, i.length = r.length, i.last = r[this.length - 1], i.first = r[0]) } notifyOnChanges() { this._changes && (this._changesDetected || !this._emitDistinctChangesOnly) && this._changes.emit(this) } setDirty() { this.dirty = !0 } destroy() { this.changes.complete(), this.changes.unsubscribe() } } Symbol; let ke = (() => { class n { } return n.__NG_ELEMENT_ID__ = vP, n })(); const yP = ke, bP = class extends yP { constructor(t, e, i) { super(), this._declarationLView = t, this._declarationTContainer = e, this.elementRef = i } createEmbeddedView(t) { const e = this._declarationTContainer.tViews, i = Ks(this._declarationLView, e, t, 16, null, e.declTNode, null, null, null, null); i[17] = this._declarationLView[this._declarationTContainer.index]; const o = this._declarationLView[19]; return null !== o && (i[19] = o.createEmbeddedView(e)), qs(e, i, t), new ra(i) } }; function vP() { return sc(ut(), w()) } function sc(n, t) { return 4 & n.type ? new bP(t, n, Vo(n, t)) : null } let Rt = (() => { class n { } return n.__NG_ELEMENT_ID__ = DP, n })(); function DP() { return w0(ut(), w()) } const CP = Rt, C0 = class extends CP { constructor(t, e, i) { super(), this._lContainer = t, this._hostTNode = e, this._hostLView = i } get element() { return Vo(this._hostTNode, this._hostLView) } get injector() { return new ao(this._hostTNode, this._hostLView) } get parentInjector() { const t = Il(this._hostTNode, this._hostLView); if (_m(t)) { const e = so(t, this._hostLView), i = oo(t); return new ao(e[1].data[i + 8], e) } return new ao(null, this._hostLView) } clear() { for (; this.length > 0;)this.remove(this.length - 1) } get(t) { const e = E0(this._lContainer); return null !== e && e[t] || null } get length() { return this._lContainer.length - 10 } createEmbeddedView(t, e, i) { const r = t.createEmbeddedView(e || {}); return this.insert(r, i), r } createComponent(t, e, i, r, o) { const s = t && !function Ps(n) { return "function" == typeof n }(t); let a; if (s) a = e; else { const d = e || {}; a = d.index, i = d.injector, r = d.projectableNodes, o = d.ngModuleRef } const l = s ? t : new tf(At(t)), c = i || this.parentInjector; if (!o && null == l.ngModule && c) { const d = c.get(Ti, null); d && (o = d) } const u = l.create(c, r, void 0, o); return this.insert(u.hostView, a), u } insert(t, e) { const i = t._lView, r = i[1]; if (function zA(n) { return On(n[3]) }(i)) { const u = this.indexOf(t); if (-1 !== u) this.detach(u); else { const d = i[3], h = new C0(d, d[6], d[3]); h.detach(h.indexOf(t)) } } const o = this._adjustIndex(e), s = this._lContainer; !function ZN(n, t, e, i) { const r = 10 + i, o = e.length; i > 0 && (e[r - 1][4] = t), i < o - 10 ? (t[4] = e[r], Sm(e, 10 + i, t)) : (e.push(t), t[4] = null), t[3] = e; const s = t[17]; null !== s && e !== s && function XN(n, t) { const e = n[9]; t[16] !== t[3][3][16] && (n[2] = !0), null === e ? n[9] = [t] : e.push(t) }(s, t); const a = t[19]; null !== a && a.insertView(n), t[2] |= 128 }(r, i, s, o); const a = oh(o, s), l = i[11], c = Hl(l, s[7]); return null !== c && function YN(n, t, e, i, r, o) { i[0] = r, i[6] = t, zs(n, i, e, 1, r, o) }(r, s[6], l, i, c, a), t.attachToViewContainerRef(), Sm(af(s), o, t), t } move(t, e) { return this.insert(t, e) } indexOf(t) { const e = E0(this._lContainer); return null !== e ? e.indexOf(t) : -1 } remove(t) { const e = this._adjustIndex(t, -1), i = nh(this._lContainer, e); i && (xl(af(this._lContainer), e), dy(i[1], i)) } detach(t) { const e = this._adjustIndex(t, -1), i = nh(this._lContainer, e); return i && null != xl(af(this._lContainer), e) ? new ra(i) : null } _adjustIndex(t, e = 0) { return null == t ? this.length + e : t } }; function E0(n) { return n[8] } function af(n) { return n[8] || (n[8] = []) } function w0(n, t) { let e; const i = t[n.index]; if (On(i)) e = i; else { let r; if (8 & n.type) r = rt(i); else { const o = t[11]; r = o.createComment(""); const s = pn(n, t); Dr(o, Hl(o, s), r, function iI(n, t) { return Ye(n) ? n.nextSibling(t) : t.nextSibling }(o, s), !1) } t[n.index] = e = eb(i, t, r, n), Kl(t, e) } return new C0(e, n, t) } class lf { constructor(t) { this.queryList = t, this.matches = null } clone() { return new lf(this.queryList) } setDirty() { this.queryList.setDirty() } } class cf { constructor(t = []) { this.queries = t } createEmbeddedView(t) { const e = t.queries; if (null !== e) { const i = null !== t.contentQueries ? t.contentQueries[0] : e.length, r = []; for (let o = 0; o < i; o++) { const s = e.getByIndex(o); r.push(this.queries[s.indexInDeclarationView].clone()) } return new cf(r) } return null } insertView(t) { this.dirtyQueriesWithMatches(t) } detachView(t) { this.dirtyQueriesWithMatches(t) } dirtyQueriesWithMatches(t) { for (let e = 0; e < this.queries.length; e++)null !== N0(t, e).matches && this.queries[e].setDirty() } } class T0 { constructor(t, e, i = null) { this.predicate = t, this.flags = e, this.read = i } } class uf { constructor(t = []) { this.queries = t } elementStart(t, e) { for (let i = 0; i < this.queries.length; i++)this.queries[i].elementStart(t, e) } elementEnd(t) { for (let e = 0; e < this.queries.length; e++)this.queries[e].elementEnd(t) } embeddedTView(t) { let e = null; for (let i = 0; i < this.length; i++) { const r = null !== e ? e.length : 0, o = this.getByIndex(i).embeddedTView(t, r); o && (o.indexInDeclarationView = i, null !== e ? e.push(o) : e = [o]) } return null !== e ? new uf(e) : null } template(t, e) { for (let i = 0; i < this.queries.length; i++)this.queries[i].template(t, e) } getByIndex(t) { return this.queries[t] } get length() { return this.queries.length } track(t) { this.queries.push(t) } } class df { constructor(t, e = -1) { this.metadata = t, this.matches = null, this.indexInDeclarationView = -1, this.crossesNgTemplate = !1, this._appliesToNextNode = !0, this._declarationNodeIndex = e } elementStart(t, e) { this.isApplyingToNode(e) && this.matchTNode(t, e) } elementEnd(t) { this._declarationNodeIndex === t.index && (this._appliesToNextNode = !1) } template(t, e) { this.elementStart(t, e) } embeddedTView(t, e) { return this.isApplyingToNode(t) ? (this.crossesNgTemplate = !0, this.addMatch(-t.index, e), new df(this.metadata)) : null } isApplyingToNode(t) { if (this._appliesToNextNode && 1 != (1 & this.metadata.flags)) { const e = this._declarationNodeIndex; let i = t.parent; for (; null !== i && 8 & i.type && i.index !== e;)i = i.parent; return e === (null !== i ? i.index : -1) } return this._appliesToNextNode } matchTNode(t, e) { const i = this.metadata.predicate; if (Array.isArray(i)) for (let r = 0; r < i.length; r++) { const o = i[r]; this.matchTNodeWithReadOption(t, e, TP(e, o)), this.matchTNodeWithReadOption(t, e, Ol(e, t, o, !1, !1)) } else i === ke ? 4 & e.type && this.matchTNodeWithReadOption(t, e, -1) : this.matchTNodeWithReadOption(t, e, Ol(e, t, i, !1, !1)) } matchTNodeWithReadOption(t, e, i) { if (null !== i) { const r = this.metadata.read; if (null !== r) if (r === X || r === Rt || r === ke && 4 & e.type) this.addMatch(e.index, -2); else { const o = Ol(e, t, r, !1, !1); null !== o && this.addMatch(e.index, o) } else this.addMatch(e.index, i) } } addMatch(t, e) { null === this.matches ? this.matches = [t, e] : this.matches.push(t, e) } } function TP(n, t) { const e = n.localNames; if (null !== e) for (let i = 0; i < e.length; i += 2)if (e[i] === t) return e[i + 1]; return null } function AP(n, t, e, i) { return -1 === e ? function SP(n, t) { return 11 & n.type ? Vo(n, t) : 4 & n.type ? sc(n, t) : null }(t, n) : -2 === e ? function MP(n, t, e) { return e === X ? Vo(t, n) : e === ke ? sc(t, n) : e === Rt ? w0(t, n) : void 0 }(n, t, i) : Os(n, n[1], e, t) } function S0(n, t, e, i) { const r = t[19].queries[i]; if (null === r.matches) { const o = n.data, s = e.matches, a = []; for (let l = 0; l < s.length; l += 2) { const c = s[l]; a.push(c < 0 ? null : AP(t, o[c], s[l + 1], e.metadata.read)) } r.matches = a } return r.matches } function hf(n, t, e, i) { const r = n.queries.getByIndex(e), o = r.matches; if (null !== o) { const s = S0(n, t, r, e); for (let a = 0; a < o.length; a += 2) { const l = o[a]; if (l > 0) i.push(s[a / 2]); else { const c = o[a + 1], u = t[-l]; for (let d = 10; d < u.length; d++) { const h = u[d]; h[17] === h[3] && hf(h[1], h, c, i) } if (null !== u[9]) { const d = u[9]; for (let h = 0; h < d.length; h++) { const f = d[h]; hf(f[1], f, c, i) } } } } } return i } function le(n) { const t = w(), e = me(), i = am(); Ed(i + 1); const r = N0(e, i); if (n.dirty && tm(t) === (2 == (2 & r.metadata.flags))) { if (null === r.matches) n.reset([]); else { const o = r.crossesNgTemplate ? hf(e, t, i, []) : S0(e, t, r, i); n.reset(o, $x), n.notifyOnChanges() } return !0 } return !1 } function qt(n, t, e) { const i = me(); i.firstCreatePass && (M0(i, new T0(n, t, e), -1), 2 == (2 & t) && (i.staticViewQueries = !0)), A0(i, w(), t) } function Ve(n, t, e, i) { const r = me(); if (r.firstCreatePass) { const o = ut(); M0(r, new T0(t, e, i), o.index), function IP(n, t) { const e = n.contentQueries || (n.contentQueries = []); t !== (e.length ? e[e.length - 1] : -1) && e.push(n.queries.length - 1, t) }(r, n), 2 == (2 & e) && (r.staticContentQueries = !0) } A0(r, w(), e) } function ce() { return function NP(n, t) { return n[19].queries[t].queryList }(w(), am()) } function A0(n, t, e) { const i = new $o(4 == (4 & e)); zy(n, t, i, i.destroy), null === t[19] && (t[19] = new cf), t[19].queries.push(new lf(i)) } function M0(n, t, e) { null === n.queries && (n.queries = new uf), n.queries.track(new df(t, e)) } function N0(n, t) { return n.queries.getByIndex(t) } function jn(n, t) { return sc(n, t) } function cc(...n) { } const uc = new P("Application Initializer"); let Wo = (() => { class n { constructor(e) { this.appInits = e, this.resolve = cc, this.reject = cc, this.initialized = !1, this.done = !1, this.donePromise = new Promise((i, r) => { this.resolve = i, this.reject = r }) } runInitializers() { if (this.initialized) return; const e = [], i = () => { this.done = !0, this.resolve() }; if (this.appInits) for (let r = 0; r < this.appInits.length; r++) { const o = this.appInits[r](); if (Zs(o)) e.push(o); else if ($h(o)) { const s = new Promise((a, l) => { o.subscribe({ complete: a, error: l }) }); e.push(s) } } Promise.all(e).then(() => { i() }).catch(r => { this.reject(r) }), 0 === e.length && i(), this.initialized = !0 } } return n.\u0275fac = function(e) { return new (e || n)(E(uc, 8)) }, n.\u0275prov = R({ token: n, factory: n.\u0275fac }), n })(); const ca = new P("AppId"), qP = { provide: ca, useFactory: function KP() { return `${yf()}${yf()}${yf()}` }, deps: [] }; function yf() { return String.fromCharCode(97 + Math.floor(25 * Math.random())) } const z0 = new P("Platform Initializer"), zo = new P("Platform ID"), K0 = new P("appBootstrapListener"); let q0 = (() => { class n { log(e) { console.log(e) } warn(e) { console.warn(e) } } return n.\u0275fac = function(e) { return new (e || n) }, n.\u0275prov = R({ token: n, factory: n.\u0275fac }), n })(); const Si = new P("LocaleId"), Y0 = new P("DefaultCurrencyCode"); class YP { constructor(t, e) { this.ngModuleFactory = t, this.componentFactories = e } } let dc = (() => { class n { compileModuleSync(e) { return new nf(e) } compileModuleAsync(e) { return Promise.resolve(this.compileModuleSync(e)) } compileModuleAndAllComponentsSync(e) { const i = this.compileModuleSync(e), o = ti(dn(e).declarations).reduce((s, a) => { const l = At(a); return l && s.push(new tf(l)), s }, []); return new YP(i, o) } compileModuleAndAllComponentsAsync(e) { return Promise.resolve(this.compileModuleAndAllComponentsSync(e)) } clearCache() { } clearCacheFor(e) { } getModuleId(e) { } } return n.\u0275fac = function(e) { return new (e || n) }, n.\u0275prov = R({ token: n, factory: n.\u0275fac }), n })(); const JP = (() => Promise.resolve(0))(); function bf(n) { "undefined" == typeof Zone ? JP.then(() => { n && n.apply(null, null) }) : Zone.current.scheduleMicroTask("scheduleMicrotask", n) } class he { constructor({ enableLongStackTrace: t = !1, shouldCoalesceEventChangeDetection: e = !1, shouldCoalesceRunChangeDetection: i = !1 }) { if (this.hasPendingMacrotasks = !1, this.hasPendingMicrotasks = !1, this.isStable = !0, this.onUnstable = new L(!1), this.onMicrotaskEmpty = new L(!1), this.onStable = new L(!1), this.onError = new L(!1), "undefined" == typeof Zone) throw new Error("In this configuration Angular requires Zone.js"); Zone.assertZonePatched(); const r = this; r._nesting = 0, r._outer = r._inner = Zone.current, Zone.TaskTrackingZoneSpec && (r._inner = r._inner.fork(new Zone.TaskTrackingZoneSpec)), t && Zone.longStackTraceZoneSpec && (r._inner = r._inner.fork(Zone.longStackTraceZoneSpec)), r.shouldCoalesceEventChangeDetection = !i && e, r.shouldCoalesceRunChangeDetection = i, r.lastRequestAnimationFrameId = -1, r.nativeRequestAnimationFrame = function ZP() { let n = Re.requestAnimationFrame, t = Re.cancelAnimationFrame; if ("undefined" != typeof Zone && n && t) { const e = n[Zone.__symbol__("OriginalDelegate")]; e && (n = e); const i = t[Zone.__symbol__("OriginalDelegate")]; i && (t = i) } return { nativeRequestAnimationFrame: n, nativeCancelAnimationFrame: t } }().nativeRequestAnimationFrame, function tk(n) { const t = () => { !function ek(n) { n.isCheckStableRunning || -1 !== n.lastRequestAnimationFrameId || (n.lastRequestAnimationFrameId = n.nativeRequestAnimationFrame.call(Re, () => { n.fakeTopEventTask || (n.fakeTopEventTask = Zone.root.scheduleEventTask("fakeTopEventTask", () => { n.lastRequestAnimationFrameId = -1, Df(n), n.isCheckStableRunning = !0, vf(n), n.isCheckStableRunning = !1 }, void 0, () => { }, () => { })), n.fakeTopEventTask.invoke() }), Df(n)) }(n) }; n._inner = n._inner.fork({ name: "angular", properties: { isAngularZone: !0 }, onInvokeTask: (e, i, r, o, s, a) => { try { return Q0(n), e.invokeTask(r, o, s, a) } finally { (n.shouldCoalesceEventChangeDetection && "eventTask" === o.type || n.shouldCoalesceRunChangeDetection) && t(), J0(n) } }, onInvoke: (e, i, r, o, s, a, l) => { try { return Q0(n), e.invoke(r, o, s, a, l) } finally { n.shouldCoalesceRunChangeDetection && t(), J0(n) } }, onHasTask: (e, i, r, o) => { e.hasTask(r, o), i === r && ("microTask" == o.change ? (n._hasPendingMicrotasks = o.microTask, Df(n), vf(n)) : "macroTask" == o.change && (n.hasPendingMacrotasks = o.macroTask)) }, onHandleError: (e, i, r, o) => (e.handleError(r, o), n.runOutsideAngular(() => n.onError.emit(o)), !1) }) }(r) } static isInAngularZone() { return !0 === Zone.current.get("isAngularZone") } static assertInAngularZone() { if (!he.isInAngularZone()) throw new Error("Expected to be in Angular Zone, but it is not!") } static assertNotInAngularZone() { if (he.isInAngularZone()) throw new Error("Expected to not be in Angular Zone, but it is!") } run(t, e, i) { return this._inner.run(t, e, i) } runTask(t, e, i, r) { const o = this._inner, s = o.scheduleEventTask("NgZoneEvent: " + r, t, XP, cc, cc); try { return o.runTask(s, e, i) } finally { o.cancelTask(s) } } runGuarded(t, e, i) { return this._inner.runGuarded(t, e, i) } runOutsideAngular(t) { return this._outer.run(t) } } const XP = {}; function vf(n) { if (0 == n._nesting && !n.hasPendingMicrotasks && !n.isStable) try { n._nesting++, n.onMicrotaskEmpty.emit(null) } finally { if (n._nesting--, !n.hasPendingMicrotasks) try { n.runOutsideAngular(() => n.onStable.emit(null)) } finally { n.isStable = !0 } } } function Df(n) { n.hasPendingMicrotasks = !!(n._hasPendingMicrotasks || (n.shouldCoalesceEventChangeDetection || n.shouldCoalesceRunChangeDetection) && -1 !== n.lastRequestAnimationFrameId) } function Q0(n) { n._nesting++, n.isStable && (n.isStable = !1, n.onUnstable.emit(null)) } function J0(n) { n._nesting--, vf(n) } class nk { constructor() { this.hasPendingMicrotasks = !1, this.hasPendingMacrotasks = !1, this.isStable = !0, this.onUnstable = new L, this.onMicrotaskEmpty = new L, this.onStable = new L, this.onError = new L } run(t, e, i) { return t.apply(e, i) } runGuarded(t, e, i) { return t.apply(e, i) } runOutsideAngular(t) { return t() } runTask(t, e, i, r) { return t.apply(e, i) } } let Cf = (() => { class n { constructor(e) { this._ngZone = e, this._pendingCount = 0, this._isZoneStable = !0, this._didWork = !1, this._callbacks = [], this.taskTrackingZone = null, this._watchAngularEvents(), e.run(() => { this.taskTrackingZone = "undefined" == typeof Zone ? null : Zone.current.get("TaskTrackingZone") }) } _watchAngularEvents() { this._ngZone.onUnstable.subscribe({ next: () => { this._didWork = !0, this._isZoneStable = !1 } }), this._ngZone.runOutsideAngular(() => { this._ngZone.onStable.subscribe({ next: () => { he.assertNotInAngularZone(), bf(() => { this._isZoneStable = !0, this._runCallbacksIfReady() }) } }) }) } increasePendingRequestCount() { return this._pendingCount += 1, this._didWork = !0, this._pendingCount } decreasePendingRequestCount() { if (this._pendingCount -= 1, this._pendingCount < 0) throw new Error("pending async requests below zero"); return this._runCallbacksIfReady(), this._pendingCount } isStable() { return this._isZoneStable && 0 === this._pendingCount && !this._ngZone.hasPendingMacrotasks } _runCallbacksIfReady() { if (this.isStable()) bf(() => { for (; 0 !== this._callbacks.length;) { let e = this._callbacks.pop(); clearTimeout(e.timeoutId), e.doneCb(this._didWork) } this._didWork = !1 }); else { let e = this.getPendingTasks(); this._callbacks = this._callbacks.filter(i => !i.updateCb || !i.updateCb(e) || (clearTimeout(i.timeoutId), !1)), this._didWork = !0 } } getPendingTasks() { return this.taskTrackingZone ? this.taskTrackingZone.macroTasks.map(e => ({ source: e.source, creationLocation: e.creationLocation, data: e.data })) : [] } addCallback(e, i, r) { let o = -1; i && i > 0 && (o = setTimeout(() => { this._callbacks = this._callbacks.filter(s => s.timeoutId !== o), e(this._didWork, this.getPendingTasks()) }, i)), this._callbacks.push({ doneCb: e, timeoutId: o, updateCb: r }) } whenStable(e, i, r) { if (r && !this.taskTrackingZone) throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?'); this.addCallback(e, i, r), this._runCallbacksIfReady() } getPendingRequestCount() { return this._pendingCount } findProviders(e, i, r) { return [] } } return n.\u0275fac = function(e) { return new (e || n)(E(he)) }, n.\u0275prov = R({ token: n, factory: n.\u0275fac }), n })(), Z0 = (() => { class n { constructor() { this._applications = new Map, Ef.addToWindow(this) } registerApplication(e, i) { this._applications.set(e, i) } unregisterApplication(e) { this._applications.delete(e) } unregisterAllApplications() { this._applications.clear() } getTestability(e) { return this._applications.get(e) || null } getAllTestabilities() { return Array.from(this._applications.values()) } getAllRootElements() { return Array.from(this._applications.keys()) } findTestabilityInTree(e, i = !0) { return Ef.findTestabilityInTree(this, e, i) } } return n.\u0275fac = function(e) { return new (e || n) }, n.\u0275prov = R({ token: n, factory: n.\u0275fac }), n })(); class ik { addToWindow(t) { } findTestabilityInTree(t, e, i) { return null } } let Un, Ef = new ik; const X0 = new P("AllowMultipleToken"); class eD { constructor(t, e) { this.name = t, this.token = e } } function tD(n, t, e = []) { const i = `Platform: ${t}`, r = new P(i); return (o = []) => { let s = nD(); if (!s || s.injector.get(X0, !1)) if (n) n(e.concat(o).concat({ provide: r, useValue: !0 })); else { const a = e.concat(o).concat({ provide: r, useValue: !0 }, { provide: Ih, useValue: "platform" }); !function ak(n) { if (Un && !Un.destroyed && !Un.injector.get(X0, !1)) throw new _e(400, ""); Un = n.get(iD); const t = n.get(z0, null); t && t.forEach(e => e()) }(et.create({ providers: a, name: i })) } return function lk(n) { const t = nD(); if (!t) throw new _e(401, ""); return t }() } } function nD() { return Un && !Un.destroyed ? Un : null } let iD = (() => { class n { constructor(e) { this._injector = e, this._modules = [], this._destroyListeners = [], this._destroyed = !1 } bootstrapModuleFactory(e, i) { const a = function ck(n, t) { let e; return e = "noop" === n ? new nk : ("zone.js" === n ? void 0 : n) || new he({ enableLongStackTrace: !1, shouldCoalesceEventChangeDetection: !!(null == t ? void 0 : t.ngZoneEventCoalescing), shouldCoalesceRunChangeDetection: !!(null == t ? void 0 : t.ngZoneRunCoalescing) }), e }(i ? i.ngZone : void 0, { ngZoneEventCoalescing: i && i.ngZoneEventCoalescing || !1, ngZoneRunCoalescing: i && i.ngZoneRunCoalescing || !1 }), l = [{ provide: he, useValue: a }]; return a.run(() => { const c = et.create({ providers: l, parent: this.injector, name: e.moduleType.name }), u = e.create(c), d = u.injector.get(Di, null); if (!d) throw new _e(402, ""); return a.runOutsideAngular(() => { const h = a.onError.subscribe({ next: f => { d.handleError(f) } }); u.onDestroy(() => { wf(this._modules, u), h.unsubscribe() }) }), function uk(n, t, e) { try { const i = e(); return Zs(i) ? i.catch(r => { throw t.runOutsideAngular(() => n.handleError(r)), r }) : i } catch (i) { throw t.runOutsideAngular(() => n.handleError(i)), i } }(d, a, () => { const h = u.injector.get(Wo); return h.runInitializers(), h.donePromise.then(() => (function zO(n) { Xt(n, "Expected localeId to be defined"), "string" == typeof n && (Lv = n.toLowerCase().replace(/_/g, "-")) }(u.injector.get(Si, ec) || ec), this._moduleDoBootstrap(u), u)) }) }) } bootstrapModule(e, i = []) { const r = rD({}, i); return function ok(n, t, e) { const i = new nf(e); return Promise.resolve(i) }(0, 0, e).then(o => this.bootstrapModuleFactory(o, r)) } _moduleDoBootstrap(e) { const i = e.injector.get(Ko); if (e._bootstrapComponents.length > 0) e._bootstrapComponents.forEach(r => i.bootstrap(r)); else { if (!e.instance.ngDoBootstrap) throw new _e(403, ""); e.instance.ngDoBootstrap(i) } this._modules.push(e) } onDestroy(e) { this._destroyListeners.push(e) } get injector() { return this._injector } destroy() { if (this._destroyed) throw new _e(404, ""); this._modules.slice().forEach(e => e.destroy()), this._destroyListeners.forEach(e => e()), this._destroyed = !0 } get destroyed() { return this._destroyed } } return n.\u0275fac = function(e) { return new (e || n)(E(et)) }, n.\u0275prov = R({ token: n, factory: n.\u0275fac }), n })(); function rD(n, t) { return Array.isArray(t) ? t.reduce(rD, n) : Object.assign(Object.assign({}, n), t) } let Ko = (() => { class n { constructor(e, i, r, o, s) { this._zone = e, this._injector = i, this._exceptionHandler = r, this._componentFactoryResolver = o, this._initStatus = s, this._bootstrapListeners = [], this._views = [], this._runningTick = !1, this._stable = !0, this.componentTypes = [], this.components = [], this._onMicrotaskEmptySubscription = this._zone.onMicrotaskEmpty.subscribe({ next: () => { this._zone.run(() => { this.tick() }) } }); const a = new Ce(c => { this._stable = this._zone.isStable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks, this._zone.runOutsideAngular(() => { c.next(this._stable), c.complete() }) }), l = new Ce(c => { let u; this._zone.runOutsideAngular(() => { u = this._zone.onStable.subscribe(() => { he.assertNotInAngularZone(), bf(() => { !this._stable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks && (this._stable = !0, c.next(!0)) }) }) }); const d = this._zone.onUnstable.subscribe(() => { he.assertInAngularZone(), this._stable && (this._stable = !1, this._zone.runOutsideAngular(() => { c.next(!1) })) }); return () => { u.unsubscribe(), d.unsubscribe() } }); this.isStable = ul(a, l.pipe(L_())) } bootstrap(e, i) { if (!this._initStatus.done) throw new _e(405, ""); let r; r = e instanceof c0 ? e : this._componentFactoryResolver.resolveComponentFactory(e), this.componentTypes.push(r.componentType); const o = function sk(n) { return n.isBoundToModule }(r) ? void 0 : this._injector.get(Ti), a = r.create(et.NULL, [], i || r.selector, o), l = a.location.nativeElement, c = a.injector.get(Cf, null), u = c && a.injector.get(Z0); return c && u && u.registerApplication(l, c), a.onDestroy(() => { this.detachView(a.hostView), wf(this.components, a), u && u.unregisterApplication(l) }), this._loadComponent(a), a } tick() { if (this._runningTick) throw new _e(101, ""); try { this._runningTick = !0; for (let e of this._views) e.detectChanges() } catch (e) { this._zone.runOutsideAngular(() => this._exceptionHandler.handleError(e)) } finally { this._runningTick = !1 } } attachView(e) { const i = e; this._views.push(i), i.attachToAppRef(this) } detachView(e) { const i = e; wf(this._views, i), i.detachFromAppRef() } _loadComponent(e) { this.attachView(e.hostView), this.tick(), this.components.push(e), this._injector.get(K0, []).concat(this._bootstrapListeners).forEach(r => r(e)) } ngOnDestroy() { this._views.slice().forEach(e => e.destroy()), this._onMicrotaskEmptySubscription.unsubscribe() } get viewCount() { return this._views.length } } return n.\u0275fac = function(e) { return new (e || n)(E(he), E(et), E(Di), E(wi), E(Wo)) }, n.\u0275prov = R({ token: n, factory: n.\u0275fac }), n })(); function wf(n, t) { const e = n.indexOf(t); e > -1 && n.splice(e, 1) } let sD = !0, Tt = (() => { class n { } return n.__NG_ELEMENT_ID__ = fk, n })(); function fk(n) { return function pk(n, t, e) { if (ml(n) && !e) { const i = tn(n.index, t); return new ra(i, i) } return 47 & n.type ? new ra(t[16], t) : null }(ut(), w(), 16 == (16 & n)) } class fD { constructor() { } supports(t) { return Qs(t) } create(t) { return new vk(t) } } const bk = (n, t) => t; class vk { constructor(t) { this.length = 0, this._linkedRecords = null, this._unlinkedRecords = null, this._previousItHead = null, this._itHead = null, this._itTail = null, this._additionsHead = null, this._additionsTail = null, this._movesHead = null, this._movesTail = null, this._removalsHead = null, this._removalsTail = null, this._identityChangesHead = null, this._identityChangesTail = null, this._trackByFn = t || bk } forEachItem(t) { let e; for (e = this._itHead; null !== e; e = e._next)t(e) } forEachOperation(t) { let e = this._itHead, i = this._removalsHead, r = 0, o = null; for (; e || i;) { const s = !i || e && e.currentIndex < gD(i, r, o) ? e : i, a = gD(s, r, o), l = s.currentIndex; if (s === i) r--, i = i._nextRemoved; else if (e = e._next, null == s.previousIndex) r++; else { o || (o = []); const c = a - r, u = l - r; if (c != u) { for (let h = 0; h < c; h++) { const f = h < o.length ? o[h] : o[h] = 0, p = f + h; u <= p && p < c && (o[h] = f + 1) } o[s.previousIndex] = u - c } } a !== l && t(s, a, l) } } forEachPreviousItem(t) { let e; for (e = this._previousItHead; null !== e; e = e._nextPrevious)t(e) } forEachAddedItem(t) { let e; for (e = this._additionsHead; null !== e; e = e._nextAdded)t(e) } forEachMovedItem(t) { let e; for (e = this._movesHead; null !== e; e = e._nextMoved)t(e) } forEachRemovedItem(t) { let e; for (e = this._removalsHead; null !== e; e = e._nextRemoved)t(e) } forEachIdentityChange(t) { let e; for (e = this._identityChangesHead; null !== e; e = e._nextIdentityChange)t(e) } diff(t) { if (null == t && (t = []), !Qs(t)) throw new _e(900, ""); return this.check(t) ? this : null } onDestroy() { } check(t) { this._reset(); let r, o, s, e = this._itHead, i = !1; if (Array.isArray(t)) { this.length = t.length; for (let a = 0; a < this.length; a++)o = t[a], s = this._trackByFn(a, o), null !== e && Object.is(e.trackById, s) ? (i && (e = this._verifyReinsertion(e, o, s, a)), Object.is(e.item, o) || this._addIdentityChange(e, o)) : (e = this._mismatch(e, o, s, a), i = !0), e = e._next } else r = 0, function OR(n, t) { if (Array.isArray(n)) for (let e = 0; e < n.length; e++)t(n[e]); else { const e = n[Eo()](); let i; for (; !(i = e.next()).done;)t(i.value) } }(t, a => { s = this._trackByFn(r, a), null !== e && Object.is(e.trackById, s) ? (i && (e = this._verifyReinsertion(e, a, s, r)), Object.is(e.item, a) || this._addIdentityChange(e, a)) : (e = this._mismatch(e, a, s, r), i = !0), e = e._next, r++ }), this.length = r; return this._truncate(e), this.collection = t, this.isDirty } get isDirty() { return null !== this._additionsHead || null !== this._movesHead || null !== this._removalsHead || null !== this._identityChangesHead } _reset() { if (this.isDirty) { let t; for (t = this._previousItHead = this._itHead; null !== t; t = t._next)t._nextPrevious = t._next; for (t = this._additionsHead; null !== t; t = t._nextAdded)t.previousIndex = t.currentIndex; for (this._additionsHead = this._additionsTail = null, t = this._movesHead; null !== t; t = t._nextMoved)t.previousIndex = t.currentIndex; this._movesHead = this._movesTail = null, this._removalsHead = this._removalsTail = null, this._identityChangesHead = this._identityChangesTail = null } } _mismatch(t, e, i, r) { let o; return null === t ? o = this._itTail : (o = t._prev, this._remove(t)), null !== (t = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(i, null)) ? (Object.is(t.item, e) || this._addIdentityChange(t, e), this._reinsertAfter(t, o, r)) : null !== (t = null === this._linkedRecords ? null : this._linkedRecords.get(i, r)) ? (Object.is(t.item, e) || this._addIdentityChange(t, e), this._moveAfter(t, o, r)) : t = this._addAfter(new Dk(e, i), o, r), t } _verifyReinsertion(t, e, i, r) { let o = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(i, null); return null !== o ? t = this._reinsertAfter(o, t._prev, r) : t.currentIndex != r && (t.currentIndex = r, this._addToMoves(t, r)), t } _truncate(t) { for (; null !== t;) { const e = t._next; this._addToRemovals(this._unlink(t)), t = e } null !== this._unlinkedRecords && this._unlinkedRecords.clear(), null !== this._additionsTail && (this._additionsTail._nextAdded = null), null !== this._movesTail && (this._movesTail._nextMoved = null), null !== this._itTail && (this._itTail._next = null), null !== this._removalsTail && (this._removalsTail._nextRemoved = null), null !== this._identityChangesTail && (this._identityChangesTail._nextIdentityChange = null) } _reinsertAfter(t, e, i) { null !== this._unlinkedRecords && this._unlinkedRecords.remove(t); const r = t._prevRemoved, o = t._nextRemoved; return null === r ? this._removalsHead = o : r._nextRemoved = o, null === o ? this._removalsTail = r : o._prevRemoved = r, this._insertAfter(t, e, i), this._addToMoves(t, i), t } _moveAfter(t, e, i) { return this._unlink(t), this._insertAfter(t, e, i), this._addToMoves(t, i), t } _addAfter(t, e, i) { return this._insertAfter(t, e, i), this._additionsTail = null === this._additionsTail ? this._additionsHead = t : this._additionsTail._nextAdded = t, t } _insertAfter(t, e, i) { const r = null === e ? this._itHead : e._next; return t._next = r, t._prev = e, null === r ? this._itTail = t : r._prev = t, null === e ? this._itHead = t : e._next = t, null === this._linkedRecords && (this._linkedRecords = new pD), this._linkedRecords.put(t), t.currentIndex = i, t } _remove(t) { return this._addToRemovals(this._unlink(t)) } _unlink(t) { null !== this._linkedRecords && this._linkedRecords.remove(t); const e = t._prev, i = t._next; return null === e ? this._itHead = i : e._next = i, null === i ? this._itTail = e : i._prev = e, t } _addToMoves(t, e) { return t.previousIndex === e || (this._movesTail = null === this._movesTail ? this._movesHead = t : this._movesTail._nextMoved = t), t } _addToRemovals(t) { return null === this._unlinkedRecords && (this._unlinkedRecords = new pD), this._unlinkedRecords.put(t), t.currentIndex = null, t._nextRemoved = null, null === this._removalsTail ? (this._removalsTail = this._removalsHead = t, t._prevRemoved = null) : (t._prevRemoved = this._removalsTail, this._removalsTail = this._removalsTail._nextRemoved = t), t } _addIdentityChange(t, e) { return t.item = e, this._identityChangesTail = null === this._identityChangesTail ? this._identityChangesHead = t : this._identityChangesTail._nextIdentityChange = t, t } } class Dk { constructor(t, e) { this.item = t, this.trackById = e, this.currentIndex = null, this.previousIndex = null, this._nextPrevious = null, this._prev = null, this._next = null, this._prevDup = null, this._nextDup = null, this._prevRemoved = null, this._nextRemoved = null, this._nextAdded = null, this._nextMoved = null, this._nextIdentityChange = null } } class Ck { constructor() { this._head = null, this._tail = null } add(t) { null === this._head ? (this._head = this._tail = t, t._nextDup = null, t._prevDup = null) : (this._tail._nextDup = t, t._prevDup = this._tail, t._nextDup = null, this._tail = t) } get(t, e) { let i; for (i = this._head; null !== i; i = i._nextDup)if ((null === e || e <= i.currentIndex) && Object.is(i.trackById, t)) return i; return null } remove(t) { const e = t._prevDup, i = t._nextDup; return null === e ? this._head = i : e._nextDup = i, null === i ? this._tail = e : i._prevDup = e, null === this._head } } class pD { constructor() { this.map = new Map } put(t) { const e = t.trackById; let i = this.map.get(e); i || (i = new Ck, this.map.set(e, i)), i.add(t) } get(t, e) { const r = this.map.get(t); return r ? r.get(t, e) : null } remove(t) { const e = t.trackById; return this.map.get(e).remove(t) && this.map.delete(e), t } get isEmpty() { return 0 === this.map.size } clear() { this.map.clear() } } function gD(n, t, e) { const i = n.previousIndex; if (null === i) return i; let r = 0; return e && i < e.length && (r = e[i]), i + t + r } class _D { constructor() { } supports(t) { return t instanceof Map || Fh(t) } create() { return new Ek } } class Ek { constructor() { this._records = new Map, this._mapHead = null, this._appendAfter = null, this._previousMapHead = null, this._changesHead = null, this._changesTail = null, this._additionsHead = null, this._additionsTail = null, this._removalsHead = null, this._removalsTail = null } get isDirty() { return null !== this._additionsHead || null !== this._changesHead || null !== this._removalsHead } forEachItem(t) { let e; for (e = this._mapHead; null !== e; e = e._next)t(e) } forEachPreviousItem(t) { let e; for (e = this._previousMapHead; null !== e; e = e._nextPrevious)t(e) } forEachChangedItem(t) { let e; for (e = this._changesHead; null !== e; e = e._nextChanged)t(e) } forEachAddedItem(t) { let e; for (e = this._additionsHead; null !== e; e = e._nextAdded)t(e) } forEachRemovedItem(t) { let e; for (e = this._removalsHead; null !== e; e = e._nextRemoved)t(e) } diff(t) { if (t) { if (!(t instanceof Map || Fh(t))) throw new _e(900, "") } else t = new Map; return this.check(t) ? this : null } onDestroy() { } check(t) { this._reset(); let e = this._mapHead; if (this._appendAfter = null, this._forEach(t, (i, r) => { if (e && e.key === r) this._maybeAddToChanges(e, i), this._appendAfter = e, e = e._next; else { const o = this._getOrCreateRecordForKey(r, i); e = this._insertBeforeOrAppend(e, o) } }), e) { e._prev && (e._prev._next = null), this._removalsHead = e; for (let i = e; null !== i; i = i._nextRemoved)i === this._mapHead && (this._mapHead = null), this._records.delete(i.key), i._nextRemoved = i._next, i.previousValue = i.currentValue, i.currentValue = null, i._prev = null, i._next = null } return this._changesTail && (this._changesTail._nextChanged = null), this._additionsTail && (this._additionsTail._nextAdded = null), this.isDirty } _insertBeforeOrAppend(t, e) { if (t) { const i = t._prev; return e._next = t, e._prev = i, t._prev = e, i && (i._next = e), t === this._mapHead && (this._mapHead = e), this._appendAfter = t, t } return this._appendAfter ? (this._appendAfter._next = e, e._prev = this._appendAfter) : this._mapHead = e, this._appendAfter = e, null } _getOrCreateRecordForKey(t, e) { if (this._records.has(t)) { const r = this._records.get(t); this._maybeAddToChanges(r, e); const o = r._prev, s = r._next; return o && (o._next = s), s && (s._prev = o), r._next = null, r._prev = null, r } const i = new wk(t); return this._records.set(t, i), i.currentValue = e, this._addToAdditions(i), i } _reset() { if (this.isDirty) { let t; for (this._previousMapHead = this._mapHead, t = this._previousMapHead; null !== t; t = t._next)t._nextPrevious = t._next; for (t = this._changesHead; null !== t; t = t._nextChanged)t.previousValue = t.currentValue; for (t = this._additionsHead; null != t; t = t._nextAdded)t.previousValue = t.currentValue; this._changesHead = this._changesTail = null, this._additionsHead = this._additionsTail = null, this._removalsHead = null } } _maybeAddToChanges(t, e) { Object.is(e, t.currentValue) || (t.previousValue = t.currentValue, t.currentValue = e, this._addToChanges(t)) } _addToAdditions(t) { null === this._additionsHead ? this._additionsHead = this._additionsTail = t : (this._additionsTail._nextAdded = t, this._additionsTail = t) } _addToChanges(t) { null === this._changesHead ? this._changesHead = this._changesTail = t : (this._changesTail._nextChanged = t, this._changesTail = t) } _forEach(t, e) { t instanceof Map ? t.forEach(e) : Object.keys(t).forEach(i => e(t[i], i)) } } class wk { constructor(t) { this.key = t, this.previousValue = null, this.currentValue = null, this._nextPrevious = null, this._next = null, this._prev = null, this._nextAdded = null, this._nextRemoved = null, this._nextChanged = null } } function mD() { return new ua([new fD]) } let ua = (() => { class n { constructor(e) { this.factories = e } static create(e, i) { if (null != i) { const r = i.factories.slice(); e = e.concat(r) } return new n(e) } static extend(e) { return { provide: n, useFactory: i => n.create(e, i || mD()), deps: [[n, new br, new rn]] } } find(e) { const i = this.factories.find(r => r.supports(e)); if (null != i) return i; throw new _e(901, "") } } return n.\u0275prov = R({ token: n, providedIn: "root", factory: mD }), n })(); function yD() { return new qo([new _D]) } let qo = (() => { class n { constructor(e) { this.factories = e } static create(e, i) { if (i) { const r = i.factories.slice(); e = e.concat(r) } return new n(e) } static extend(e) { return { provide: n, useFactory: i => n.create(e, i || yD()), deps: [[n, new br, new rn]] } } find(e) { const i = this.factories.find(o => o.supports(e)); if (i) return i; throw new _e(901, "") } } return n.\u0275prov = R({ token: n, providedIn: "root", factory: yD }), n })(); const Tk = [new _D], Ak = new ua([new fD]), Mk = new qo(Tk), Nk = tD(null, "core", [{ provide: zo, useValue: "unknown" }, { provide: iD, deps: [et] }, { provide: Z0, deps: [] }, { provide: q0, deps: [] }]), Pk = [{ provide: Ko, useClass: Ko, deps: [he, et, Di, wi, Wo] }, { provide: Qx, deps: [he], useFactory: function kk(n) { let t = []; return n.onStable.subscribe(() => { for (; t.length;)t.pop()() }), function(e) { t.push(e) } } }, { provide: Wo, useClass: Wo, deps: [[new rn, uc]] }, { provide: dc, useClass: dc, deps: [] }, qP, { provide: ua, useFactory: function Ik() { return Ak }, deps: [] }, { provide: qo, useFactory: function Rk() { return Mk }, deps: [] }, { provide: Si, useFactory: function Ok(n) { return n || function xk() { return "undefined" != typeof $localize && $localize.locale || ec }() }, deps: [[new Vs(Si), new rn, new br]] }, { provide: Y0, useValue: "USD" }]; let Fk = (() => { class n { constructor(e) { } } return n.\u0275fac = function(e) { return new (e || n)(E(Ko)) }, n.\u0275mod = se({ type: n }), n.\u0275inj = te({ providers: Pk }), n })(), fc = null; function si() { return fc } const De = new P("DocumentToken"); let Nr = (() => { class n { historyGo(e) { throw new Error("Not implemented") } } return n.\u0275fac = function(e) { return new (e || n) }, n.\u0275prov = R({ token: n, factory: function() { return function Hk() { return E(bD) }() }, providedIn: "platform" }), n })(); const jk = new P("Location Initialized"); let bD = (() => { class n extends Nr { constructor(e) { super(), this._doc = e, this._init() } _init() { this.location = window.location, this._history = window.history } getBaseHrefFromDOM() { return si().getBaseHref(this._doc) } onPopState(e) { const i = si().getGlobalEventTarget(this._doc, "window"); return i.addEventListener("popstate", e, !1), () => i.removeEventListener("popstate", e) } onHashChange(e) { const i = si().getGlobalEventTarget(this._doc, "window"); return i.addEventListener("hashchange", e, !1), () => i.removeEventListener("hashchange", e) } get href() { return this.location.href } get protocol() { return this.location.protocol } get hostname() { return this.location.hostname } get port() { return this.location.port } get pathname() { return this.location.pathname } get search() { return this.location.search } get hash() { return this.location.hash } set pathname(e) { this.location.pathname = e } pushState(e, i, r) { vD() ? this._history.pushState(e, i, r) : this.location.hash = r } replaceState(e, i, r) { vD() ? this._history.replaceState(e, i, r) : this.location.hash = r } forward() { this._history.forward() } back() { this._history.back() } historyGo(e = 0) { this._history.go(e) } getState() { return this._history.state } } return n.\u0275fac = function(e) { return new (e || n)(E(De)) }, n.\u0275prov = R({ token: n, factory: function() { return function Uk() { return new bD(E(De)) }() }, providedIn: "platform" }), n })(); function vD() { return !!window.history.pushState } function Nf(n, t) { if (0 == n.length) return t; if (0 == t.length) return n; let e = 0; return n.endsWith("/") && e++, t.startsWith("/") && e++, 2 == e ? n + t.substring(1) : 1 == e ? n + t : n + "/" + t } function DD(n) { const t = n.match(/#|\?|$/), e = t && t.index || n.length; return n.slice(0, e - ("/" === n[e - 1] ? 1 : 0)) + n.slice(e) } function Ai(n) { return n && "?" !== n[0] ? "?" + n : n } let Yo = (() => { class n { historyGo(e) { throw new Error("Not implemented") } } return n.\u0275fac = function(e) { return new (e || n) }, n.\u0275prov = R({ token: n, factory: function() { return function $k(n) { const t = E(De).location; return new CD(E(Nr), t && t.origin || "") }() }, providedIn: "root" }), n })(); const If = new P("appBaseHref"); let CD = (() => { class n extends Yo { constructor(e, i) { if (super(), this._platformLocation = e, this._removeListenerFns = [], null == i && (i = this._platformLocation.getBaseHrefFromDOM()), null == i) throw new Error("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document."); this._baseHref = i } ngOnDestroy() { for (; this._removeListenerFns.length;)this._removeListenerFns.pop()() } onPopState(e) { this._removeListenerFns.push(this._platformLocation.onPopState(e), this._platformLocation.onHashChange(e)) } getBaseHref() { return this._baseHref } prepareExternalUrl(e) { return Nf(this._baseHref, e) } path(e = !1) { const i = this._platformLocation.pathname + Ai(this._platformLocation.search), r = this._platformLocation.hash; return r && e ? `${i}${r}` : i } pushState(e, i, r, o) { const s = this.prepareExternalUrl(r + Ai(o)); this._platformLocation.pushState(e, i, s) } replaceState(e, i, r, o) { const s = this.prepareExternalUrl(r + Ai(o)); this._platformLocation.replaceState(e, i, s) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } historyGo(e = 0) { var i, r; null === (r = (i = this._platformLocation).historyGo) || void 0 === r || r.call(i, e) } } return n.\u0275fac = function(e) { return new (e || n)(E(Nr), E(If, 8)) }, n.\u0275prov = R({ token: n, factory: n.\u0275fac }), n })(), Gk = (() => { class n extends Yo { constructor(e, i) { super(), this._platformLocation = e, this._baseHref = "", this._removeListenerFns = [], null != i && (this._baseHref = i) } ngOnDestroy() { for (; this._removeListenerFns.length;)this._removeListenerFns.pop()() } onPopState(e) { this._removeListenerFns.push(this._platformLocation.onPopState(e), this._platformLocation.onHashChange(e)) } getBaseHref() { return this._baseHref } path(e = !1) { let i = this._platformLocation.hash; return null == i && (i = "#"), i.length > 0 ? i.substring(1) : i } prepareExternalUrl(e) { const i = Nf(this._baseHref, e); return i.length > 0 ? "#" + i : i } pushState(e, i, r, o) { let s = this.prepareExternalUrl(r + Ai(o)); 0 == s.length && (s = this._platformLocation.pathname), this._platformLocation.pushState(e, i, s) } replaceState(e, i, r, o) { let s = this.prepareExternalUrl(r + Ai(o)); 0 == s.length && (s = this._platformLocation.pathname), this._platformLocation.replaceState(e, i, s) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } historyGo(e = 0) { var i, r; null === (r = (i = this._platformLocation).historyGo) || void 0 === r || r.call(i, e) } } return n.\u0275fac = function(e) { return new (e || n)(E(Nr), E(If, 8)) }, n.\u0275prov = R({ token: n, factory: n.\u0275fac }), n })(), Rf = (() => { class n { constructor(e, i) { this._subject = new L, this._urlChangeListeners = [], this._platformStrategy = e; const r = this._platformStrategy.getBaseHref(); this._platformLocation = i, this._baseHref = DD(ED(r)), this._platformStrategy.onPopState(o => { this._subject.emit({ url: this.path(!0), pop: !0, state: o.state, type: o.type }) }) } path(e = !1) { return this.normalize(this._platformStrategy.path(e)) } getState() { return this._platformLocation.getState() } isCurrentPathEqualTo(e, i = "") { return this.path() == this.normalize(e + Ai(i)) } normalize(e) { return n.stripTrailingSlash(function zk(n, t) { return n && t.startsWith(n) ? t.substring(n.length) : t }(this._baseHref, ED(e))) } prepareExternalUrl(e) { return e && "/" !== e[0] && (e = "/" + e), this._platformStrategy.prepareExternalUrl(e) } go(e, i = "", r = null) { this._platformStrategy.pushState(r, "", e, i), this._notifyUrlChangeListeners(this.prepareExternalUrl(e + Ai(i)), r) } replaceState(e, i = "", r = null) { this._platformStrategy.replaceState(r, "", e, i), this._notifyUrlChangeListeners(this.prepareExternalUrl(e + Ai(i)), r) } forward() { this._platformStrategy.forward() } back() { this._platformStrategy.back() } historyGo(e = 0) { var i, r; null === (r = (i = this._platformStrategy).historyGo) || void 0 === r || r.call(i, e) } onUrlChange(e) { this._urlChangeListeners.push(e), this._urlChangeSubscription || (this._urlChangeSubscription = this.subscribe(i => { this._notifyUrlChangeListeners(i.url, i.state) })) } _notifyUrlChangeListeners(e = "", i) { this._urlChangeListeners.forEach(r => r(e, i)) } subscribe(e, i, r) { return this._subject.subscribe({ next: e, error: i, complete: r }) } } return n.normalizeQueryParams = Ai, n.joinWithSlash = Nf, n.stripTrailingSlash = DD, n.\u0275fac = function(e) { return new (e || n)(E(Yo), E(Nr)) }, n.\u0275prov = R({ token: n, factory: function() { return function Wk() { return new Rf(E(Yo), E(Nr)) }() }, providedIn: "root" }), n })(); function ED(n) { return n.replace(/\/index.html$/, "") } var ot = (() => ((ot = ot || {})[ot.Zero = 0] = "Zero", ot[ot.One = 1] = "One", ot[ot.Two = 2] = "Two", ot[ot.Few = 3] = "Few", ot[ot.Many = 4] = "Many", ot[ot.Other = 5] = "Other", ot))(); const Xk = function kv(n) { return function Vt(n) { const t = function UO(n) { return n.toLowerCase().replace(/_/g, "-") }(n); let e = Fv(t); if (e) return e; const i = t.split("-")[0]; if (e = Fv(i), e) return e; if ("en" === i) return jO; throw new Error(`Missing locale data for the locale "${n}".`) }(n)[I.PluralCase] }; class Ec { } let MF = (() => { class n extends Ec { constructor(e) { super(), this.locale = e } getPluralCategory(e, i) { switch (Xk(i || this.locale)(e)) { case ot.Zero: return "zero"; case ot.One: return "one"; case ot.Two: return "two"; case ot.Few: return "few"; case ot.Many: return "many"; default: return "other" } } } return n.\u0275fac = function(e) { return new (e || n)(E(Si)) }, n.\u0275prov = R({ token: n, factory: n.\u0275fac }), n })(); function OD(n, t) { t = encodeURIComponent(t); for (const e of n.split(";")) { const i = e.indexOf("="), [r, o] = -1 == i ? [e, ""] : [e.slice(0, i), e.slice(i + 1)]; if (r.trim() === t) return decodeURIComponent(o) } return null } let xD = (() => { class n { constructor(e, i, r, o) { this._iterableDiffers = e, this._keyValueDiffers = i, this._ngEl = r, this._renderer = o, this._iterableDiffer = null, this._keyValueDiffer = null, this._initialClasses = [], this._rawClass = null } set klass(e) { this._removeClasses(this._initialClasses), this._initialClasses = "string" == typeof e ? e.split(/\s+/) : [], this._applyClasses(this._initialClasses), this._applyClasses(this._rawClass) } set ngClass(e) { this._removeClasses(this._rawClass), this._applyClasses(this._initialClasses), this._iterableDiffer = null, this._keyValueDiffer = null, this._rawClass = "string" == typeof e ? e.split(/\s+/) : e, this._rawClass && (Qs(this._rawClass) ? this._iterableDiffer = this._iterableDiffers.find(this._rawClass).create() : this._keyValueDiffer = this._keyValueDiffers.find(this._rawClass).create()) } ngDoCheck() { if (this._iterableDiffer) { const e = this._iterableDiffer.diff(this._rawClass); e && this._applyIterableChanges(e) } else if (this._keyValueDiffer) { const e = this._keyValueDiffer.diff(this._rawClass); e && this._applyKeyValueChanges(e) } } _applyKeyValueChanges(e) { e.forEachAddedItem(i => this._toggleClass(i.key, i.currentValue)), e.forEachChangedItem(i => this._toggleClass(i.key, i.currentValue)), e.forEachRemovedItem(i => { i.previousValue && this._toggleClass(i.key, !1) }) } _applyIterableChanges(e) { e.forEachAddedItem(i => { if ("string" != typeof i.item) throw new Error(`NgClass can only toggle CSS classes expressed as strings, got ${Me(i.item)}`); this._toggleClass(i.item, !0) }), e.forEachRemovedItem(i => this._toggleClass(i.item, !1)) } _applyClasses(e) { e && (Array.isArray(e) || e instanceof Set ? e.forEach(i => this._toggleClass(i, !0)) : Object.keys(e).forEach(i => this._toggleClass(i, !!e[i]))) } _removeClasses(e) { e && (Array.isArray(e) || e instanceof Set ? e.forEach(i => this._toggleClass(i, !1)) : Object.keys(e).forEach(i => this._toggleClass(i, !1))) } _toggleClass(e, i) { (e = e.trim()) && e.split(/\s+/g).forEach(r => { i ? this._renderer.addClass(this._ngEl.nativeElement, r) : this._renderer.removeClass(this._ngEl.nativeElement, r) }) } } return n.\u0275fac = function(e) { return new (e || n)(g(ua), g(qo), g(X), g(Hn)) }, n.\u0275dir = S({ type: n, selectors: [["", "ngClass", ""]], inputs: { klass: ["class", "klass"], ngClass: "ngClass" } }), n })(); class IF { constructor(t, e, i, r) { this.$implicit = t, this.ngForOf = e, this.index = i, this.count = r } get first() { return 0 === this.index } get last() { return this.index === this.count - 1 } get even() { return this.index % 2 == 0 } get odd() { return !this.even } } let Qi = (() => { class n { constructor(e, i, r) { this._viewContainer = e, this._template = i, this._differs = r, this._ngForOf = null, this._ngForOfDirty = !0, this._differ = null } set ngForOf(e) { this._ngForOf = e, this._ngForOfDirty = !0 } set ngForTrackBy(e) { this._trackByFn = e } get ngForTrackBy() { return this._trackByFn } set ngForTemplate(e) { e && (this._template = e) } ngDoCheck() { if (this._ngForOfDirty) { this._ngForOfDirty = !1; const e = this._ngForOf; !this._differ && e && (this._differ = this._differs.find(e).create(this.ngForTrackBy)) } if (this._differ) { const e = this._differ.diff(this._ngForOf); e && this._applyChanges(e) } } _applyChanges(e) { const i = this._viewContainer; e.forEachOperation((r, o, s) => { if (null == r.previousIndex) i.createEmbeddedView(this._template, new IF(r.item, this._ngForOf, -1, -1), null === s ? void 0 : s); else if (null == s) i.remove(null === o ? void 0 : o); else if (null !== o) { const a = i.get(o); i.move(a, s), PD(a, r) } }); for (let r = 0, o = i.length; r < o; r++) { const a = i.get(r).context; a.index = r, a.count = o, a.ngForOf = this._ngForOf } e.forEachIdentityChange(r => { PD(i.get(r.currentIndex), r) }) } static ngTemplateContextGuard(e, i) { return !0 } } return n.\u0275fac = function(e) { return new (e || n)(g(Rt), g(ke), g(ua)) }, n.\u0275dir = S({ type: n, selectors: [["", "ngFor", "", "ngForOf", ""]], inputs: { ngForOf: "ngForOf", ngForTrackBy: "ngForTrackBy", ngForTemplate: "ngForTemplate" } }), n })(); function PD(n, t) { n.context.$implicit = t.item } let Ni = (() => { class n { constructor(e, i) { this._viewContainer = e, this._context = new RF, this._thenTemplateRef = null, this._elseTemplateRef = null, this._thenViewRef = null, this._elseViewRef = null, this._thenTemplateRef = i } set ngIf(e) { this._context.$implicit = this._context.ngIf = e, this._updateView() } set ngIfThen(e) { kD("ngIfThen", e), this._thenTemplateRef = e, this._thenViewRef = null, this._updateView() } set ngIfElse(e) { kD("ngIfElse", e), this._elseTemplateRef = e, this._elseViewRef = null, this._updateView() } _updateView() { this._context.$implicit ? this._thenViewRef || (this._viewContainer.clear(), this._elseViewRef = null, this._thenTemplateRef && (this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context))) : this._elseViewRef || (this._viewContainer.clear(), this._thenViewRef = null, this._elseTemplateRef && (this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context))) } static ngTemplateContextGuard(e, i) { return !0 } } return n.\u0275fac = function(e) { return new (e || n)(g(Rt), g(ke)) }, n.\u0275dir = S({ type: n, selectors: [["", "ngIf", ""]], inputs: { ngIf: "ngIf", ngIfThen: "ngIfThen", ngIfElse: "ngIfElse" } }), n })(); class RF { constructor() { this.$implicit = null, this.ngIf = null } } function kD(n, t) { if (t && !t.createEmbeddedView) throw new Error(`${n} must be a TemplateRef, but received '${Me(t)}'.`) } let Qt = (() => { class n { } return n.\u0275fac = function(e) { return new (e || n) }, n.\u0275mod = se({ type: n }), n.\u0275inj = te({ providers: [{ provide: Ec, useClass: MF }] }), n })(); const BD = "browser"; let sL = (() => { class n { } return n.\u0275prov = R({ token: n, providedIn: "root", factory: () => new aL(E(De), window) }), n })(); class aL { constructor(t, e) { this.document = t, this.window = e, this.offset = () => [0, 0] } setOffset(t) { this.offset = Array.isArray(t) ? () => t : t } getScrollPosition() { return this.supportsScrolling() ? [this.window.pageXOffset, this.window.pageYOffset] : [0, 0] } scrollToPosition(t) { this.supportsScrolling() && this.window.scrollTo(t[0], t[1]) } scrollToAnchor(t) { if (!this.supportsScrolling()) return; const e = function lL(n, t) { const e = n.getElementById(t) || n.getElementsByName(t)[0]; if (e) return e; if ("function" == typeof n.createTreeWalker && n.body && (n.body.createShadowRoot || n.body.attachShadow)) { const i = n.createTreeWalker(n.body, NodeFilter.SHOW_ELEMENT); let r = i.currentNode; for (; r;) { const o = r.shadowRoot; if (o) { const s = o.getElementById(t) || o.querySelector(`[name="${t}"]`); if (s) return s } r = i.nextNode() } } return null }(this.document, t); e && (this.scrollToElement(e), this.attemptFocus(e)) } setHistoryScrollRestoration(t) { if (this.supportScrollRestoration()) { const e = this.window.history; e && e.scrollRestoration && (e.scrollRestoration = t) } } scrollToElement(t) { const e = t.getBoundingClientRect(), i = e.left + this.window.pageXOffset, r = e.top + this.window.pageYOffset, o = this.offset(); this.window.scrollTo(i - o[0], r - o[1]) } attemptFocus(t) { return t.focus(), this.document.activeElement === t } supportScrollRestoration() { try { if (!this.supportsScrolling()) return !1; const t = HD(this.window.history) || HD(Object.getPrototypeOf(this.window.history)); return !(!t || !t.writable && !t.set) } catch (t) { return !1 } } supportsScrolling() { try { return !!this.window && !!this.window.scrollTo && "pageXOffset" in this.window } catch (t) { return !1 } } } function HD(n) { return Object.getOwnPropertyDescriptor(n, "scrollRestoration") } class jD { } class Gf extends class cL extends class Vk { }{ constructor() { super(...arguments), this.supportsDOMEvents = !0 } }{ static makeCurrent() { !function Bk(n) { fc || (fc = n) }(new Gf) } onAndCancel(t, e, i) { return t.addEventListener(e, i, !1), () => { t.removeEventListener(e, i, !1) } } dispatchEvent(t, e) { t.dispatchEvent(e) } remove(t) { t.parentNode && t.parentNode.removeChild(t) } createElement(t, e) { return (e = e || this.getDefaultDocument()).createElement(t) } createHtmlDocument() { return document.implementation.createHTMLDocument("fakeTitle") } getDefaultDocument() { return document } isElementNode(t) { return t.nodeType === Node.ELEMENT_NODE } isShadowRoot(t) { return t instanceof DocumentFragment } getGlobalEventTarget(t, e) { return "window" === e ? window : "document" === e ? t : "body" === e ? t.body : null } getBaseHref(t) { const e = function uL() { return pa = pa || document.querySelector("base"), pa ? pa.getAttribute("href") : null }(); return null == e ? null : function dL(n) { wc = wc || document.createElement("a"), wc.setAttribute("href", n); const t = wc.pathname; return "/" === t.charAt(0) ? t : `/${t}` }(e) } resetBaseElement() { pa = null } getUserAgent() { return window.navigator.userAgent } getCookie(t) { return OD(document.cookie, t) } } let wc, pa = null; const UD = new P("TRANSITION_ID"), fL = [{ provide: uc, useFactory: function hL(n, t, e) { return () => { e.get(Wo).donePromise.then(() => { const i = si(), r = t.querySelectorAll(`style[ng-transition="${n}"]`); for (let o = 0; o < r.length; o++)i.remove(r[o]) }) } }, deps: [UD, De, et], multi: !0 }]; class Wf { static init() { !function rk(n) { Ef = n }(new Wf) } addToWindow(t) { Re.getAngularTestability = (i, r = !0) => { const o = t.findTestabilityInTree(i, r); if (null == o) throw new Error("Could not find testability for element."); return o }, Re.getAllAngularTestabilities = () => t.getAllTestabilities(), Re.getAllAngularRootElements = () => t.getAllRootElements(), Re.frameworkStabilizers || (Re.frameworkStabilizers = []), Re.frameworkStabilizers.push(i => { const r = Re.getAllAngularTestabilities(); let o = r.length, s = !1; const a = function(l) { s = s || l, o--, 0 == o && i(s) }; r.forEach(function(l) { l.whenStable(a) }) }) } findTestabilityInTree(t, e, i) { if (null == e) return null; const r = t.getTestability(e); return null != r ? r : i ? si().isShadowRoot(e) ? this.findTestabilityInTree(t, e.host, !0) : this.findTestabilityInTree(t, e.parentElement, !0) : null } } let pL = (() => { class n { build() { return new XMLHttpRequest } } return n.\u0275fac = function(e) { return new (e || n) }, n.\u0275prov = R({ token: n, factory: n.\u0275fac }), n })(); const Tc = new P("EventManagerPlugins"); let Sc = (() => { class n { constructor(e, i) { this._zone = i, this._eventNameToPlugin = new Map, e.forEach(r => r.manager = this), this._plugins = e.slice().reverse() } addEventListener(e, i, r) { return this._findPluginFor(i).addEventListener(e, i, r) } addGlobalEventListener(e, i, r) { return this._findPluginFor(i).addGlobalEventListener(e, i, r) } getZone() { return this._zone } _findPluginFor(e) { const i = this._eventNameToPlugin.get(e); if (i) return i; const r = this._plugins; for (let o = 0; o < r.length; o++) { const s = r[o]; if (s.supports(e)) return this._eventNameToPlugin.set(e, s), s } throw new Error(`No event manager plugin found for event ${e}`) } } return n.\u0275fac = function(e) { return new (e || n)(E(Tc), E(he)) }, n.\u0275prov = R({ token: n, factory: n.\u0275fac }), n })(); class $D { constructor(t) { this._doc = t } addGlobalEventListener(t, e, i) { const r = si().getGlobalEventTarget(this._doc, t); if (!r) throw new Error(`Unsupported event target ${r} for event ${e}`); return this.addEventListener(r, e, i) } } let GD = (() => { class n { constructor() { this._stylesSet = new Set } addStyles(e) { const i = new Set; e.forEach(r => { this._stylesSet.has(r) || (this._stylesSet.add(r), i.add(r)) }), this.onStylesAdded(i) } onStylesAdded(e) { } getAllStyles() { return Array.from(this._stylesSet) } } return n.\u0275fac = function(e) { return new (e || n) }, n.\u0275prov = R({ token: n, factory: n.\u0275fac }), n })(), ga = (() => { class n extends GD { constructor(e) { super(), this._doc = e, this._hostNodes = new Map, this._hostNodes.set(e.head, []) } _addStylesToHost(e, i, r) { e.forEach(o => { const s = this._doc.createElement("style"); s.textContent = o, r.push(i.appendChild(s)) }) } addHost(e) { const i = []; this._addStylesToHost(this._stylesSet, e, i), this._hostNodes.set(e, i) } removeHost(e) { const i = this._hostNodes.get(e); i && i.forEach(WD), this._hostNodes.delete(e) } onStylesAdded(e) { this._hostNodes.forEach((i, r) => { this._addStylesToHost(e, r, i) }) } ngOnDestroy() { this._hostNodes.forEach(e => e.forEach(WD)) } } return n.\u0275fac = function(e) { return new (e || n)(E(De)) }, n.\u0275prov = R({ token: n, factory: n.\u0275fac }), n })(); function WD(n) { si().remove(n) } const zf = { svg: "http://www.w3.org/2000/svg", xhtml: "http://www.w3.org/1999/xhtml", xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/" }, Kf = /%COMP%/g; function Ac(n, t, e) { for (let i = 0; i < t.length; i++) { let r = t[i]; Array.isArray(r) ? Ac(n, r, e) : (r = r.replace(Kf, n), e.push(r)) } return e } function qD(n) { return t => { if ("__ngUnwrap__" === t) return n; !1 === n(t) && (t.preventDefault(), t.returnValue = !1) } } let Mc = (() => { class n { constructor(e, i, r) { this.eventManager = e, this.sharedStylesHost = i, this.appId = r, this.rendererByCompId = new Map, this.defaultRenderer = new qf(e) } createRenderer(e, i) { if (!e || !i) return this.defaultRenderer; switch (i.encapsulation) { case In.Emulated: { let r = this.rendererByCompId.get(i.id); return r || (r = new vL(this.eventManager, this.sharedStylesHost, i, this.appId), this.rendererByCompId.set(i.id, r)), r.applyToHost(e), r } case 1: case In.ShadowDom: return new DL(this.eventManager, this.sharedStylesHost, e, i); default: if (!this.rendererByCompId.has(i.id)) { const r = Ac(i.id, i.styles, []); this.sharedStylesHost.addStyles(r), this.rendererByCompId.set(i.id, this.defaultRenderer) } return this.defaultRenderer } } begin() { } end() { } } return n.\u0275fac = function(e) { return new (e || n)(E(Sc), E(ga), E(ca)) }, n.\u0275prov = R({ token: n, factory: n.\u0275fac }), n })(); class qf { constructor(t) { this.eventManager = t, this.data = Object.create(null), this.destroyNode = null } destroy() { } createElement(t, e) { return e ? document.createElementNS(zf[e] || e, t) : document.createElement(t) } createComment(t) { return document.createComment(t) } createText(t) { return document.createTextNode(t) } appendChild(t, e) { t.appendChild(e) } insertBefore(t, e, i) { t && t.insertBefore(e, i) } removeChild(t, e) { t && t.removeChild(e) } selectRootElement(t, e) { let i = "string" == typeof t ? document.querySelector(t) : t; if (!i) throw new Error(`The selector "${t}" did not match any elements`); return e || (i.textContent = ""), i } parentNode(t) { return t.parentNode } nextSibling(t) { return t.nextSibling } setAttribute(t, e, i, r) { if (r) { e = r + ":" + e; const o = zf[r]; o ? t.setAttributeNS(o, e, i) : t.setAttribute(e, i) } else t.setAttribute(e, i) } removeAttribute(t, e, i) { if (i) { const r = zf[i]; r ? t.removeAttributeNS(r, e) : t.removeAttribute(`${i}:${e}`) } else t.removeAttribute(e) } addClass(t, e) { t.classList.add(e) } removeClass(t, e) { t.classList.remove(e) } setStyle(t, e, i, r) { r & (sn.DashCase | sn.Important) ? t.style.setProperty(e, i, r & sn.Important ? "important" : "") : t.style[e] = i } removeStyle(t, e, i) { i & sn.DashCase ? t.style.removeProperty(e) : t.style[e] = "" } setProperty(t, e, i) { t[e] = i } setValue(t, e) { t.nodeValue = e } listen(t, e, i) { return "string" == typeof t ? this.eventManager.addGlobalEventListener(t, e, qD(i)) : this.eventManager.addEventListener(t, e, qD(i)) } } class vL extends qf { constructor(t, e, i, r) { super(t), this.component = i; const o = Ac(r + "-" + i.id, i.styles, []); e.addStyles(o), this.contentAttr = function mL(n) { return "_ngcontent-%COMP%".replace(Kf, n) }(r + "-" + i.id), this.hostAttr = function yL(n) { return "_nghost-%COMP%".replace(Kf, n) }(r + "-" + i.id) } applyToHost(t) { super.setAttribute(t, this.hostAttr, "") } createElement(t, e) { const i = super.createElement(t, e); return super.setAttribute(i, this.contentAttr, ""), i } } class DL extends qf { constructor(t, e, i, r) { super(t), this.sharedStylesHost = e, this.hostEl = i, this.shadowRoot = i.attachShadow({ mode: "open" }), this.sharedStylesHost.addHost(this.shadowRoot); const o = Ac(r.id, r.styles, []); for (let s = 0; s < o.length; s++) { const a = document.createElement("style"); a.textContent = o[s], this.shadowRoot.appendChild(a) } } nodeOrShadowRoot(t) { return t === this.hostEl ? this.shadowRoot : t } destroy() { this.sharedStylesHost.removeHost(this.shadowRoot) } appendChild(t, e) { return super.appendChild(this.nodeOrShadowRoot(t), e) } insertBefore(t, e, i) { return super.insertBefore(this.nodeOrShadowRoot(t), e, i) } removeChild(t, e) { return super.removeChild(this.nodeOrShadowRoot(t), e) } parentNode(t) { return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t))) } } let CL = (() => { class n extends $D { constructor(e) { super(e) } supports(e) { return !0 } addEventListener(e, i, r) { return e.addEventListener(i, r, !1), () => this.removeEventListener(e, i, r) } removeEventListener(e, i, r) { return e.removeEventListener(i, r) } } return n.\u0275fac = function(e) { return new (e || n)(E(De)) }, n.\u0275prov = R({ token: n, factory: n.\u0275fac }), n })(); const QD = ["alt", "control", "meta", "shift"], wL = { "\b": "Backspace", "\t": "Tab", "\x7f": "Delete", "\x1b": "Escape", Del: "Delete", Esc: "Escape", Left: "ArrowLeft", Right: "ArrowRight", Up: "ArrowUp", Down: "ArrowDown", Menu: "ContextMenu", Scroll: "ScrollLock", Win: "OS" }, JD = { A: "1", B: "2", C: "3", D: "4", E: "5", F: "6", G: "7", H: "8", I: "9", J: "*", K: "+", M: "-", N: ".", O: "/", "`": "0", "\x90": "NumLock" }, TL = { alt: n => n.altKey, control: n => n.ctrlKey, meta: n => n.metaKey, shift: n => n.shiftKey }; let SL = (() => { class n extends $D { constructor(e) { super(e) } supports(e) { return null != n.parseEventName(e) } addEventListener(e, i, r) { const o = n.parseEventName(i), s = n.eventCallback(o.fullKey, r, this.manager.getZone()); return this.manager.getZone().runOutsideAngular(() => si().onAndCancel(e, o.domEventName, s)) } static parseEventName(e) { const i = e.toLowerCase().split("."), r = i.shift(); if (0 === i.length || "keydown" !== r && "keyup" !== r) return null; const o = n._normalizeKey(i.pop()); let s = ""; if (QD.forEach(l => { const c = i.indexOf(l); c > -1 && (i.splice(c, 1), s += l + ".") }), s += o, 0 != i.length || 0 === o.length) return null; const a = {}; return a.domEventName = r, a.fullKey = s, a } static getEventFullKey(e) { let i = "", r = function AL(n) { let t = n.key; if (null == t) { if (t = n.keyIdentifier, null == t) return "Unidentified"; t.startsWith("U+") && (t = String.fromCharCode(parseInt(t.substring(2), 16)), 3 === n.location && JD.hasOwnProperty(t) && (t = JD[t])) } return wL[t] || t }(e); return r = r.toLowerCase(), " " === r ? r = "space" : "." === r && (r = "dot"), QD.forEach(o => { o != r && TL[o](e) && (i += o + ".") }), i += r, i } static eventCallback(e, i, r) { return o => { n.getEventFullKey(o) === e && r.runGuarded(() => i(o)) } } static _normalizeKey(e) { return "esc" === e ? "escape" : e } } return n.\u0275fac = function(e) { return new (e || n)(E(De)) }, n.\u0275prov = R({ token: n, factory: n.\u0275fac }), n })(); const RL = tD(Nk, "browser", [{ provide: zo, useValue: BD }, { provide: z0, useValue: function ML() { Gf.makeCurrent(), Wf.init() }, multi: !0 }, { provide: De, useFactory: function IL() { return function UA(n) { pd = n }(document), document }, deps: [] }]), OL = [{ provide: Ih, useValue: "root" }, { provide: Di, useFactory: function NL() { return new Di }, deps: [] }, { provide: Tc, useClass: CL, multi: !0, deps: [De, he, zo] }, { provide: Tc, useClass: SL, multi: !0, deps: [De] }, { provide: Mc, useClass: Mc, deps: [Sc, ga, ca] }, { provide: Ho, useExisting: Mc }, { provide: GD, useExisting: ga }, { provide: ga, useClass: ga, deps: [De] }, { provide: Cf, useClass: Cf, deps: [he] }, { provide: Sc, useClass: Sc, deps: [Tc, he] }, { provide: jD, useClass: pL, deps: [] }]; let ZD = (() => { class n { constructor(e) { if (e) throw new Error("BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.") } static withServerTransition(e) { return { ngModule: n, providers: [{ provide: ca, useValue: e.appId }, { provide: UD, useExisting: ca }, fL] } } } return n.\u0275fac = function(e) { return new (e || n)(E(n, 12)) }, n.\u0275mod = se({ type: n }), n.\u0275inj = te({ providers: OL, imports: [Qt, Fk] }), n })(); "undefined" != typeof window && window; let Qf = (() => { class n { } return n.\u0275fac = function(e) { return new (e || n) }, n.\u0275prov = R({ token: n, factory: function(e) { let i = null; return i = e ? new (e || n) : E(t1), i }, providedIn: "root" }), n })(), t1 = (() => { class n extends Qf { constructor(e) { super(), this._doc = e } sanitize(e, i) { if (null == i) return null; switch (e) { case Ee.NONE: return i; case Ee.HTML: return Xn(i, "HTML") ? on(i) : Ym(this._doc, String(i)).toString(); case Ee.STYLE: return Xn(i, "Style") ? on(i) : i; case Ee.SCRIPT: if (Xn(i, "Script")) return on(i); throw new Error("unsafe value used in a script context"); case Ee.URL: return jm(i), Xn(i, "URL") ? on(i) : js(String(i)); case Ee.RESOURCE_URL: if (Xn(i, "ResourceURL")) return on(i); throw new Error("unsafe value used in a resource URL context (see https://g.co/ng/security#xss)"); default: throw new Error(`Unexpected SecurityContext ${e} (see https://g.co/ng/security#xss)`) } } bypassSecurityTrustHtml(e) { return function nN(n) { return new JM(n) }(e) } bypassSecurityTrustStyle(e) { return function iN(n) { return new ZM(n) }(e) } bypassSecurityTrustScript(e) { return function rN(n) { return new XM(n) }(e) } bypassSecurityTrustUrl(e) { return function oN(n) { return new eN(n) }(e) } bypassSecurityTrustResourceUrl(e) { return function sN(n) { return new tN(n) }(e) } } return n.\u0275fac = function(e) { return new (e || n)(E(De)) }, n.\u0275prov = R({ token: n, factory: function(e) { let i = null; return i = e ? new e : function UL(n) { return new t1(n.get(De)) }(E(et)), i }, providedIn: "root" }), n })(); function U(...n) { return bt(n, Es(n)) } class gt extends be { constructor(t) { super(), this._value = t } get value() { return this.getValue() } _subscribe(t) { const e = super._subscribe(t); return !e.closed && t.next(this._value), e } getValue() { const { hasError: t, thrownError: e, _value: i } = this; if (t) throw e; return this._throwIfClosed(), i } next(t) { super.next(this._value = t) } } const { isArray: $L } = Array, { getPrototypeOf: GL, prototype: WL, keys: zL } = Object; function n1(n) { if (1 === n.length) { const t = n[0]; if ($L(t)) return { args: t, keys: null }; if (function KL(n) { return n && "object" == typeof n && GL(n) === WL }(t)) { const e = zL(t); return { args: e.map(i => t[i]), keys: e } } } return { args: n, keys: null } } const { isArray: qL } = Array; function Jf(n) { return W(t => function YL(n, t) { return qL(t) ? n(...t) : n(t) }(n, t)) } function r1(n, t) { return n.reduce((e, i, r) => (e[i] = t[r], e), {}) } function o1(n, t, e) { n ? _i(e, n, t) : t() } const Nc = Ds(n => function() { n(this), this.name = "EmptyError", this.message = "no elements in sequence" }); function _a(...n) { return function JL() { return Cs(1) }()(bt(n, Es(n))) } function s1(n) { return new Ce(t => { Et(n()).subscribe(t) }) } function a1() { return Ge((n, t) => { let e = null; n._refCount++; const i = new Ie(t, void 0, void 0, void 0, () => { if (!n || n._refCount <= 0 || 0 < --n._refCount) return void (e = null); const r = n._connection, o = e; e = null, r && (!o || r === o) && r.unsubscribe(), t.unsubscribe() }); n.subscribe(i), i.closed || (e = n.connect()) }) } class ZL extends Ce { constructor(t, e) { super(), this.source = t, this.subjectFactory = e, this._subject = null, this._refCount = 0, this._connection = null, v_(t) && (this.lift = t.lift) } _subscribe(t) { return this.getSubject().subscribe(t) } getSubject() { const t = this._subject; return (!t || t.isStopped) && (this._subject = this.subjectFactory()), this._subject } _teardown() { this._refCount = 0; const { _connection: t } = this; this._subject = this._connection = null, null == t || t.unsubscribe() } connect() { let t = this._connection; if (!t) { t = this._connection = new Ze; const e = this.getSubject(); t.add(this.source.subscribe(new Ie(e, void 0, () => { this._teardown(), e.complete() }, i => { this._teardown(), e.error(i) }, () => this._teardown()))), t.closed && (this._connection = null, t = Ze.EMPTY) } return t } refCount() { return a1()(this) } } function Ii(n, t) { return Ge((e, i) => { let r = null, o = 0, s = !1; const a = () => s && !r && i.complete(); e.subscribe(new Ie(i, l => { null == r || r.unsubscribe(); let c = 0; const u = o++; Et(n(l, u)).subscribe(r = new Ie(i, d => i.next(t ? t(l, d, u, c++) : d), () => { r = null, a() })) }, () => { s = !0, a() })) }) } function Qo(...n) { const t = Es(n); return Ge((e, i) => { (t ? _a(n, e, t) : _a(n, e)).subscribe(i) }) } function XL(n, t, e, i, r) { return (o, s) => { let a = e, l = t, c = 0; o.subscribe(new Ie(s, u => { const d = c++; l = a ? n(l, u, d) : (a = !0, u), i && s.next(l) }, r && (() => { a && s.next(l), s.complete() }))) } } function l1(n, t) { return Ge(XL(n, t, arguments.length >= 2, !0)) } function jt(n, t) { return Ge((e, i) => { let r = 0; e.subscribe(new Ie(i, o => n.call(t, o, r++) && i.next(o))) }) } function ai(n) { return Ge((t, e) => { let o, i = null, r = !1; i = t.subscribe(new Ie(e, void 0, void 0, s => { o = Et(n(s, ai(n)(t))), i ? (i.unsubscribe(), i = null, o.subscribe(e)) : r = !0 })), r && (i.unsubscribe(), i = null, o.subscribe(e)) }) } function Jo(n, t) { return ye(t) ? it(n, t, 1) : it(n, 1) } function Xf(n) { return n <= 0 ? () => Mn : Ge((t, e) => { let i = []; t.subscribe(new Ie(e, r => { i.push(r), n < i.length && i.shift() }, () => { for (const r of i) e.next(r); e.complete() }, void 0, () => { i = null })) }) } function c1(n = e2) { return Ge((t, e) => { let i = !1; t.subscribe(new Ie(e, r => { i = !0, e.next(r) }, () => i ? e.complete() : e.error(n()))) }) } function e2() { return new Nc } function u1(n) { return Ge((t, e) => { let i = !1; t.subscribe(new Ie(e, r => { i = !0, e.next(r) }, () => { i || e.next(n), e.complete() })) }) } function Zo(n, t) { const e = arguments.length >= 2; return i => i.pipe(n ? jt((r, o) => n(r, o, i)) : gi, ct(1), e ? u1(t) : c1(() => new Nc)) } function _t(n, t, e) { const i = ye(n) || t || e ? { next: n, error: t, complete: e } : n; return i ? Ge((r, o) => { var s; null === (s = i.subscribe) || void 0 === s || s.call(i); let a = !0; r.subscribe(new Ie(o, l => { var c; null === (c = i.next) || void 0 === c || c.call(i, l), o.next(l) }, () => { var l; a = !1, null === (l = i.complete) || void 0 === l || l.call(i), o.complete() }, l => { var c; a = !1, null === (c = i.error) || void 0 === c || c.call(i, l), o.error(l) }, () => { var l, c; a && (null === (l = i.unsubscribe) || void 0 === l || l.call(i)), null === (c = i.finalize) || void 0 === c || c.call(i) })) }) : gi } function d1(n) { return Ge((t, e) => { try { t.subscribe(e) } finally { e.add(n) } }) } class Ri { constructor(t, e) { this.id = t, this.url = e } } class ep extends Ri { constructor(t, e, i = "imperative", r = null) { super(t, e), this.navigationTrigger = i, this.restoredState = r } toString() { return `NavigationStart(id: ${this.id}, url: '${this.url}')` } } class ma extends Ri { constructor(t, e, i) { super(t, e), this.urlAfterRedirects = i } toString() { return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')` } } class h1 extends Ri { constructor(t, e, i) { super(t, e), this.reason = i } toString() { return `NavigationCancel(id: ${this.id}, url: '${this.url}')` } } class n2 extends Ri { constructor(t, e, i) { super(t, e), this.error = i } toString() { return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})` } } class r2 extends Ri { constructor(t, e, i, r) { super(t, e), this.urlAfterRedirects = i, this.state = r } toString() { return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class o2 extends Ri { constructor(t, e, i, r) { super(t, e), this.urlAfterRedirects = i, this.state = r } toString() { return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class s2 extends Ri { constructor(t, e, i, r, o) { super(t, e), this.urlAfterRedirects = i, this.state = r, this.shouldActivate = o } toString() { return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})` } } class a2 extends Ri { constructor(t, e, i, r) { super(t, e), this.urlAfterRedirects = i, this.state = r } toString() { return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class l2 extends Ri { constructor(t, e, i, r) { super(t, e), this.urlAfterRedirects = i, this.state = r } toString() { return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class f1 { constructor(t) { this.route = t } toString() { return `RouteConfigLoadStart(path: ${this.route.path})` } } class p1 { constructor(t) { this.route = t } toString() { return `RouteConfigLoadEnd(path: ${this.route.path})` } } class c2 { constructor(t) { this.snapshot = t } toString() { return `ChildActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class u2 { constructor(t) { this.snapshot = t } toString() { return `ChildActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class d2 { constructor(t) { this.snapshot = t } toString() { return `ActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class h2 { constructor(t) { this.snapshot = t } toString() { return `ActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class g1 { constructor(t, e, i) { this.routerEvent = t, this.position = e, this.anchor = i } toString() { return `Scroll(anchor: '${this.anchor}', position: '${this.position ? `${this.position[0]}, ${this.position[1]}` : null}')` } } const ue = "primary"; class f2 { constructor(t) { this.params = t || {} } has(t) { return Object.prototype.hasOwnProperty.call(this.params, t) } get(t) { if (this.has(t)) { const e = this.params[t]; return Array.isArray(e) ? e[0] : e } return null } getAll(t) { if (this.has(t)) { const e = this.params[t]; return Array.isArray(e) ? e : [e] } return [] } get keys() { return Object.keys(this.params) } } function Xo(n) { return new f2(n) } const _1 = "ngNavigationCancelingError"; function tp(n) { const t = Error("NavigationCancelingError: " + n); return t[_1] = !0, t } function g2(n, t, e) { const i = e.path.split("/"); if (i.length > n.length || "full" === e.pathMatch && (t.hasChildren() || i.length < n.length)) return null; const r = {}; for (let o = 0; o < i.length; o++) { const s = i[o], a = n[o]; if (s.startsWith(":")) r[s.substring(1)] = a; else if (s !== a.path) return null } return { consumed: n.slice(0, i.length), posParams: r } } function li(n, t) { const e = n ? Object.keys(n) : void 0, i = t ? Object.keys(t) : void 0; if (!e || !i || e.length != i.length) return !1; let r; for (let o = 0; o < e.length; o++)if (r = e[o], !m1(n[r], t[r])) return !1; return !0 } function m1(n, t) { if (Array.isArray(n) && Array.isArray(t)) { if (n.length !== t.length) return !1; const e = [...n].sort(), i = [...t].sort(); return e.every((r, o) => i[o] === r) } return n === t } function y1(n) { return Array.prototype.concat.apply([], n) } function b1(n) { return n.length > 0 ? n[n.length - 1] : null } function St(n, t) { for (const e in n) n.hasOwnProperty(e) && t(n[e], e) } function ci(n) { return $h(n) ? n : Zs(n) ? bt(Promise.resolve(n)) : U(n) } const y2 = { exact: function C1(n, t, e) { if (!Rr(n.segments, t.segments) || !Ic(n.segments, t.segments, e) || n.numberOfChildren !== t.numberOfChildren) return !1; for (const i in t.children) if (!n.children[i] || !C1(n.children[i], t.children[i], e)) return !1; return !0 }, subset: E1 }, v1 = { exact: function b2(n, t) { return li(n, t) }, subset: function v2(n, t) { return Object.keys(t).length <= Object.keys(n).length && Object.keys(t).every(e => m1(n[e], t[e])) }, ignored: () => !0 }; function D1(n, t, e) { return y2[e.paths](n.root, t.root, e.matrixParams) && v1[e.queryParams](n.queryParams, t.queryParams) && !("exact" === e.fragment && n.fragment !== t.fragment) } function E1(n, t, e) { return w1(n, t, t.segments, e) } function w1(n, t, e, i) { if (n.segments.length > e.length) { const r = n.segments.slice(0, e.length); return !(!Rr(r, e) || t.hasChildren() || !Ic(r, e, i)) } if (n.segments.length === e.length) { if (!Rr(n.segments, e) || !Ic(n.segments, e, i)) return !1; for (const r in t.children) if (!n.children[r] || !E1(n.children[r], t.children[r], i)) return !1; return !0 } { const r = e.slice(0, n.segments.length), o = e.slice(n.segments.length); return !!(Rr(n.segments, r) && Ic(n.segments, r, i) && n.children[ue]) && w1(n.children[ue], t, o, i) } } function Ic(n, t, e) { return t.every((i, r) => v1[e](n[r].parameters, i.parameters)) } class Ir { constructor(t, e, i) { this.root = t, this.queryParams = e, this.fragment = i } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = Xo(this.queryParams)), this._queryParamMap } toString() { return E2.serialize(this) } } class pe { constructor(t, e) { this.segments = t, this.children = e, this.parent = null, St(e, (i, r) => i.parent = this) } hasChildren() { return this.numberOfChildren > 0 } get numberOfChildren() { return Object.keys(this.children).length } toString() { return Rc(this) } } class ya { constructor(t, e) { this.path = t, this.parameters = e } get parameterMap() { return this._parameterMap || (this._parameterMap = Xo(this.parameters)), this._parameterMap } toString() { return N1(this) } } function Rr(n, t) { return n.length === t.length && n.every((e, i) => e.path === t[i].path) } class T1 { } class S1 { parse(t) { const e = new O2(t); return new Ir(e.parseRootSegment(), e.parseQueryParams(), e.parseFragment()) } serialize(t) { const e = `/${ba(t.root, !0)}`, i = function S2(n) { const t = Object.keys(n).map(e => { const i = n[e]; return Array.isArray(i) ? i.map(r => `${Oc(e)}=${Oc(r)}`).join("&") : `${Oc(e)}=${Oc(i)}` }).filter(e => !!e); return t.length ? `?${t.join("&")}` : "" }(t.queryParams); return `${e}${i}${"string" == typeof t.fragment ? `#${function w2(n) { return encodeURI(n) }(t.fragment)}` : ""}` } } const E2 = new S1; function Rc(n) { return n.segments.map(t => N1(t)).join("/") } function ba(n, t) { if (!n.hasChildren()) return Rc(n); if (t) { const e = n.children[ue] ? ba(n.children[ue], !1) : "", i = []; return St(n.children, (r, o) => { o !== ue && i.push(`${o}:${ba(r, !1)}`) }), i.length > 0 ? `${e}(${i.join("//")})` : e } { const e = function C2(n, t) { let e = []; return St(n.children, (i, r) => { r === ue && (e = e.concat(t(i, r))) }), St(n.children, (i, r) => { r !== ue && (e = e.concat(t(i, r))) }), e }(n, (i, r) => r === ue ? [ba(n.children[ue], !1)] : [`${r}:${ba(i, !1)}`]); return 1 === Object.keys(n.children).length && null != n.children[ue] ? `${Rc(n)}/${e[0]}` : `${Rc(n)}/(${e.join("//")})` } } function A1(n) { return encodeURIComponent(n).replace(/%40/g, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",") } function Oc(n) { return A1(n).replace(/%3B/gi, ";") } function np(n) { return A1(n).replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/%26/gi, "&") } function xc(n) { return decodeURIComponent(n) } function M1(n) { return xc(n.replace(/\+/g, "%20")) } function N1(n) { return `${np(n.path)}${function T2(n) { return Object.keys(n).map(t => `;${np(t)}=${np(n[t])}`).join("") }(n.parameters)}` } const A2 = /^[^\/()?;=#]+/; function Pc(n) { const t = n.match(A2); return t ? t[0] : "" } const M2 = /^[^=?&#]+/, I2 = /^[^&#]+/; class O2 { constructor(t) { this.url = t, this.remaining = t } parseRootSegment() { return this.consumeOptional("/"), "" === this.remaining || this.peekStartsWith("?") || this.peekStartsWith("#") ? new pe([], {}) : new pe([], this.parseChildren()) } parseQueryParams() { const t = {}; if (this.consumeOptional("?")) do { this.parseQueryParam(t) } while (this.consumeOptional("&")); return t } parseFragment() { return this.consumeOptional("#") ? decodeURIComponent(this.remaining) : null } parseChildren() { if ("" === this.remaining) return {}; this.consumeOptional("/"); const t = []; for (this.peekStartsWith("(") || t.push(this.parseSegment()); this.peekStartsWith("/") && !this.peekStartsWith("//") && !this.peekStartsWith("/(");)this.capture("/"), t.push(this.parseSegment()); let e = {}; this.peekStartsWith("/(") && (this.capture("/"), e = this.parseParens(!0)); let i = {}; return this.peekStartsWith("(") && (i = this.parseParens(!1)), (t.length > 0 || Object.keys(e).length > 0) && (i[ue] = new pe(t, e)), i } parseSegment() { const t = Pc(this.remaining); if ("" === t && this.peekStartsWith(";")) throw new Error(`Empty path url segment cannot have parameters: '${this.remaining}'.`); return this.capture(t), new ya(xc(t), this.parseMatrixParams()) } parseMatrixParams() { const t = {}; for (; this.consumeOptional(";");)this.parseParam(t); return t } parseParam(t) { const e = Pc(this.remaining); if (!e) return; this.capture(e); let i = ""; if (this.consumeOptional("=")) { const r = Pc(this.remaining); r && (i = r, this.capture(i)) } t[xc(e)] = xc(i) } parseQueryParam(t) { const e = function N2(n) { const t = n.match(M2); return t ? t[0] : "" }(this.remaining); if (!e) return; this.capture(e); let i = ""; if (this.consumeOptional("=")) { const s = function R2(n) { const t = n.match(I2); return t ? t[0] : "" }(this.remaining); s && (i = s, this.capture(i)) } const r = M1(e), o = M1(i); if (t.hasOwnProperty(r)) { let s = t[r]; Array.isArray(s) || (s = [s], t[r] = s), s.push(o) } else t[r] = o } parseParens(t) { const e = {}; for (this.capture("("); !this.consumeOptional(")") && this.remaining.length > 0;) { const i = Pc(this.remaining), r = this.remaining[i.length]; if ("/" !== r && ")" !== r && ";" !== r) throw new Error(`Cannot parse url '${this.url}'`); let o; i.indexOf(":") > -1 ? (o = i.substr(0, i.indexOf(":")), this.capture(o), this.capture(":")) : t && (o = ue); const s = this.parseChildren(); e[o] = 1 === Object.keys(s).length ? s[ue] : new pe([], s), this.consumeOptional("//") } return e } peekStartsWith(t) { return this.remaining.startsWith(t) } consumeOptional(t) { return !!this.peekStartsWith(t) && (this.remaining = this.remaining.substring(t.length), !0) } capture(t) { if (!this.consumeOptional(t)) throw new Error(`Expected "${t}".`) } } class I1 { constructor(t) { this._root = t } get root() { return this._root.value } parent(t) { const e = this.pathFromRoot(t); return e.length > 1 ? e[e.length - 2] : null } children(t) { const e = ip(t, this._root); return e ? e.children.map(i => i.value) : [] } firstChild(t) { const e = ip(t, this._root); return e && e.children.length > 0 ? e.children[0].value : null } siblings(t) { const e = rp(t, this._root); return e.length < 2 ? [] : e[e.length - 2].children.map(r => r.value).filter(r => r !== t) } pathFromRoot(t) { return rp(t, this._root).map(e => e.value) } } function ip(n, t) { if (n === t.value) return t; for (const e of t.children) { const i = ip(n, e); if (i) return i } return null } function rp(n, t) { if (n === t.value) return [t]; for (const e of t.children) { const i = rp(n, e); if (i.length) return i.unshift(t), i } return [] } class Oi { constructor(t, e) { this.value = t, this.children = e } toString() { return `TreeNode(${this.value})` } } function es(n) { const t = {}; return n && n.children.forEach(e => t[e.value.outlet] = e), t } class R1 extends I1 { constructor(t, e) { super(t), this.snapshot = e, op(this, t) } toString() { return this.snapshot.toString() } } function O1(n, t) { const e = function x2(n, t) { const s = new kc([], {}, {}, "", {}, ue, t, null, n.root, -1, {}); return new P1("", new Oi(s, [])) }(n, t), i = new gt([new ya("", {})]), r = new gt({}), o = new gt({}), s = new gt({}), a = new gt(""), l = new Zi(i, r, s, a, o, ue, t, e.root); return l.snapshot = e.root, new R1(new Oi(l, []), e) } class Zi { constructor(t, e, i, r, o, s, a, l) { this.url = t, this.params = e, this.queryParams = i, this.fragment = r, this.data = o, this.outlet = s, this.component = a, this._futureSnapshot = l } get routeConfig() { return this._futureSnapshot.routeConfig } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = this.params.pipe(W(t => Xo(t)))), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = this.queryParams.pipe(W(t => Xo(t)))), this._queryParamMap } toString() { return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})` } } function x1(n, t = "emptyOnly") { const e = n.pathFromRoot; let i = 0; if ("always" !== t) for (i = e.length - 1; i >= 1;) { const r = e[i], o = e[i - 1]; if (r.routeConfig && "" === r.routeConfig.path) i--; else { if (o.component) break; i-- } } return function P2(n) { return n.reduce((t, e) => ({ params: Object.assign(Object.assign({}, t.params), e.params), data: Object.assign(Object.assign({}, t.data), e.data), resolve: Object.assign(Object.assign({}, t.resolve), e._resolvedData) }), { params: {}, data: {}, resolve: {} }) }(e.slice(i)) } class kc { constructor(t, e, i, r, o, s, a, l, c, u, d) { this.url = t, this.params = e, this.queryParams = i, this.fragment = r, this.data = o, this.outlet = s, this.component = a, this.routeConfig = l, this._urlSegment = c, this._lastPathIndex = u, this._resolve = d } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = Xo(this.params)), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = Xo(this.queryParams)), this._queryParamMap } toString() { return `Route(url:'${this.url.map(i => i.toString()).join("/")}', path:'${this.routeConfig ? this.routeConfig.path : ""}')` } } class P1 extends I1 { constructor(t, e) { super(e), this.url = t, op(this, e) } toString() { return k1(this._root) } } function op(n, t) { t.value._routerState = n, t.children.forEach(e => op(n, e)) } function k1(n) { const t = n.children.length > 0 ? ` { ${n.children.map(k1).join(", ")} } ` : ""; return `${n.value}${t}` } function sp(n) { if (n.snapshot) { const t = n.snapshot, e = n._futureSnapshot; n.snapshot = e, li(t.queryParams, e.queryParams) || n.queryParams.next(e.queryParams), t.fragment !== e.fragment && n.fragment.next(e.fragment), li(t.params, e.params) || n.params.next(e.params), function _2(n, t) { if (n.length !== t.length) return !1; for (let e = 0; e < n.length; ++e)if (!li(n[e], t[e])) return !1; return !0 }(t.url, e.url) || n.url.next(e.url), li(t.data, e.data) || n.data.next(e.data) } else n.snapshot = n._futureSnapshot, n.data.next(n._futureSnapshot.data) } function ap(n, t) { const e = li(n.params, t.params) && function D2(n, t) { return Rr(n, t) && n.every((e, i) => li(e.parameters, t[i].parameters)) }(n.url, t.url); return e && !(!n.parent != !t.parent) && (!n.parent || ap(n.parent, t.parent)) } function va(n, t, e) { if (e && n.shouldReuseRoute(t.value, e.value.snapshot)) { const i = e.value; i._futureSnapshot = t.value; const r = function F2(n, t, e) { return t.children.map(i => { for (const r of e.children) if (n.shouldReuseRoute(i.value, r.value.snapshot)) return va(n, i, r); return va(n, i) }) }(n, t, e); return new Oi(i, r) } { if (n.shouldAttach(t.value)) { const o = n.retrieve(t.value); if (null !== o) { const s = o.route; return s.value._futureSnapshot = t.value, s.children = t.children.map(a => va(n, a)), s } } const i = function L2(n) { return new Zi(new gt(n.url), new gt(n.params), new gt(n.queryParams), new gt(n.fragment), new gt(n.data), n.outlet, n.component, n) }(t.value), r = t.children.map(o => va(n, o)); return new Oi(i, r) } } function Fc(n) { return "object" == typeof n && null != n && !n.outlets && !n.segmentPath } function Da(n) { return "object" == typeof n && null != n && n.outlets } function lp(n, t, e, i, r) { let o = {}; return i && St(i, (s, a) => { o[a] = Array.isArray(s) ? s.map(l => `${l}`) : `${s}` }), new Ir(e.root === n ? t : F1(e.root, n, t), o, r) } function F1(n, t, e) { const i = {}; return St(n.children, (r, o) => { i[o] = r === t ? e : F1(r, t, e) }), new pe(n.segments, i) } class L1 { constructor(t, e, i) { if (this.isAbsolute = t, this.numberOfDoubleDots = e, this.commands = i, t && i.length > 0 && Fc(i[0])) throw new Error("Root segment cannot have matrix parameters"); const r = i.find(Da); if (r && r !== b1(i)) throw new Error("{outlets:{}} has to be the last command") } toRoot() { return this.isAbsolute && 1 === this.commands.length && "/" == this.commands[0] } } class cp { constructor(t, e, i) { this.segmentGroup = t, this.processChildren = e, this.index = i } } function B1(n, t, e) { if (n || (n = new pe([], {})), 0 === n.segments.length && n.hasChildren()) return Lc(n, t, e); const i = function $2(n, t, e) { let i = 0, r = t; const o = { match: !1, pathIndex: 0, commandIndex: 0 }; for (; r < n.segments.length;) { if (i >= e.length) return o; const s = n.segments[r], a = e[i]; if (Da(a)) break; const l = `${a}`, c = i < e.length - 1 ? e[i + 1] : null; if (r > 0 && void 0 === l) break; if (l && c && "object" == typeof c && void 0 === c.outlets) { if (!H1(l, c, s)) return o; i += 2 } else { if (!H1(l, {}, s)) return o; i++ } r++ } return { match: !0, pathIndex: r, commandIndex: i } }(n, t, e), r = e.slice(i.commandIndex); if (i.match && i.pathIndex < n.segments.length) { const o = new pe(n.segments.slice(0, i.pathIndex), {}); return o.children[ue] = new pe(n.segments.slice(i.pathIndex), n.children), Lc(o, 0, r) } return i.match && 0 === r.length ? new pe(n.segments, {}) : i.match && !n.hasChildren() ? up(n, t, e) : i.match ? Lc(n, 0, r) : up(n, t, e) } function Lc(n, t, e) { if (0 === e.length) return new pe(n.segments, {}); { const i = function U2(n) { return Da(n[0]) ? n[0].outlets : { [ue]: n } }(e), r = {}; return St(i, (o, s) => { "string" == typeof o && (o = [o]), null !== o && (r[s] = B1(n.children[s], t, o)) }), St(n.children, (o, s) => { void 0 === i[s] && (r[s] = o) }), new pe(n.segments, r) } } function up(n, t, e) { const i = n.segments.slice(0, t); let r = 0; for (; r < e.length;) { const o = e[r]; if (Da(o)) { const l = G2(o.outlets); return new pe(i, l) } if (0 === r && Fc(e[0])) { i.push(new ya(n.segments[t].path, V1(e[0]))), r++; continue } const s = Da(o) ? o.outlets[ue] : `${o}`, a = r < e.length - 1 ? e[r + 1] : null; s && a && Fc(a) ? (i.push(new ya(s, V1(a))), r += 2) : (i.push(new ya(s, {})), r++) } return new pe(i, {}) } function G2(n) { const t = {}; return St(n, (e, i) => { "string" == typeof e && (e = [e]), null !== e && (t[i] = up(new pe([], {}), 0, e)) }), t } function V1(n) { const t = {}; return St(n, (e, i) => t[i] = `${e}`), t } function H1(n, t, e) { return n == e.path && li(t, e.parameters) } class z2 { constructor(t, e, i, r) { this.routeReuseStrategy = t, this.futureState = e, this.currState = i, this.forwardEvent = r } activate(t) { const e = this.futureState._root, i = this.currState ? this.currState._root : null; this.deactivateChildRoutes(e, i, t), sp(this.futureState.root), this.activateChildRoutes(e, i, t) } deactivateChildRoutes(t, e, i) { const r = es(e); t.children.forEach(o => { const s = o.value.outlet; this.deactivateRoutes(o, r[s], i), delete r[s] }), St(r, (o, s) => { this.deactivateRouteAndItsChildren(o, i) }) } deactivateRoutes(t, e, i) { const r = t.value, o = e ? e.value : null; if (r === o) if (r.component) { const s = i.getContext(r.outlet); s && this.deactivateChildRoutes(t, e, s.children) } else this.deactivateChildRoutes(t, e, i); else o && this.deactivateRouteAndItsChildren(e, i) } deactivateRouteAndItsChildren(t, e) { t.value.component && this.routeReuseStrategy.shouldDetach(t.value.snapshot) ? this.detachAndStoreRouteSubtree(t, e) : this.deactivateRouteAndOutlet(t, e) } detachAndStoreRouteSubtree(t, e) { const i = e.getContext(t.value.outlet), r = i && t.value.component ? i.children : e, o = es(t); for (const s of Object.keys(o)) this.deactivateRouteAndItsChildren(o[s], r); if (i && i.outlet) { const s = i.outlet.detach(), a = i.children.onOutletDeactivated(); this.routeReuseStrategy.store(t.value.snapshot, { componentRef: s, route: t, contexts: a }) } } deactivateRouteAndOutlet(t, e) { const i = e.getContext(t.value.outlet), r = i && t.value.component ? i.children : e, o = es(t); for (const s of Object.keys(o)) this.deactivateRouteAndItsChildren(o[s], r); i && i.outlet && (i.outlet.deactivate(), i.children.onOutletDeactivated(), i.attachRef = null, i.resolver = null, i.route = null) } activateChildRoutes(t, e, i) { const r = es(e); t.children.forEach(o => { this.activateRoutes(o, r[o.value.outlet], i), this.forwardEvent(new h2(o.value.snapshot)) }), t.children.length && this.forwardEvent(new u2(t.value.snapshot)) } activateRoutes(t, e, i) { const r = t.value, o = e ? e.value : null; if (sp(r), r === o) if (r.component) { const s = i.getOrCreateContext(r.outlet); this.activateChildRoutes(t, e, s.children) } else this.activateChildRoutes(t, e, i); else if (r.component) { const s = i.getOrCreateContext(r.outlet); if (this.routeReuseStrategy.shouldAttach(r.snapshot)) { const a = this.routeReuseStrategy.retrieve(r.snapshot); this.routeReuseStrategy.store(r.snapshot, null), s.children.onOutletReAttached(a.contexts), s.attachRef = a.componentRef, s.route = a.route.value, s.outlet && s.outlet.attach(a.componentRef, a.route.value), sp(a.route.value), this.activateChildRoutes(t, null, s.children) } else { const a = function K2(n) { for (let t = n.parent; t; t = t.parent) { const e = t.routeConfig; if (e && e._loadedConfig) return e._loadedConfig; if (e && e.component) return null } return null }(r.snapshot), l = a ? a.module.componentFactoryResolver : null; s.attachRef = null, s.route = r, s.resolver = l, s.outlet && s.outlet.activateWith(r, l), this.activateChildRoutes(t, null, s.children) } } else this.activateChildRoutes(t, null, i) } } class dp { constructor(t, e) { this.routes = t, this.module = e } } function Xi(n) { return "function" == typeof n } function Or(n) { return n instanceof Ir } const Ca = Symbol("INITIAL_VALUE"); function Ea() { return Ii(n => function Zf(...n) { const t = Es(n), e = cl(n), { args: i, keys: r } = n1(n); if (0 === i.length) return bt([], t); const o = new Ce(function QL(n, t, e = gi) { return i => { o1(t, () => { const { length: r } = n, o = new Array(r); let s = r, a = r; for (let l = 0; l < r; l++)o1(t, () => { const c = bt(n[l], t); let u = !1; c.subscribe(new Ie(i, d => { o[l] = d, u || (u = !0, a--), a || i.next(e(o.slice())) }, () => { --s || i.complete() })) }, i) }, i) } }(i, t, r ? s => r1(r, s) : gi)); return e ? o.pipe(Jf(e)) : o }(n.map(t => t.pipe(ct(1), Qo(Ca)))).pipe(l1((t, e) => { let i = !1; return e.reduce((r, o, s) => r !== Ca ? r : (o === Ca && (i = !0), i || !1 !== o && s !== e.length - 1 && !Or(o) ? r : o), t) }, Ca), jt(t => t !== Ca), W(t => Or(t) ? t : !0 === t), ct(1))) } class X2 { constructor() { this.outlet = null, this.route = null, this.resolver = null, this.children = new wa, this.attachRef = null } } class wa { constructor() { this.contexts = new Map } onChildOutletCreated(t, e) { const i = this.getOrCreateContext(t); i.outlet = e, this.contexts.set(t, i) } onChildOutletDestroyed(t) { const e = this.getContext(t); e && (e.outlet = null, e.attachRef = null) } onOutletDeactivated() { const t = this.contexts; return this.contexts = new Map, t } onOutletReAttached(t) { this.contexts = t } getOrCreateContext(t) { let e = this.getContext(t); return e || (e = new X2, this.contexts.set(t, e)), e } getContext(t) { return this.contexts.get(t) || null } } let hp = (() => { class n { constructor(e, i, r, o, s) { this.parentContexts = e, this.location = i, this.resolver = r, this.changeDetector = s, this.activated = null, this._activatedRoute = null, this.activateEvents = new L, this.deactivateEvents = new L, this.attachEvents = new L, this.detachEvents = new L, this.name = o || ue, e.onChildOutletCreated(this.name, this) } ngOnDestroy() { this.parentContexts.onChildOutletDestroyed(this.name) } ngOnInit() { if (!this.activated) { const e = this.parentContexts.getContext(this.name); e && e.route && (e.attachRef ? this.attach(e.attachRef, e.route) : this.activateWith(e.route, e.resolver || null)) } } get isActivated() { return !!this.activated } get component() { if (!this.activated) throw new Error("Outlet is not activated"); return this.activated.instance } get activatedRoute() { if (!this.activated) throw new Error("Outlet is not activated"); return this._activatedRoute } get activatedRouteData() { return this._activatedRoute ? this._activatedRoute.snapshot.data : {} } detach() { if (!this.activated) throw new Error("Outlet is not activated"); this.location.detach(); const e = this.activated; return this.activated = null, this._activatedRoute = null, this.detachEvents.emit(e.instance), e } attach(e, i) { this.activated = e, this._activatedRoute = i, this.location.insert(e.hostView), this.attachEvents.emit(e.instance) } deactivate() { if (this.activated) { const e = this.component; this.activated.destroy(), this.activated = null, this._activatedRoute = null, this.deactivateEvents.emit(e) } } activateWith(e, i) { if (this.isActivated) throw new Error("Cannot activate an already activated outlet"); this._activatedRoute = e; const s = (i = i || this.resolver).resolveComponentFactory(e._futureSnapshot.routeConfig.component), a = this.parentContexts.getOrCreateContext(this.name).children, l = new eB(e, a, this.location.injector); this.activated = this.location.createComponent(s, this.location.length, l), this.changeDetector.markForCheck(), this.activateEvents.emit(this.activated.instance) } } return n.\u0275fac = function(e) { return new (e || n)(g(wa), g(Rt), g(wi), Wi("name"), g(Tt)) }, n.\u0275dir = S({ type: n, selectors: [["router-outlet"]], outputs: { activateEvents: "activate", deactivateEvents: "deactivate", attachEvents: "attach", detachEvents: "detach" }, exportAs: ["outlet"] }), n })(); class eB { constructor(t, e, i) { this.route = t, this.childContexts = e, this.parent = i } get(t, e) { return t === Zi ? this.route : t === wa ? this.childContexts : this.parent.get(t, e) } } let j1 = (() => { class n { } return n.\u0275fac = function(e) { return new (e || n) }, n.\u0275cmp = We({ type: n, selectors: [["ng-component"]], decls: 1, vars: 0, template: function(e, i) { 1 & e && Ue(0, "router-outlet") }, directives: [hp], encapsulation: 2 }), n })(); function U1(n, t = "") { for (let e = 0; e < n.length; e++) { const i = n[e]; tB(i, nB(t, i)) } } function tB(n, t) { n.children && U1(n.children, t) } function nB(n, t) { return t ? n || t.path ? n && !t.path ? `${n}/` : !n && t.path ? t.path : `${n}/${t.path}` : "" : n } function fp(n) { const t = n.children && n.children.map(fp), e = t ? Object.assign(Object.assign({}, n), { children: t }) : Object.assign({}, n); return !e.component && (t || e.loadChildren) && e.outlet && e.outlet !== ue && (e.component = j1), e } function bn(n) { return n.outlet || ue } function $1(n, t) { const e = n.filter(i => bn(i) === t); return e.push(...n.filter(i => bn(i) !== t)), e } const G1 = { matched: !1, consumedSegments: [], lastChild: 0, parameters: {}, positionalParamSegments: {} }; function Bc(n, t, e) { var i; if ("" === t.path) return "full" === t.pathMatch && (n.hasChildren() || e.length > 0) ? Object.assign({}, G1) : { matched: !0, consumedSegments: [], lastChild: 0, parameters: {}, positionalParamSegments: {} }; const o = (t.matcher || g2)(e, n, t); if (!o) return Object.assign({}, G1); const s = {}; St(o.posParams, (l, c) => { s[c] = l.path }); const a = o.consumed.length > 0 ? Object.assign(Object.assign({}, s), o.consumed[o.consumed.length - 1].parameters) : s; return { matched: !0, consumedSegments: o.consumed, lastChild: o.consumed.length, parameters: a, positionalParamSegments: null !== (i = o.posParams) && void 0 !== i ? i : {} } } function Vc(n, t, e, i, r = "corrected") { if (e.length > 0 && function oB(n, t, e) { return e.some(i => Hc(n, t, i) && bn(i) !== ue) }(n, e, i)) { const s = new pe(t, function rB(n, t, e, i) { const r = {}; r[ue] = i, i._sourceSegment = n, i._segmentIndexShift = t.length; for (const o of e) if ("" === o.path && bn(o) !== ue) { const s = new pe([], {}); s._sourceSegment = n, s._segmentIndexShift = t.length, r[bn(o)] = s } return r }(n, t, i, new pe(e, n.children))); return s._sourceSegment = n, s._segmentIndexShift = t.length, { segmentGroup: s, slicedSegments: [] } } if (0 === e.length && function sB(n, t, e) { return e.some(i => Hc(n, t, i)) }(n, e, i)) { const s = new pe(n.segments, function iB(n, t, e, i, r, o) { const s = {}; for (const a of i) if (Hc(n, e, a) && !r[bn(a)]) { const l = new pe([], {}); l._sourceSegment = n, l._segmentIndexShift = "legacy" === o ? n.segments.length : t.length, s[bn(a)] = l } return Object.assign(Object.assign({}, r), s) }(n, t, e, i, n.children, r)); return s._sourceSegment = n, s._segmentIndexShift = t.length, { segmentGroup: s, slicedSegments: e } } const o = new pe(n.segments, n.children); return o._sourceSegment = n, o._segmentIndexShift = t.length, { segmentGroup: o, slicedSegments: e } } function Hc(n, t, e) { return (!(n.hasChildren() || t.length > 0) || "full" !== e.pathMatch) && "" === e.path } function W1(n, t, e, i) { return !!(bn(n) === i || i !== ue && Hc(t, e, n)) && ("**" === n.path || Bc(t, n, e).matched) } function z1(n, t, e) { return 0 === t.length && !n.children[e] } class Ta { constructor(t) { this.segmentGroup = t || null } } class K1 { constructor(t) { this.urlTree = t } } function jc(n) { return new Ce(t => t.error(new Ta(n))) } function q1(n) { return new Ce(t => t.error(new K1(n))) } function aB(n) { return new Ce(t => t.error(new Error(`Only absolute redirects can have named outlets. redirectTo: '${n}'`))) } class uB { constructor(t, e, i, r, o) { this.configLoader = e, this.urlSerializer = i, this.urlTree = r, this.config = o, this.allowRedirects = !0, this.ngModule = t.get(Ti) } apply() { const t = Vc(this.urlTree.root, [], [], this.config).segmentGroup, e = new pe(t.segments, t.children); return this.expandSegmentGroup(this.ngModule, this.config, e, ue).pipe(W(o => this.createUrlTree(pp(o), this.urlTree.queryParams, this.urlTree.fragment))).pipe(ai(o => { if (o instanceof K1) return this.allowRedirects = !1, this.match(o.urlTree); throw o instanceof Ta ? this.noMatchError(o) : o })) } match(t) { return this.expandSegmentGroup(this.ngModule, this.config, t.root, ue).pipe(W(r => this.createUrlTree(pp(r), t.queryParams, t.fragment))).pipe(ai(r => { throw r instanceof Ta ? this.noMatchError(r) : r })) } noMatchError(t) { return new Error(`Cannot match any routes. URL Segment: '${t.segmentGroup}'`) } createUrlTree(t, e, i) { const r = t.segments.length > 0 ? new pe([], { [ue]: t }) : t; return new Ir(r, e, i) } expandSegmentGroup(t, e, i, r) { return 0 === i.segments.length && i.hasChildren() ? this.expandChildren(t, e, i).pipe(W(o => new pe([], o))) : this.expandSegment(t, i, e, i.segments, r, !0) } expandChildren(t, e, i) { const r = []; for (const o of Object.keys(i.children)) "primary" === o ? r.unshift(o) : r.push(o); return bt(r).pipe(Jo(o => { const s = i.children[o], a = $1(e, o); return this.expandSegmentGroup(t, a, s, o).pipe(W(l => ({ segment: l, outlet: o }))) }), l1((o, s) => (o[s.outlet] = s.segment, o), {}), function t2(n, t) { const e = arguments.length >= 2; return i => i.pipe(n ? jt((r, o) => n(r, o, i)) : gi, Xf(1), e ? u1(t) : c1(() => new Nc)) }()) } expandSegment(t, e, i, r, o, s) { return bt(i).pipe(Jo(a => this.expandSegmentAgainstRoute(t, e, i, a, r, o, s).pipe(ai(c => { if (c instanceof Ta) return U(null); throw c }))), Zo(a => !!a), ai((a, l) => { if (a instanceof Nc || "EmptyError" === a.name) { if (z1(e, r, o)) return U(new pe([], {})); throw new Ta(e) } throw a })) } expandSegmentAgainstRoute(t, e, i, r, o, s, a) { return W1(r, e, o, s) ? void 0 === r.redirectTo ? this.matchSegmentAgainstRoute(t, e, r, o, s) : a && this.allowRedirects ? this.expandSegmentAgainstRouteUsingRedirect(t, e, i, r, o, s) : jc(e) : jc(e) } expandSegmentAgainstRouteUsingRedirect(t, e, i, r, o, s) { return "**" === r.path ? this.expandWildCardWithParamsAgainstRouteUsingRedirect(t, i, r, s) : this.expandRegularSegmentAgainstRouteUsingRedirect(t, e, i, r, o, s) } expandWildCardWithParamsAgainstRouteUsingRedirect(t, e, i, r) { const o = this.applyRedirectCommands([], i.redirectTo, {}); return i.redirectTo.startsWith("/") ? q1(o) : this.lineralizeSegments(i, o).pipe(it(s => { const a = new pe(s, {}); return this.expandSegment(t, a, e, s, r, !1) })) } expandRegularSegmentAgainstRouteUsingRedirect(t, e, i, r, o, s) { const { matched: a, consumedSegments: l, lastChild: c, positionalParamSegments: u } = Bc(e, r, o); if (!a) return jc(e); const d = this.applyRedirectCommands(l, r.redirectTo, u); return r.redirectTo.startsWith("/") ? q1(d) : this.lineralizeSegments(r, d).pipe(it(h => this.expandSegment(t, e, i, h.concat(o.slice(c)), s, !1))) } matchSegmentAgainstRoute(t, e, i, r, o) { if ("**" === i.path) return i.loadChildren ? (i._loadedConfig ? U(i._loadedConfig) : this.configLoader.load(t.injector, i)).pipe(W(h => (i._loadedConfig = h, new pe(r, {})))) : U(new pe(r, {})); const { matched: s, consumedSegments: a, lastChild: l } = Bc(e, i, r); if (!s) return jc(e); const c = r.slice(l); return this.getChildConfig(t, i, r).pipe(it(d => { const h = d.module, f = d.routes, { segmentGroup: p, slicedSegments: _ } = Vc(e, a, c, f), y = new pe(p.segments, p.children); if (0 === _.length && y.hasChildren()) return this.expandChildren(h, f, y).pipe(W(T => new pe(a, T))); if (0 === f.length && 0 === _.length) return U(new pe(a, {})); const b = bn(i) === o; return this.expandSegment(h, y, f, _, b ? ue : o, !0).pipe(W(C => new pe(a.concat(C.segments), C.children))) })) } getChildConfig(t, e, i) { return e.children ? U(new dp(e.children, t)) : e.loadChildren ? void 0 !== e._loadedConfig ? U(e._loadedConfig) : this.runCanLoadGuards(t.injector, e, i).pipe(it(r => r ? this.configLoader.load(t.injector, e).pipe(W(o => (e._loadedConfig = o, o))) : function lB(n) { return new Ce(t => t.error(tp(`Cannot load children because the guard of the route "path: '${n.path}'" returned false`))) }(e))) : U(new dp([], t)) } runCanLoadGuards(t, e, i) { const r = e.canLoad; return r && 0 !== r.length ? U(r.map(s => { const a = t.get(s); let l; if (function Y2(n) { return n && Xi(n.canLoad) }(a)) l = a.canLoad(e, i); else { if (!Xi(a)) throw new Error("Invalid CanLoad guard"); l = a(e, i) } return ci(l) })).pipe(Ea(), _t(s => { if (!Or(s)) return; const a = tp(`Redirecting to "${this.urlSerializer.serialize(s)}"`); throw a.url = s, a }), W(s => !0 === s)) : U(!0) } lineralizeSegments(t, e) { let i = [], r = e.root; for (; ;) { if (i = i.concat(r.segments), 0 === r.numberOfChildren) return U(i); if (r.numberOfChildren > 1 || !r.children[ue]) return aB(t.redirectTo); r = r.children[ue] } } applyRedirectCommands(t, e, i) { return this.applyRedirectCreatreUrlTree(e, this.urlSerializer.parse(e), t, i) } applyRedirectCreatreUrlTree(t, e, i, r) { const o = this.createSegmentGroup(t, e.root, i, r); return new Ir(o, this.createQueryParams(e.queryParams, this.urlTree.queryParams), e.fragment) } createQueryParams(t, e) { const i = {}; return St(t, (r, o) => { if ("string" == typeof r && r.startsWith(":")) { const a = r.substring(1); i[o] = e[a] } else i[o] = r }), i } createSegmentGroup(t, e, i, r) { const o = this.createSegments(t, e.segments, i, r); let s = {}; return St(e.children, (a, l) => { s[l] = this.createSegmentGroup(t, a, i, r) }), new pe(o, s) } createSegments(t, e, i, r) { return e.map(o => o.path.startsWith(":") ? this.findPosParam(t, o, r) : this.findOrReturn(o, i)) } findPosParam(t, e, i) { const r = i[e.path.substring(1)]; if (!r) throw new Error(`Cannot redirect to '${t}'. Cannot find '${e.path}'.`); return r } findOrReturn(t, e) { let i = 0; for (const r of e) { if (r.path === t.path) return e.splice(i), r; i++ } return t } } function pp(n) { const t = {}; for (const i of Object.keys(n.children)) { const o = pp(n.children[i]); (o.segments.length > 0 || o.hasChildren()) && (t[i] = o) } return function dB(n) { if (1 === n.numberOfChildren && n.children[ue]) { const t = n.children[ue]; return new pe(n.segments.concat(t.segments), t.children) } return n }(new pe(n.segments, t)) } class Y1 { constructor(t) { this.path = t, this.route = this.path[this.path.length - 1] } } class Uc { constructor(t, e) { this.component = t, this.route = e } } function fB(n, t, e) { const i = n._root; return Sa(i, t ? t._root : null, e, [i.value]) } function $c(n, t, e) { const i = function gB(n) { if (!n) return null; for (let t = n.parent; t; t = t.parent) { const e = t.routeConfig; if (e && e._loadedConfig) return e._loadedConfig } return null }(t); return (i ? i.module.injector : e).get(n) } function Sa(n, t, e, i, r = { canDeactivateChecks: [], canActivateChecks: [] }) { const o = es(t); return n.children.forEach(s => { (function _B(n, t, e, i, r = { canDeactivateChecks: [], canActivateChecks: [] }) { const o = n.value, s = t ? t.value : null, a = e ? e.getContext(n.value.outlet) : null; if (s && o.routeConfig === s.routeConfig) { const l = function mB(n, t, e) { if ("function" == typeof e) return e(n, t); switch (e) { case "pathParamsChange": return !Rr(n.url, t.url); case "pathParamsOrQueryParamsChange": return !Rr(n.url, t.url) || !li(n.queryParams, t.queryParams); case "always": return !0; case "paramsOrQueryParamsChange": return !ap(n, t) || !li(n.queryParams, t.queryParams); default: return !ap(n, t) } }(s, o, o.routeConfig.runGuardsAndResolvers); l ? r.canActivateChecks.push(new Y1(i)) : (o.data = s.data, o._resolvedData = s._resolvedData), Sa(n, t, o.component ? a ? a.children : null : e, i, r), l && a && a.outlet && a.outlet.isActivated && r.canDeactivateChecks.push(new Uc(a.outlet.component, s)) } else s && Aa(t, a, r), r.canActivateChecks.push(new Y1(i)), Sa(n, null, o.component ? a ? a.children : null : e, i, r) })(s, o[s.value.outlet], e, i.concat([s.value]), r), delete o[s.value.outlet] }), St(o, (s, a) => Aa(s, e.getContext(a), r)), r } function Aa(n, t, e) { const i = es(n), r = n.value; St(i, (o, s) => { Aa(o, r.component ? t ? t.children.getContext(s) : null : t, e) }), e.canDeactivateChecks.push(new Uc(r.component && t && t.outlet && t.outlet.isActivated ? t.outlet.component : null, r)) } class SB { } function Q1(n) { return new Ce(t => t.error(n)) } class MB { constructor(t, e, i, r, o, s) { this.rootComponentType = t, this.config = e, this.urlTree = i, this.url = r, this.paramsInheritanceStrategy = o, this.relativeLinkResolution = s } recognize() { const t = Vc(this.urlTree.root, [], [], this.config.filter(s => void 0 === s.redirectTo), this.relativeLinkResolution).segmentGroup, e = this.processSegmentGroup(this.config, t, ue); if (null === e) return null; const i = new kc([], Object.freeze({}), Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, {}, ue, this.rootComponentType, null, this.urlTree.root, -1, {}), r = new Oi(i, e), o = new P1(this.url, r); return this.inheritParamsAndData(o._root), o } inheritParamsAndData(t) { const e = t.value, i = x1(e, this.paramsInheritanceStrategy); e.params = Object.freeze(i.params), e.data = Object.freeze(i.data), t.children.forEach(r => this.inheritParamsAndData(r)) } processSegmentGroup(t, e, i) { return 0 === e.segments.length && e.hasChildren() ? this.processChildren(t, e) : this.processSegment(t, e, e.segments, i) } processChildren(t, e) { const i = []; for (const o of Object.keys(e.children)) { const s = e.children[o], a = $1(t, o), l = this.processSegmentGroup(a, s, o); if (null === l) return null; i.push(...l) } const r = J1(i); return function NB(n) { n.sort((t, e) => t.value.outlet === ue ? -1 : e.value.outlet === ue ? 1 : t.value.outlet.localeCompare(e.value.outlet)) }(r), r } processSegment(t, e, i, r) { for (const o of t) { const s = this.processSegmentAgainstRoute(o, e, i, r); if (null !== s) return s } return z1(e, i, r) ? [] : null } processSegmentAgainstRoute(t, e, i, r) { if (t.redirectTo || !W1(t, e, i, r)) return null; let o, s = [], a = []; if ("**" === t.path) { const f = i.length > 0 ? b1(i).parameters : {}; o = new kc(i, f, Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, eC(t), bn(t), t.component, t, Z1(e), X1(e) + i.length, tC(t)) } else { const f = Bc(e, t, i); if (!f.matched) return null; s = f.consumedSegments, a = i.slice(f.lastChild), o = new kc(s, f.parameters, Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, eC(t), bn(t), t.component, t, Z1(e), X1(e) + s.length, tC(t)) } const l = function IB(n) { return n.children ? n.children : n.loadChildren ? n._loadedConfig.routes : [] }(t), { segmentGroup: c, slicedSegments: u } = Vc(e, s, a, l.filter(f => void 0 === f.redirectTo), this.relativeLinkResolution); if (0 === u.length && c.hasChildren()) { const f = this.processChildren(l, c); return null === f ? null : [new Oi(o, f)] } if (0 === l.length && 0 === u.length) return [new Oi(o, [])]; const d = bn(t) === r, h = this.processSegment(l, c, u, d ? ue : r); return null === h ? null : [new Oi(o, h)] } } function RB(n) { const t = n.value.routeConfig; return t && "" === t.path && void 0 === t.redirectTo } function J1(n) { const t = [], e = new Set; for (const i of n) { if (!RB(i)) { t.push(i); continue } const r = t.find(o => i.value.routeConfig === o.value.routeConfig); void 0 !== r ? (r.children.push(...i.children), e.add(r)) : t.push(i) } for (const i of e) { const r = J1(i.children); t.push(new Oi(i.value, r)) } return t.filter(i => !e.has(i)) } function Z1(n) { let t = n; for (; t._sourceSegment;)t = t._sourceSegment; return t } function X1(n) { let t = n, e = t._segmentIndexShift ? t._segmentIndexShift : 0; for (; t._sourceSegment;)t = t._sourceSegment, e += t._segmentIndexShift ? t._segmentIndexShift : 0; return e - 1 } function eC(n) { return n.data || {} } function tC(n) { return n.resolve || {} } function gp(n) { return Ii(t => { const e = n(t); return e ? bt(e).pipe(W(() => t)) : U(t) }) } class VB extends class BB { shouldDetach(t) { return !1 } store(t, e) { } shouldAttach(t) { return !1 } retrieve(t) { return null } shouldReuseRoute(t, e) { return t.routeConfig === e.routeConfig } }{ } const _p = new P("ROUTES"); class nC { constructor(t, e, i, r) { this.injector = t, this.compiler = e, this.onLoadStartListener = i, this.onLoadEndListener = r } load(t, e) { if (e._loader$) return e._loader$; this.onLoadStartListener && this.onLoadStartListener(e); const r = this.loadModuleFactory(e.loadChildren).pipe(W(o => { this.onLoadEndListener && this.onLoadEndListener(e); const s = o.create(t); return new dp(y1(s.injector.get(_p, void 0, Z.Self | Z.Optional)).map(fp), s) }), ai(o => { throw e._loader$ = void 0, o })); return e._loader$ = new ZL(r, () => new be).pipe(a1()), e._loader$ } loadModuleFactory(t) { return ci(t()).pipe(it(e => e instanceof f0 ? U(e) : bt(this.compiler.compileModuleAsync(e)))) } } class jB { shouldProcessUrl(t) { return !0 } extract(t) { return t } merge(t, e) { return t } } function UB(n) { throw n } function $B(n, t, e) { return t.parse("/") } function iC(n, t) { return U(null) } const GB = { paths: "exact", fragment: "ignored", matrixParams: "ignored", queryParams: "exact" }, WB = { paths: "subset", fragment: "ignored", matrixParams: "ignored", queryParams: "subset" }; let Ot = (() => { class n { constructor(e, i, r, o, s, a, l) { this.rootComponentType = e, this.urlSerializer = i, this.rootContexts = r, this.location = o, this.config = l, this.lastSuccessfulNavigation = null, this.currentNavigation = null, this.disposed = !1, this.navigationId = 0, this.currentPageId = 0, this.isNgZoneEnabled = !1, this.events = new be, this.errorHandler = UB, this.malformedUriErrorHandler = $B, this.navigated = !1, this.lastSuccessfulId = -1, this.hooks = { beforePreactivation: iC, afterPreactivation: iC }, this.urlHandlingStrategy = new jB, this.routeReuseStrategy = new VB, this.onSameUrlNavigation = "ignore", this.paramsInheritanceStrategy = "emptyOnly", this.urlUpdateStrategy = "deferred", this.relativeLinkResolution = "corrected", this.canceledNavigationResolution = "replace", this.ngModule = s.get(Ti), this.console = s.get(q0); const d = s.get(he); this.isNgZoneEnabled = d instanceof he && he.isInAngularZone(), this.resetConfig(l), this.currentUrlTree = function m2() { return new Ir(new pe([], {}), {}, null) }(), this.rawUrlTree = this.currentUrlTree, this.browserUrlTree = this.currentUrlTree, this.configLoader = new nC(s, a, h => this.triggerEvent(new f1(h)), h => this.triggerEvent(new p1(h))), this.routerState = O1(this.currentUrlTree, this.rootComponentType), this.transitions = new gt({ id: 0, targetPageId: 0, currentUrlTree: this.currentUrlTree, currentRawUrl: this.currentUrlTree, extractedUrl: this.urlHandlingStrategy.extract(this.currentUrlTree), urlAfterRedirects: this.urlHandlingStrategy.extract(this.currentUrlTree), rawUrl: this.currentUrlTree, extras: {}, resolve: null, reject: null, promise: Promise.resolve(!0), source: "imperative", restoredState: null, currentSnapshot: this.routerState.snapshot, targetSnapshot: null, currentRouterState: this.routerState, targetRouterState: null, guards: { canActivateChecks: [], canDeactivateChecks: [] }, guardsResult: null }), this.navigations = this.setupNavigations(this.transitions), this.processNavigations() } get browserPageId() { var e; return null === (e = this.location.getState()) || void 0 === e ? void 0 : e.\u0275routerPageId } setupNavigations(e) { const i = this.events; return e.pipe(jt(r => 0 !== r.id), W(r => Object.assign(Object.assign({}, r), { extractedUrl: this.urlHandlingStrategy.extract(r.rawUrl) })), Ii(r => { let o = !1, s = !1; return U(r).pipe(_t(a => { this.currentNavigation = { id: a.id, initialUrl: a.currentRawUrl, extractedUrl: a.extractedUrl, trigger: a.source, extras: a.extras, previousNavigation: this.lastSuccessfulNavigation ? Object.assign(Object.assign({}, this.lastSuccessfulNavigation), { previousNavigation: null }) : null } }), Ii(a => { const l = this.browserUrlTree.toString(), c = !this.navigated || a.extractedUrl.toString() !== l || l !== this.currentUrlTree.toString(); if (("reload" === this.onSameUrlNavigation || c) && this.urlHandlingStrategy.shouldProcessUrl(a.rawUrl)) return Gc(a.source) && (this.browserUrlTree = a.extractedUrl), U(a).pipe(Ii(d => { const h = this.transitions.getValue(); return i.next(new ep(d.id, this.serializeUrl(d.extractedUrl), d.source, d.restoredState)), h !== this.transitions.getValue() ? Mn : Promise.resolve(d) }), function hB(n, t, e, i) { return Ii(r => function cB(n, t, e, i, r) { return new uB(n, t, e, i, r).apply() }(n, t, e, r.extractedUrl, i).pipe(W(o => Object.assign(Object.assign({}, r), { urlAfterRedirects: o })))) }(this.ngModule.injector, this.configLoader, this.urlSerializer, this.config), _t(d => { this.currentNavigation = Object.assign(Object.assign({}, this.currentNavigation), { finalUrl: d.urlAfterRedirects }) }), function OB(n, t, e, i, r) { return it(o => function AB(n, t, e, i, r = "emptyOnly", o = "legacy") { try { const s = new MB(n, t, e, i, r, o).recognize(); return null === s ? Q1(new SB) : U(s) } catch (s) { return Q1(s) } }(n, t, o.urlAfterRedirects, e(o.urlAfterRedirects), i, r).pipe(W(s => Object.assign(Object.assign({}, o), { targetSnapshot: s })))) }(this.rootComponentType, this.config, d => this.serializeUrl(d), this.paramsInheritanceStrategy, this.relativeLinkResolution), _t(d => { if ("eager" === this.urlUpdateStrategy) { if (!d.extras.skipLocationChange) { const f = this.urlHandlingStrategy.merge(d.urlAfterRedirects, d.rawUrl); this.setBrowserUrl(f, d) } this.browserUrlTree = d.urlAfterRedirects } const h = new r2(d.id, this.serializeUrl(d.extractedUrl), this.serializeUrl(d.urlAfterRedirects), d.targetSnapshot); i.next(h) })); if (c && this.rawUrlTree && this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)) { const { id: h, extractedUrl: f, source: p, restoredState: _, extras: y } = a, b = new ep(h, this.serializeUrl(f), p, _); i.next(b); const m = O1(f, this.rootComponentType).snapshot; return U(Object.assign(Object.assign({}, a), { targetSnapshot: m, urlAfterRedirects: f, extras: Object.assign(Object.assign({}, y), { skipLocationChange: !1, replaceUrl: !1 }) })) } return this.rawUrlTree = a.rawUrl, a.resolve(null), Mn }), gp(a => { const { targetSnapshot: l, id: c, extractedUrl: u, rawUrl: d, extras: { skipLocationChange: h, replaceUrl: f } } = a; return this.hooks.beforePreactivation(l, { navigationId: c, appliedUrlTree: u, rawUrlTree: d, skipLocationChange: !!h, replaceUrl: !!f }) }), _t(a => { const l = new o2(a.id, this.serializeUrl(a.extractedUrl), this.serializeUrl(a.urlAfterRedirects), a.targetSnapshot); this.triggerEvent(l) }), W(a => Object.assign(Object.assign({}, a), { guards: fB(a.targetSnapshot, a.currentSnapshot, this.rootContexts) })), function yB(n, t) { return it(e => { const { targetSnapshot: i, currentSnapshot: r, guards: { canActivateChecks: o, canDeactivateChecks: s } } = e; return 0 === s.length && 0 === o.length ? U(Object.assign(Object.assign({}, e), { guardsResult: !0 })) : function bB(n, t, e, i) { return bt(n).pipe(it(r => function TB(n, t, e, i, r) { const o = t && t.routeConfig ? t.routeConfig.canDeactivate : null; return o && 0 !== o.length ? U(o.map(a => { const l = $c(a, t, r); let c; if (function Z2(n) { return n && Xi(n.canDeactivate) }(l)) c = ci(l.canDeactivate(n, t, e, i)); else { if (!Xi(l)) throw new Error("Invalid CanDeactivate guard"); c = ci(l(n, t, e, i)) } return c.pipe(Zo()) })).pipe(Ea()) : U(!0) }(r.component, r.route, e, t, i)), Zo(r => !0 !== r, !0)) }(s, i, r, n).pipe(it(a => a && function q2(n) { return "boolean" == typeof n }(a) ? function vB(n, t, e, i) { return bt(t).pipe(Jo(r => _a(function CB(n, t) { return null !== n && t && t(new c2(n)), U(!0) }(r.route.parent, i), function DB(n, t) { return null !== n && t && t(new d2(n)), U(!0) }(r.route, i), function wB(n, t, e) { const i = t[t.length - 1], o = t.slice(0, t.length - 1).reverse().map(s => function pB(n) { const t = n.routeConfig ? n.routeConfig.canActivateChild : null; return t && 0 !== t.length ? { node: n, guards: t } : null }(s)).filter(s => null !== s).map(s => s1(() => U(s.guards.map(l => { const c = $c(l, s.node, e); let u; if (function J2(n) { return n && Xi(n.canActivateChild) }(c)) u = ci(c.canActivateChild(i, n)); else { if (!Xi(c)) throw new Error("Invalid CanActivateChild guard"); u = ci(c(i, n)) } return u.pipe(Zo()) })).pipe(Ea()))); return U(o).pipe(Ea()) }(n, r.path, e), function EB(n, t, e) { const i = t.routeConfig ? t.routeConfig.canActivate : null; if (!i || 0 === i.length) return U(!0); const r = i.map(o => s1(() => { const s = $c(o, t, e); let a; if (function Q2(n) { return n && Xi(n.canActivate) }(s)) a = ci(s.canActivate(t, n)); else { if (!Xi(s)) throw new Error("Invalid CanActivate guard"); a = ci(s(t, n)) } return a.pipe(Zo()) })); return U(r).pipe(Ea()) }(n, r.route, e))), Zo(r => !0 !== r, !0)) }(i, o, n, t) : U(a)), W(a => Object.assign(Object.assign({}, e), { guardsResult: a }))) }) }(this.ngModule.injector, a => this.triggerEvent(a)), _t(a => { if (Or(a.guardsResult)) { const c = tp(`Redirecting to "${this.serializeUrl(a.guardsResult)}"`); throw c.url = a.guardsResult, c } const l = new s2(a.id, this.serializeUrl(a.extractedUrl), this.serializeUrl(a.urlAfterRedirects), a.targetSnapshot, !!a.guardsResult); this.triggerEvent(l) }), jt(a => !!a.guardsResult || (this.restoreHistory(a), this.cancelNavigationTransition(a, ""), !1)), gp(a => { if (a.guards.canActivateChecks.length) return U(a).pipe(_t(l => { const c = new a2(l.id, this.serializeUrl(l.extractedUrl), this.serializeUrl(l.urlAfterRedirects), l.targetSnapshot); this.triggerEvent(c) }), Ii(l => { let c = !1; return U(l).pipe(function xB(n, t) { return it(e => { const { targetSnapshot: i, guards: { canActivateChecks: r } } = e; if (!r.length) return U(e); let o = 0; return bt(r).pipe(Jo(s => function PB(n, t, e, i) { return function kB(n, t, e, i) { const r = Object.keys(n); if (0 === r.length) return U({}); const o = {}; return bt(r).pipe(it(s => function FB(n, t, e, i) { const r = $c(n, t, i); return ci(r.resolve ? r.resolve(t, e) : r(t, e)) }(n[s], t, e, i).pipe(_t(a => { o[s] = a }))), Xf(1), it(() => Object.keys(o).length === r.length ? U(o) : Mn)) }(n._resolve, n, t, i).pipe(W(o => (n._resolvedData = o, n.data = Object.assign(Object.assign({}, n.data), x1(n, e).resolve), null))) }(s.route, i, n, t)), _t(() => o++), Xf(1), it(s => o === r.length ? U(e) : Mn)) }) }(this.paramsInheritanceStrategy, this.ngModule.injector), _t({ next: () => c = !0, complete: () => { c || (this.restoreHistory(l), this.cancelNavigationTransition(l, "At least one route resolver didn't emit any value.")) } })) }), _t(l => { const c = new l2(l.id, this.serializeUrl(l.extractedUrl), this.serializeUrl(l.urlAfterRedirects), l.targetSnapshot); this.triggerEvent(c) })) }), gp(a => { const { targetSnapshot: l, id: c, extractedUrl: u, rawUrl: d, extras: { skipLocationChange: h, replaceUrl: f } } = a; return this.hooks.afterPreactivation(l, { navigationId: c, appliedUrlTree: u, rawUrlTree: d, skipLocationChange: !!h, replaceUrl: !!f }) }), W(a => { const l = function k2(n, t, e) { const i = va(n, t._root, e ? e._root : void 0); return new R1(i, t) }(this.routeReuseStrategy, a.targetSnapshot, a.currentRouterState); return Object.assign(Object.assign({}, a), { targetRouterState: l }) }), _t(a => { this.currentUrlTree = a.urlAfterRedirects, this.rawUrlTree = this.urlHandlingStrategy.merge(a.urlAfterRedirects, a.rawUrl), this.routerState = a.targetRouterState, "deferred" === this.urlUpdateStrategy && (a.extras.skipLocationChange || this.setBrowserUrl(this.rawUrlTree, a), this.browserUrlTree = a.urlAfterRedirects) }), ((n, t, e) => W(i => (new z2(t, i.targetRouterState, i.currentRouterState, e).activate(n), i)))(this.rootContexts, this.routeReuseStrategy, a => this.triggerEvent(a)), _t({ next() { o = !0 }, complete() { o = !0 } }), d1(() => { var a; o || s || this.cancelNavigationTransition(r, `Navigation ID ${r.id} is not equal to the current navigation id ${this.navigationId}`), (null === (a = this.currentNavigation) || void 0 === a ? void 0 : a.id) === r.id && (this.currentNavigation = null) }), ai(a => { if (s = !0, function p2(n) { return n && n[_1] }(a)) { const l = Or(a.url); l || (this.navigated = !0, this.restoreHistory(r, !0)); const c = new h1(r.id, this.serializeUrl(r.extractedUrl), a.message); i.next(c), l ? setTimeout(() => { const u = this.urlHandlingStrategy.merge(a.url, this.rawUrlTree), d = { skipLocationChange: r.extras.skipLocationChange, replaceUrl: "eager" === this.urlUpdateStrategy || Gc(r.source) }; this.scheduleNavigation(u, "imperative", null, d, { resolve: r.resolve, reject: r.reject, promise: r.promise }) }, 0) : r.resolve(!1) } else { this.restoreHistory(r, !0); const l = new n2(r.id, this.serializeUrl(r.extractedUrl), a); i.next(l); try { r.resolve(this.errorHandler(a)) } catch (c) { r.reject(c) } } return Mn })) })) } resetRootComponentType(e) { this.rootComponentType = e, this.routerState.root.component = this.rootComponentType } setTransition(e) { this.transitions.next(Object.assign(Object.assign({}, this.transitions.value), e)) } initialNavigation() { this.setUpLocationChangeListener(), 0 === this.navigationId && this.navigateByUrl(this.location.path(!0), { replaceUrl: !0 }) } setUpLocationChangeListener() { this.locationSubscription || (this.locationSubscription = this.location.subscribe(e => { const i = "popstate" === e.type ? "popstate" : "hashchange"; "popstate" === i && setTimeout(() => { var r; const o = { replaceUrl: !0 }, s = (null === (r = e.state) || void 0 === r ? void 0 : r.navigationId) ? e.state : null; if (s) { const l = Object.assign({}, s); delete l.navigationId, delete l.\u0275routerPageId, 0 !== Object.keys(l).length && (o.state = l) } const a = this.parseUrl(e.url); this.scheduleNavigation(a, i, s, o) }, 0) })) } get url() { return this.serializeUrl(this.currentUrlTree) } getCurrentNavigation() { return this.currentNavigation } triggerEvent(e) { this.events.next(e) } resetConfig(e) { U1(e), this.config = e.map(fp), this.navigated = !1, this.lastSuccessfulId = -1 } ngOnDestroy() { this.dispose() } dispose() { this.transitions.complete(), this.locationSubscription && (this.locationSubscription.unsubscribe(), this.locationSubscription = void 0), this.disposed = !0 } createUrlTree(e, i = {}) { const { relativeTo: r, queryParams: o, fragment: s, queryParamsHandling: a, preserveFragment: l } = i, c = r || this.routerState.root, u = l ? this.currentUrlTree.fragment : s; let d = null; switch (a) { case "merge": d = Object.assign(Object.assign({}, this.currentUrlTree.queryParams), o); break; case "preserve": d = this.currentUrlTree.queryParams; break; default: d = o || null }return null !== d && (d = this.removeEmptyProps(d)), function B2(n, t, e, i, r) { if (0 === e.length) return lp(t.root, t.root, t, i, r); const o = function V2(n) { if ("string" == typeof n[0] && 1 === n.length && "/" === n[0]) return new L1(!0, 0, n); let t = 0, e = !1; const i = n.reduce((r, o, s) => { if ("object" == typeof o && null != o) { if (o.outlets) { const a = {}; return St(o.outlets, (l, c) => { a[c] = "string" == typeof l ? l.split("/") : l }), [...r, { outlets: a }] } if (o.segmentPath) return [...r, o.segmentPath] } return "string" != typeof o ? [...r, o] : 0 === s ? (o.split("/").forEach((a, l) => { 0 == l && "." === a || (0 == l && "" === a ? e = !0 : ".." === a ? t++ : "" != a && r.push(a)) }), r) : [...r, o] }, []); return new L1(e, t, i) }(e); if (o.toRoot()) return lp(t.root, new pe([], {}), t, i, r); const s = function H2(n, t, e) { if (n.isAbsolute) return new cp(t.root, !0, 0); if (-1 === e.snapshot._lastPathIndex) { const o = e.snapshot._urlSegment; return new cp(o, o === t.root, 0) } const i = Fc(n.commands[0]) ? 0 : 1; return function j2(n, t, e) { let i = n, r = t, o = e; for (; o > r;) { if (o -= r, i = i.parent, !i) throw new Error("Invalid number of '../'"); r = i.segments.length } return new cp(i, !1, r - o) }(e.snapshot._urlSegment, e.snapshot._lastPathIndex + i, n.numberOfDoubleDots) }(o, t, n), a = s.processChildren ? Lc(s.segmentGroup, s.index, o.commands) : B1(s.segmentGroup, s.index, o.commands); return lp(s.segmentGroup, a, t, i, r) }(c, this.currentUrlTree, e, d, null != u ? u : null) } navigateByUrl(e, i = { skipLocationChange: !1 }) { const r = Or(e) ? e : this.parseUrl(e), o = this.urlHandlingStrategy.merge(r, this.rawUrlTree); return this.scheduleNavigation(o, "imperative", null, i) } navigate(e, i = { skipLocationChange: !1 }) { return function zB(n) { for (let t = 0; t < n.length; t++) { const e = n[t]; if (null == e) throw new Error(`The requested path contains ${e} segment at index ${t}`) } }(e), this.navigateByUrl(this.createUrlTree(e, i), i) } serializeUrl(e) { return this.urlSerializer.serialize(e) } parseUrl(e) { let i; try { i = this.urlSerializer.parse(e) } catch (r) { i = this.malformedUriErrorHandler(r, this.urlSerializer, e) } return i } isActive(e, i) { let r; if (r = !0 === i ? Object.assign({}, GB) : !1 === i ? Object.assign({}, WB) : i, Or(e)) return D1(this.currentUrlTree, e, r); const o = this.parseUrl(e); return D1(this.currentUrlTree, o, r) } removeEmptyProps(e) { return Object.keys(e).reduce((i, r) => { const o = e[r]; return null != o && (i[r] = o), i }, {}) } processNavigations() { this.navigations.subscribe(e => { this.navigated = !0, this.lastSuccessfulId = e.id, this.currentPageId = e.targetPageId, this.events.next(new ma(e.id, this.serializeUrl(e.extractedUrl), this.serializeUrl(this.currentUrlTree))), this.lastSuccessfulNavigation = this.currentNavigation, e.resolve(!0) }, e => { this.console.warn(`Unhandled Navigation Error: ${e}`) }) } scheduleNavigation(e, i, r, o, s) { var a, l, c; if (this.disposed) return Promise.resolve(!1); const u = this.transitions.value, d = Gc(i) && u && !Gc(u.source), h = u.rawUrl.toString() === e.toString(), f = u.id === (null === (a = this.currentNavigation) || void 0 === a ? void 0 : a.id); if (d && h && f) return Promise.resolve(!0); let _, y, b; s ? (_ = s.resolve, y = s.reject, b = s.promise) : b = new Promise((T, M) => { _ = T, y = M }); const m = ++this.navigationId; let C; return "computed" === this.canceledNavigationResolution ? (0 === this.currentPageId && (r = this.location.getState()), C = r && r.\u0275routerPageId ? r.\u0275routerPageId : o.replaceUrl || o.skipLocationChange ? null !== (l = this.browserPageId) && void 0 !== l ? l : 0 : (null !== (c = this.browserPageId) && void 0 !== c ? c : 0) + 1) : C = 0, this.setTransition({ id: m, targetPageId: C, source: i, restoredState: r, currentUrlTree: this.currentUrlTree, currentRawUrl: this.rawUrlTree, rawUrl: e, extras: o, resolve: _, reject: y, promise: b, currentSnapshot: this.routerState.snapshot, currentRouterState: this.routerState }), b.catch(T => Promise.reject(T)) } setBrowserUrl(e, i) { const r = this.urlSerializer.serialize(e), o = Object.assign(Object.assign({}, i.extras.state), this.generateNgRouterState(i.id, i.targetPageId)); this.location.isCurrentPathEqualTo(r) || i.extras.replaceUrl ? this.location.replaceState(r, "", o) : this.location.go(r, "", o) } restoreHistory(e, i = !1) { var r, o; if ("computed" === this.canceledNavigationResolution) { const s = this.currentPageId - e.targetPageId; "popstate" !== e.source && "eager" !== this.urlUpdateStrategy && this.currentUrlTree !== (null === (r = this.currentNavigation) || void 0 === r ? void 0 : r.finalUrl) || 0 === s ? this.currentUrlTree === (null === (o = this.currentNavigation) || void 0 === o ? void 0 : o.finalUrl) && 0 === s && (this.resetState(e), this.browserUrlTree = e.currentUrlTree, this.resetUrlToCurrentUrlTree()) : this.location.historyGo(s) } else "replace" === this.canceledNavigationResolution && (i && this.resetState(e), this.resetUrlToCurrentUrlTree()) } resetState(e) { this.routerState = e.currentRouterState, this.currentUrlTree = e.currentUrlTree, this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, e.rawUrl) } resetUrlToCurrentUrlTree() { this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree), "", this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId)) } cancelNavigationTransition(e, i) { const r = new h1(e.id, this.serializeUrl(e.extractedUrl), i); this.triggerEvent(r), e.resolve(!1) } generateNgRouterState(e, i) { return "computed" === this.canceledNavigationResolution ? { navigationId: e, \u0275routerPageId: i } : { navigationId: e } } } return n.\u0275fac = function(e) { jh() }, n.\u0275prov = R({ token: n, factory: n.\u0275fac }), n })(); function Gc(n) { return "imperative" !== n } let Ma = (() => { class n { constructor(e, i, r) { this.router = e, this.route = i, this.locationStrategy = r, this.commands = null, this.href = null, this.onChanges = new be, this.subscription = e.events.subscribe(o => { o instanceof ma && this.updateTargetUrlAndHref() }) } set routerLink(e) { this.commands = null != e ? Array.isArray(e) ? e : [e] : null } ngOnChanges(e) { this.updateTargetUrlAndHref(), this.onChanges.next(this) } ngOnDestroy() { this.subscription.unsubscribe() } onClick(e, i, r, o, s) { if (0 !== e || i || r || o || s || "string" == typeof this.target && "_self" != this.target || null === this.urlTree) return !0; const a = { skipLocationChange: ts(this.skipLocationChange), replaceUrl: ts(this.replaceUrl), state: this.state }; return this.router.navigateByUrl(this.urlTree, a), !1 } updateTargetUrlAndHref() { this.href = null !== this.urlTree ? this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.urlTree)) : null } get urlTree() { return null === this.commands ? null : this.router.createUrlTree(this.commands, { relativeTo: void 0 !== this.relativeTo ? this.relativeTo : this.route, queryParams: this.queryParams, fragment: this.fragment, queryParamsHandling: this.queryParamsHandling, preserveFragment: ts(this.preserveFragment) }) } } return n.\u0275fac = function(e) { return new (e || n)(g(Ot), g(Zi), g(Yo)) }, n.\u0275dir = S({ type: n, selectors: [["a", "routerLink", ""], ["area", "routerLink", ""]], hostVars: 2, hostBindings: function(e, i) { 1 & e && B("click", function(o) { return i.onClick(o.button, o.ctrlKey, o.shiftKey, o.altKey, o.metaKey) }), 2 & e && ve("target", i.target)("href", i.href, Wd) }, inputs: { target: "target", queryParams: "queryParams", fragment: "fragment", queryParamsHandling: "queryParamsHandling", preserveFragment: "preserveFragment", skipLocationChange: "skipLocationChange", replaceUrl: "replaceUrl", state: "state", relativeTo: "relativeTo", routerLink: "routerLink" }, features: [wt] }), n })(); function ts(n) { return "" === n || !!n } class rC { } class oC { preload(t, e) { return U(null) } } let sC = (() => { class n { constructor(e, i, r, o) { this.router = e, this.injector = r, this.preloadingStrategy = o, this.loader = new nC(r, i, l => e.triggerEvent(new f1(l)), l => e.triggerEvent(new p1(l))) } setUpPreloading() { this.subscription = this.router.events.pipe(jt(e => e instanceof ma), Jo(() => this.preload())).subscribe(() => { }) } preload() { const e = this.injector.get(Ti); return this.processRoutes(e, this.router.config) } ngOnDestroy() { this.subscription && this.subscription.unsubscribe() } processRoutes(e, i) { const r = []; for (const o of i) if (o.loadChildren && !o.canLoad && o._loadedConfig) { const s = o._loadedConfig; r.push(this.processRoutes(s.module, s.routes)) } else o.loadChildren && !o.canLoad ? r.push(this.preloadConfig(e, o)) : o.children && r.push(this.processRoutes(e, o.children)); return bt(r).pipe(Cs(), W(o => { })) } preloadConfig(e, i) { return this.preloadingStrategy.preload(i, () => (i._loadedConfig ? U(i._loadedConfig) : this.loader.load(e.injector, i)).pipe(it(o => (i._loadedConfig = o, this.processRoutes(o.module, o.routes))))) } } return n.\u0275fac = function(e) { return new (e || n)(E(Ot), E(dc), E(et), E(rC)) }, n.\u0275prov = R({ token: n, factory: n.\u0275fac }), n })(), yp = (() => { class n { constructor(e, i, r = {}) { this.router = e, this.viewportScroller = i, this.options = r, this.lastId = 0, this.lastSource = "imperative", this.restoredId = 0, this.store = {}, r.scrollPositionRestoration = r.scrollPositionRestoration || "disabled", r.anchorScrolling = r.anchorScrolling || "disabled" } init() { "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.setHistoryScrollRestoration("manual"), this.routerEventsSubscription = this.createScrollEvents(), this.scrollEventsSubscription = this.consumeScrollEvents() } createScrollEvents() { return this.router.events.subscribe(e => { e instanceof ep ? (this.store[this.lastId] = this.viewportScroller.getScrollPosition(), this.lastSource = e.navigationTrigger, this.restoredId = e.restoredState ? e.restoredState.navigationId : 0) : e instanceof ma && (this.lastId = e.id, this.scheduleScrollEvent(e, this.router.parseUrl(e.urlAfterRedirects).fragment)) }) } consumeScrollEvents() { return this.router.events.subscribe(e => { e instanceof g1 && (e.position ? "top" === this.options.scrollPositionRestoration ? this.viewportScroller.scrollToPosition([0, 0]) : "enabled" === this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition(e.position) : e.anchor && "enabled" === this.options.anchorScrolling ? this.viewportScroller.scrollToAnchor(e.anchor) : "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition([0, 0])) }) } scheduleScrollEvent(e, i) { this.router.triggerEvent(new g1(e, "popstate" === this.lastSource ? this.store[this.restoredId] : null, i)) } ngOnDestroy() { this.routerEventsSubscription && this.routerEventsSubscription.unsubscribe(), this.scrollEventsSubscription && this.scrollEventsSubscription.unsubscribe() } } return n.\u0275fac = function(e) { jh() }, n.\u0275prov = R({ token: n, factory: n.\u0275fac }), n })(); const xr = new P("ROUTER_CONFIGURATION"), aC = new P("ROUTER_FORROOT_GUARD"), QB = [Rf, { provide: T1, useClass: S1 }, { provide: Ot, useFactory: function tV(n, t, e, i, r, o, s = {}, a, l) { const c = new Ot(null, n, t, e, i, r, y1(o)); return a && (c.urlHandlingStrategy = a), l && (c.routeReuseStrategy = l), function nV(n, t) { n.errorHandler && (t.errorHandler = n.errorHandler), n.malformedUriErrorHandler && (t.malformedUriErrorHandler = n.malformedUriErrorHandler), n.onSameUrlNavigation && (t.onSameUrlNavigation = n.onSameUrlNavigation), n.paramsInheritanceStrategy && (t.paramsInheritanceStrategy = n.paramsInheritanceStrategy), n.relativeLinkResolution && (t.relativeLinkResolution = n.relativeLinkResolution), n.urlUpdateStrategy && (t.urlUpdateStrategy = n.urlUpdateStrategy), n.canceledNavigationResolution && (t.canceledNavigationResolution = n.canceledNavigationResolution) }(s, c), s.enableTracing && c.events.subscribe(u => { var d, h; null === (d = console.group) || void 0 === d || d.call(console, `Router Event: ${u.constructor.name}`), console.log(u.toString()), console.log(u), null === (h = console.groupEnd) || void 0 === h || h.call(console) }), c }, deps: [T1, wa, Rf, et, dc, _p, xr, [class HB { }, new rn], [class LB { }, new rn]] }, wa, { provide: Zi, useFactory: function iV(n) { return n.routerState.root }, deps: [Ot] }, sC, oC, class YB { preload(t, e) { return e().pipe(ai(() => U(null))) } }, { provide: xr, useValue: { enableTracing: !1 } }]; function JB() { return new eD("Router", Ot) } let bp = (() => { class n { constructor(e, i) { } static forRoot(e, i) { return { ngModule: n, providers: [QB, lC(e), { provide: aC, useFactory: eV, deps: [[Ot, new rn, new br]] }, { provide: xr, useValue: i || {} }, { provide: Yo, useFactory: XB, deps: [Nr, [new Vs(If), new rn], xr] }, { provide: yp, useFactory: ZB, deps: [Ot, sL, xr] }, { provide: rC, useExisting: i && i.preloadingStrategy ? i.preloadingStrategy : oC }, { provide: eD, multi: !0, useFactory: JB }, [vp, { provide: uc, multi: !0, useFactory: rV, deps: [vp] }, { provide: cC, useFactory: oV, deps: [vp] }, { provide: K0, multi: !0, useExisting: cC }]] } } static forChild(e) { return { ngModule: n, providers: [lC(e)] } } } return n.\u0275fac = function(e) { return new (e || n)(E(aC, 8), E(Ot, 8)) }, n.\u0275mod = se({ type: n }), n.\u0275inj = te({}), n })(); function ZB(n, t, e) { return e.scrollOffset && t.setOffset(e.scrollOffset), new yp(n, t, e) } function XB(n, t, e = {}) { return e.useHash ? new Gk(n, t) : new CD(n, t) } function eV(n) { return "guarded" } function lC(n) { return [{ provide: wM, multi: !0, useValue: n }, { provide: _p, multi: !0, useValue: n }] } let vp = (() => { class n { constructor(e) { this.injector = e, this.initNavigation = !1, this.destroyed = !1, this.resultOfPreactivationDone = new be } appInitializer() { return this.injector.get(jk, Promise.resolve(null)).then(() => { if (this.destroyed) return Promise.resolve(!0); let i = null; const r = new Promise(a => i = a), o = this.injector.get(Ot), s = this.injector.get(xr); return "disabled" === s.initialNavigation ? (o.setUpLocationChangeListener(), i(!0)) : "enabled" === s.initialNavigation || "enabledBlocking" === s.initialNavigation ? (o.hooks.afterPreactivation = () => this.initNavigation ? U(null) : (this.initNavigation = !0, i(!0), this.resultOfPreactivationDone), o.initialNavigation()) : i(!0), r }) } bootstrapListener(e) { const i = this.injector.get(xr), r = this.injector.get(sC), o = this.injector.get(yp), s = this.injector.get(Ot), a = this.injector.get(Ko); e === a.components[0] && (("enabledNonBlocking" === i.initialNavigation || void 0 === i.initialNavigation) && s.initialNavigation(), r.setUpPreloading(), o.init(), s.resetRootComponentType(a.componentTypes[0]), this.resultOfPreactivationDone.next(null), this.resultOfPreactivationDone.complete()) } ngOnDestroy() { this.destroyed = !0 } } return n.\u0275fac = function(e) { return new (e || n)(E(et)) }, n.\u0275prov = R({ token: n, factory: n.\u0275fac }), n })(); function rV(n) { return n.appInitializer.bind(n) } function oV(n) { return n.bootstrapListener.bind(n) } const cC = new P("Router Initializer"); class uC { } class dC { } class xt { constructor(t) { this.normalizedNames = new Map, this.lazyUpdate = null, t ? this.lazyInit = "string" == typeof t ? () => { this.headers = new Map, t.split("\n").forEach(e => { const i = e.indexOf(":"); if (i > 0) { const r = e.slice(0, i), o = r.toLowerCase(), s = e.slice(i + 1).trim(); this.maybeSetNormalizedName(r, o), this.headers.has(o) ? this.headers.get(o).push(s) : this.headers.set(o, [s]) } }) } : () => { this.headers = new Map, Object.keys(t).forEach(e => { let i = t[e]; const r = e.toLowerCase(); "string" == typeof i && (i = [i]), i.length > 0 && (this.headers.set(r, i), this.maybeSetNormalizedName(e, r)) }) } : this.headers = new Map } has(t) { return this.init(), this.headers.has(t.toLowerCase()) } get(t) { this.init(); const e = this.headers.get(t.toLowerCase()); return e && e.length > 0 ? e[0] : null } keys() { return this.init(), Array.from(this.normalizedNames.values()) } getAll(t) { return this.init(), this.headers.get(t.toLowerCase()) || null } append(t, e) { return this.clone({ name: t, value: e, op: "a" }) } set(t, e) { return this.clone({ name: t, value: e, op: "s" }) } delete(t, e) { return this.clone({ name: t, value: e, op: "d" }) } maybeSetNormalizedName(t, e) { this.normalizedNames.has(e) || this.normalizedNames.set(e, t) } init() { this.lazyInit && (this.lazyInit instanceof xt ? this.copyFrom(this.lazyInit) : this.lazyInit(), this.lazyInit = null, this.lazyUpdate && (this.lazyUpdate.forEach(t => this.applyUpdate(t)), this.lazyUpdate = null)) } copyFrom(t) { t.init(), Array.from(t.headers.keys()).forEach(e => { this.headers.set(e, t.headers.get(e)), this.normalizedNames.set(e, t.normalizedNames.get(e)) }) } clone(t) { const e = new xt; return e.lazyInit = this.lazyInit && this.lazyInit instanceof xt ? this.lazyInit : this, e.lazyUpdate = (this.lazyUpdate || []).concat([t]), e } applyUpdate(t) { const e = t.name.toLowerCase(); switch (t.op) { case "a": case "s": let i = t.value; if ("string" == typeof i && (i = [i]), 0 === i.length) return; this.maybeSetNormalizedName(t.name, e); const r = ("a" === t.op ? this.headers.get(e) : void 0) || []; r.push(...i), this.headers.set(e, r); break; case "d": const o = t.value; if (o) { let s = this.headers.get(e); if (!s) return; s = s.filter(a => -1 === o.indexOf(a)), 0 === s.length ? (this.headers.delete(e), this.normalizedNames.delete(e)) : this.headers.set(e, s) } else this.headers.delete(e), this.normalizedNames.delete(e) } } forEach(t) { this.init(), Array.from(this.normalizedNames.keys()).forEach(e => t(this.normalizedNames.get(e), this.headers.get(e))) } } class aV { encodeKey(t) { return hC(t) } encodeValue(t) { return hC(t) } decodeKey(t) { return decodeURIComponent(t) } decodeValue(t) { return decodeURIComponent(t) } } const cV = /%(\d[a-f0-9])/gi, uV = { 40: "@", "3A": ":", 24: "$", "2C": ",", "3B": ";", "2B": "+", "3D": "=", "3F": "?", "2F": "/" }; function hC(n) { return encodeURIComponent(n).replace(cV, (t, e) => { var i; return null !== (i = uV[e]) && void 0 !== i ? i : t }) } function fC(n) { return `${n}` } class er { constructor(t = {}) { if (this.updates = null, this.cloneFrom = null, this.encoder = t.encoder || new aV, t.fromString) { if (t.fromObject) throw new Error("Cannot specify both fromString and fromObject."); this.map = function lV(n, t) { const e = new Map; return n.length > 0 && n.replace(/^\?/, "").split("&").forEach(r => { const o = r.indexOf("="), [s, a] = -1 == o ? [t.decodeKey(r), ""] : [t.decodeKey(r.slice(0, o)), t.decodeValue(r.slice(o + 1))], l = e.get(s) || []; l.push(a), e.set(s, l) }), e }(t.fromString, this.encoder) } else t.fromObject ? (this.map = new Map, Object.keys(t.fromObject).forEach(e => { const i = t.fromObject[e]; this.map.set(e, Array.isArray(i) ? i : [i]) })) : this.map = null } has(t) { return this.init(), this.map.has(t) } get(t) { this.init(); const e = this.map.get(t); return e ? e[0] : null } getAll(t) { return this.init(), this.map.get(t) || null } keys() { return this.init(), Array.from(this.map.keys()) } append(t, e) { return this.clone({ param: t, value: e, op: "a" }) } appendAll(t) { const e = []; return Object.keys(t).forEach(i => { const r = t[i]; Array.isArray(r) ? r.forEach(o => { e.push({ param: i, value: o, op: "a" }) }) : e.push({ param: i, value: r, op: "a" }) }), this.clone(e) } set(t, e) { return this.clone({ param: t, value: e, op: "s" }) } delete(t, e) { return this.clone({ param: t, value: e, op: "d" }) } toString() { return this.init(), this.keys().map(t => { const e = this.encoder.encodeKey(t); return this.map.get(t).map(i => e + "=" + this.encoder.encodeValue(i)).join("&") }).filter(t => "" !== t).join("&") } clone(t) { const e = new er({ encoder: this.encoder }); return e.cloneFrom = this.cloneFrom || this, e.updates = (this.updates || []).concat(t), e } init() { null === this.map && (this.map = new Map), null !== this.cloneFrom && (this.cloneFrom.init(), this.cloneFrom.keys().forEach(t => this.map.set(t, this.cloneFrom.map.get(t))), this.updates.forEach(t => { switch (t.op) { case "a": case "s": const e = ("a" === t.op ? this.map.get(t.param) : void 0) || []; e.push(fC(t.value)), this.map.set(t.param, e); break; case "d": if (void 0 === t.value) { this.map.delete(t.param); break } { let i = this.map.get(t.param) || []; const r = i.indexOf(fC(t.value)); -1 !== r && i.splice(r, 1), i.length > 0 ? this.map.set(t.param, i) : this.map.delete(t.param) } } }), this.cloneFrom = this.updates = null) } } class dV { constructor() { this.map = new Map } set(t, e) { return this.map.set(t, e), this } get(t) { return this.map.has(t) || this.map.set(t, t.defaultValue()), this.map.get(t) } delete(t) { return this.map.delete(t), this } has(t) { return this.map.has(t) } keys() { return this.map.keys() } } function pC(n) { return "undefined" != typeof ArrayBuffer && n instanceof ArrayBuffer } function gC(n) { return "undefined" != typeof Blob && n instanceof Blob } function _C(n) { return "undefined" != typeof FormData && n instanceof FormData } class Na { constructor(t, e, i, r) { let o; if (this.url = e, this.body = null, this.reportProgress = !1, this.withCredentials = !1, this.responseType = "json", this.method = t.toUpperCase(), function hV(n) { switch (n) { case "DELETE": case "GET": case "HEAD": case "OPTIONS": case "JSONP": return !1; default: return !0 } }(this.method) || r ? (this.body = void 0 !== i ? i : null, o = r) : o = i, o && (this.reportProgress = !!o.reportProgress, this.withCredentials = !!o.withCredentials, o.responseType && (this.responseType = o.responseType), o.headers && (this.headers = o.headers), o.context && (this.context = o.context), o.params && (this.params = o.params)), this.headers || (this.headers = new xt), this.context || (this.context = new dV), this.params) { const s = this.params.toString(); if (0 === s.length) this.urlWithParams = e; else { const a = e.indexOf("?"); this.urlWithParams = e + (-1 === a ? "?" : a < e.length - 1 ? "&" : "") + s } } else this.params = new er, this.urlWithParams = e } serializeBody() { return null === this.body ? null : pC(this.body) || gC(this.body) || _C(this.body) || function fV(n) { return "undefined" != typeof URLSearchParams && n instanceof URLSearchParams }(this.body) || "string" == typeof this.body ? this.body : this.body instanceof er ? this.body.toString() : "object" == typeof this.body || "boolean" == typeof this.body || Array.isArray(this.body) ? JSON.stringify(this.body) : this.body.toString() } detectContentTypeHeader() { return null === this.body || _C(this.body) ? null : gC(this.body) ? this.body.type || null : pC(this.body) ? null : "string" == typeof this.body ? "text/plain" : this.body instanceof er ? "application/x-www-form-urlencoded;charset=UTF-8" : "object" == typeof this.body || "number" == typeof this.body || "boolean" == typeof this.body ? "application/json" : null } clone(t = {}) { var e; const i = t.method || this.method, r = t.url || this.url, o = t.responseType || this.responseType, s = void 0 !== t.body ? t.body : this.body, a = void 0 !== t.withCredentials ? t.withCredentials : this.withCredentials, l = void 0 !== t.reportProgress ? t.reportProgress : this.reportProgress; let c = t.headers || this.headers, u = t.params || this.params; const d = null !== (e = t.context) && void 0 !== e ? e : this.context; return void 0 !== t.setHeaders && (c = Object.keys(t.setHeaders).reduce((h, f) => h.set(f, t.setHeaders[f]), c)), t.setParams && (u = Object.keys(t.setParams).reduce((h, f) => h.set(f, t.setParams[f]), u)), new Na(i, r, s, { params: u, headers: c, context: d, reportProgress: l, responseType: o, withCredentials: a }) } } var at = (() => ((at = at || {})[at.Sent = 0] = "Sent", at[at.UploadProgress = 1] = "UploadProgress", at[at.ResponseHeader = 2] = "ResponseHeader", at[at.DownloadProgress = 3] = "DownloadProgress", at[at.Response = 4] = "Response", at[at.User = 5] = "User", at))(); class Dp { constructor(t, e = 200, i = "OK") { this.headers = t.headers || new xt, this.status = void 0 !== t.status ? t.status : e, this.statusText = t.statusText || i, this.url = t.url || null, this.ok = this.status >= 200 && this.status < 300 } } class Cp extends Dp { constructor(t = {}) { super(t), this.type = at.ResponseHeader } clone(t = {}) { return new Cp({ headers: t.headers || this.headers, status: void 0 !== t.status ? t.status : this.status, statusText: t.statusText || this.statusText, url: t.url || this.url || void 0 }) } } class Wc extends Dp { constructor(t = {}) { super(t), this.type = at.Response, this.body = void 0 !== t.body ? t.body : null } clone(t = {}) { return new Wc({ body: void 0 !== t.body ? t.body : this.body, headers: t.headers || this.headers, status: void 0 !== t.status ? t.status : this.status, statusText: t.statusText || this.statusText, url: t.url || this.url || void 0 }) } } class Ep extends Dp { constructor(t) { super(t, 0, "Unknown Error"), this.name = "HttpErrorResponse", this.ok = !1, this.message = this.status >= 200 && this.status < 300 ? `Http failure during parsing for ${t.url || "(unknown url)"}` : `Http failure response for ${t.url || "(unknown url)"}: ${t.status} ${t.statusText}`, this.error = t.error || null } } function wp(n, t) { return { body: t, headers: n.headers, context: n.context, observe: n.observe, params: n.params, reportProgress: n.reportProgress, responseType: n.responseType, withCredentials: n.withCredentials } } let ns = (() => { class n { constructor(e) { this.handler = e } request(e, i, r = {}) { let o; if (e instanceof Na) o = e; else { let l, c; l = r.headers instanceof xt ? r.headers : new xt(r.headers), r.params && (c = r.params instanceof er ? r.params : new er({ fromObject: r.params })), o = new Na(e, i, void 0 !== r.body ? r.body : null, { headers: l, context: r.context, params: c, reportProgress: r.reportProgress, responseType: r.responseType || "json", withCredentials: r.withCredentials }) } const s = U(o).pipe(Jo(l => this.handler.handle(l))); if (e instanceof Na || "events" === r.observe) return s; const a = s.pipe(jt(l => l instanceof Wc)); switch (r.observe || "body") { case "body": switch (o.responseType) { case "arraybuffer": return a.pipe(W(l => { if (null !== l.body && !(l.body instanceof ArrayBuffer)) throw new Error("Response is not an ArrayBuffer."); return l.body })); case "blob": return a.pipe(W(l => { if (null !== l.body && !(l.body instanceof Blob)) throw new Error("Response is not a Blob."); return l.body })); case "text": return a.pipe(W(l => { if (null !== l.body && "string" != typeof l.body) throw new Error("Response is not a string."); return l.body })); default: return a.pipe(W(l => l.body)) }case "response": return a; default: throw new Error(`Unreachable: unhandled observe type ${r.observe}}`) } } delete(e, i = {}) { return this.request("DELETE", e, i) } get(e, i = {}) { return this.request("GET", e, i) } head(e, i = {}) { return this.request("HEAD", e, i) } jsonp(e, i) { return this.request("JSONP", e, { params: (new er).append(i, "JSONP_CALLBACK"), observe: "body", responseType: "json" }) } options(e, i = {}) { return this.request("OPTIONS", e, i) } patch(e, i, r = {}) { return this.request("PATCH", e, wp(r, i)) } post(e, i, r = {}) { return this.request("POST", e, wp(r, i)) } put(e, i, r = {}) { return this.request("PUT", e, wp(r, i)) } } return n.\u0275fac = function(e) { return new (e || n)(E(uC)) }, n.\u0275prov = R({ token: n, factory: n.\u0275fac }), n })(); class mC { constructor(t, e) { this.next = t, this.interceptor = e } handle(t) { return this.interceptor.intercept(t, this.next) } } const Tp = new P("HTTP_INTERCEPTORS"); let pV = (() => { class n { intercept(e, i) { return i.handle(e) } } return n.\u0275fac = function(e) { return new (e || n) }, n.\u0275prov = R({ token: n, factory: n.\u0275fac }), n })(); const gV = /^\)\]\}',?\n/; let yC = (() => { class n { constructor(e) { this.xhrFactory = e } handle(e) { if ("JSONP" === e.method) throw new Error("Attempted to construct Jsonp request without HttpClientJsonpModule installed."); return new Ce(i => { const r = this.xhrFactory.build(); if (r.open(e.method, e.urlWithParams), e.withCredentials && (r.withCredentials = !0), e.headers.forEach((f, p) => r.setRequestHeader(f, p.join(","))), e.headers.has("Accept") || r.setRequestHeader("Accept", "application/json, text/plain, */*"), !e.headers.has("Content-Type")) { const f = e.detectContentTypeHeader(); null !== f && r.setRequestHeader("Content-Type", f) } if (e.responseType) { const f = e.responseType.toLowerCase(); r.responseType = "json" !== f ? f : "text" } const o = e.serializeBody(); let s = null; const a = () => { if (null !== s) return s; const f = 1223 === r.status ? 204 : r.status, p = r.statusText || "OK", _ = new xt(r.getAllResponseHeaders()), y = function _V(n) { return "responseURL" in n && n.responseURL ? n.responseURL : /^X-Request-URL:/m.test(n.getAllResponseHeaders()) ? n.getResponseHeader("X-Request-URL") : null }(r) || e.url; return s = new Cp({ headers: _, status: f, statusText: p, url: y }), s }, l = () => { let { headers: f, status: p, statusText: _, url: y } = a(), b = null; 204 !== p && (b = void 0 === r.response ? r.responseText : r.response), 0 === p && (p = b ? 200 : 0); let m = p >= 200 && p < 300; if ("json" === e.responseType && "string" == typeof b) { const C = b; b = b.replace(gV, ""); try { b = "" !== b ? JSON.parse(b) : null } catch (T) { b = C, m && (m = !1, b = { error: T, text: b }) } } m ? (i.next(new Wc({ body: b, headers: f, status: p, statusText: _, url: y || void 0 })), i.complete()) : i.error(new Ep({ error: b, headers: f, status: p, statusText: _, url: y || void 0 })) }, c = f => { const { url: p } = a(), _ = new Ep({ error: f, status: r.status || 0, statusText: r.statusText || "Unknown Error", url: p || void 0 }); i.error(_) }; let u = !1; const d = f => { u || (i.next(a()), u = !0); let p = { type: at.DownloadProgress, loaded: f.loaded }; f.lengthComputable && (p.total = f.total), "text" === e.responseType && !!r.responseText && (p.partialText = r.responseText), i.next(p) }, h = f => { let p = { type: at.UploadProgress, loaded: f.loaded }; f.lengthComputable && (p.total = f.total), i.next(p) }; return r.addEventListener("load", l), r.addEventListener("error", c), r.addEventListener("timeout", c), r.addEventListener("abort", c), e.reportProgress && (r.addEventListener("progress", d), null !== o && r.upload && r.upload.addEventListener("progress", h)), r.send(o), i.next({ type: at.Sent }), () => { r.removeEventListener("error", c), r.removeEventListener("abort", c), r.removeEventListener("load", l), r.removeEventListener("timeout", c), e.reportProgress && (r.removeEventListener("progress", d), null !== o && r.upload && r.upload.removeEventListener("progress", h)), r.readyState !== r.DONE && r.abort() } }) } } return n.\u0275fac = function(e) { return new (e || n)(E(jD)) }, n.\u0275prov = R({ token: n, factory: n.\u0275fac }), n })(); const Sp = new P("XSRF_COOKIE_NAME"), Ap = new P("XSRF_HEADER_NAME"); class bC { } let mV = (() => { class n { constructor(e, i, r) { this.doc = e, this.platform = i, this.cookieName = r, this.lastCookieString = "", this.lastToken = null, this.parseCount = 0 } getToken() { if ("server" === this.platform) return null; const e = this.doc.cookie || ""; return e !== this.lastCookieString && (this.parseCount++, this.lastToken = OD(e, this.cookieName), this.lastCookieString = e), this.lastToken } } return n.\u0275fac = function(e) { return new (e || n)(E(De), E(zo), E(Sp)) }, n.\u0275prov = R({ token: n, factory: n.\u0275fac }), n })(), Mp = (() => { class n { constructor(e, i) { this.tokenService = e, this.headerName = i } intercept(e, i) { const r = e.url.toLowerCase(); if ("GET" === e.method || "HEAD" === e.method || r.startsWith("http://") || r.startsWith("https://")) return i.handle(e); const o = this.tokenService.getToken(); return null !== o && !e.headers.has(this.headerName) && (e = e.clone({ headers: e.headers.set(this.headerName, o) })), i.handle(e) } } return n.\u0275fac = function(e) { return new (e || n)(E(bC), E(Ap)) }, n.\u0275prov = R({ token: n, factory: n.\u0275fac }), n })(), yV = (() => { class n { constructor(e, i) { this.backend = e, this.injector = i, this.chain = null } handle(e) { if (null === this.chain) { const i = this.injector.get(Tp, []); this.chain = i.reduceRight((r, o) => new mC(r, o), this.backend) } return this.chain.handle(e) } } return n.\u0275fac = function(e) { return new (e || n)(E(dC), E(et)) }, n.\u0275prov = R({ token: n, factory: n.\u0275fac }), n })(), bV = (() => { class n { static disable() { return { ngModule: n, providers: [{ provide: Mp, useClass: pV }] } } static withOptions(e = {}) { return { ngModule: n, providers: [e.cookieName ? { provide: Sp, useValue: e.cookieName } : [], e.headerName ? { provide: Ap, useValue: e.headerName } : []] } } } return n.\u0275fac = function(e) { return new (e || n) }, n.\u0275mod = se({ type: n }), n.\u0275inj = te({ providers: [Mp, { provide: Tp, useExisting: Mp, multi: !0 }, { provide: bC, useClass: mV }, { provide: Sp, useValue: "XSRF-TOKEN" }, { provide: Ap, useValue: "X-XSRF-TOKEN" }] }), n })(), vV = (() => { class n { } return n.\u0275fac = function(e) { return new (e || n) }, n.\u0275mod = se({ type: n }), n.\u0275inj = te({ providers: [ns, { provide: uC, useClass: yV }, yC, { provide: dC, useExisting: yC }], imports: [[bV.withOptions({ cookieName: "XSRF-TOKEN", headerName: "X-XSRF-TOKEN" })]] }), n })(), zc = (() => { class n { constructor(e, i) { this.router = e, this.http = i, this.baseUrl = "https://lampp.herokuapp.com/api/auth" } login(e) { return this.http.post(this.baseUrl + "/login", e, { headers: new xt({ "Content-Type": "application/json" }) }).pipe(W(i => (sessionStorage.setItem("user", e.username), sessionStorage.setItem("token", "Bearer " + i.jwt), i))) } register(e) { return this.http.post(this.baseUrl + "/register", e, { headers: new xt({ "Content-Type": "application/json" }), responseType: "text" }).pipe(W(i => "User successfully registered")) } logout() { sessionStorage.removeItem("user"), sessionStorage.removeItem("token"), this.router.navigateByUrl("login") } isUserLoggedIn() { return null !== sessionStorage.getItem("token") } getLoggedInUser() { return sessionStorage.getItem("user") } getToken() { return sessionStorage.getItem("token") } } return n.\u0275fac = function(e) { return new (e || n)(E(Ot), E(ns)) }, n.\u0275prov = R({ token: n, factory: n.\u0275fac, providedIn: "root" }), n })(); const DV = ["addListener", "removeListener"], CV = ["addEventListener", "removeEventListener"], EV = ["on", "off"]; function Ct(n, t, e, i) { if (ye(e) && (i = e, e = void 0), i) return Ct(n, t, e).pipe(Jf(i)); const [r, o] = function SV(n) { return ye(n.addEventListener) && ye(n.removeEventListener) }(n) ? CV.map(s => a => n[s](t, a, e)) : function wV(n) { return ye(n.addListener) && ye(n.removeListener) }(n) ? DV.map(vC(n, t)) : function TV(n) { return ye(n.on) && ye(n.off) }(n) ? EV.map(vC(n, t)) : []; if (!r && Zu(n)) return it(s => Ct(s, t, e))(Et(n)); if (!r) throw new TypeError("Invalid event target"); return new Ce(s => { const a = (...l) => s.next(1 < l.length ? l : l[0]); return r(a), () => o(a) }) } function vC(n, t) { return e => i => n[e](t, i) } class AV extends Ze { constructor(t, e) { super() } schedule(t, e = 0) { return this } } const Kc = { setInterval(...n) { const { delegate: t } = Kc; return ((null == t ? void 0 : t.setInterval) || setInterval)(...n) }, clearInterval(n) { const { delegate: t } = Kc; return ((null == t ? void 0 : t.clearInterval) || clearInterval)(n) }, delegate: void 0 }; class Np extends AV { constructor(t, e) { super(t, e), this.scheduler = t, this.work = e, this.pending = !1 } schedule(t, e = 0) { if (this.closed) return this; this.state = t; const i = this.id, r = this.scheduler; return null != i && (this.id = this.recycleAsyncId(r, i, e)), this.pending = !0, this.delay = e, this.id = this.id || this.requestAsyncId(r, this.id, e), this } requestAsyncId(t, e, i = 0) { return Kc.setInterval(t.flush.bind(t, this), i) } recycleAsyncId(t, e, i = 0) { if (null != i && this.delay === i && !1 === this.pending) return e; Kc.clearInterval(e) } execute(t, e) { if (this.closed) return new Error("executing a cancelled action"); this.pending = !1; const i = this._execute(t, e); if (i) return i; !1 === this.pending && null != this.id && (this.id = this.recycleAsyncId(this.scheduler, this.id, null)) } _execute(t, e) { let r, i = !1; try { this.work(t) } catch (o) { i = !0, r = o || new Error("Scheduled action threw falsy error") } if (i) return this.unsubscribe(), r } unsubscribe() { if (!this.closed) { const { id: t, scheduler: e } = this, { actions: i } = e; this.work = this.state = this.scheduler = null, this.pending = !1, Jr(i, this), null != t && (this.id = this.recycleAsyncId(e, t, null)), this.delay = null, super.unsubscribe() } } } const DC = { now: () => (DC.delegate || Date).now(), delegate: void 0 }; class Ia { constructor(t, e = Ia.now) { this.schedulerActionCtor = t, this.now = e } schedule(t, e = 0, i) { return new this.schedulerActionCtor(this, t).schedule(i, e) } } Ia.now = DC.now; class Ip extends Ia { constructor(t, e = Ia.now) { super(t, e), this.actions = [], this._active = !1, this._scheduled = void 0 } flush(t) { const { actions: e } = this; if (this._active) return void e.push(t); let i; this._active = !0; do { if (i = t.execute(t.state, t.delay)) break } while (t = e.shift()); if (this._active = !1, i) { for (; t = e.shift();)t.unsubscribe(); throw i } } } const Rp = new Ip(Np), CC = Rp; function Ra(n = 0, t, e = CC) { let i = -1; return null != t && (x_(t) ? e = t : i = t), new Ce(r => { let o = function MV(n) { return n instanceof Date && !isNaN(n) }(n) ? +n - e.now() : n; o < 0 && (o = 0); let s = 0; return e.schedule(function() { r.closed || (r.next(s++), 0 <= i ? this.schedule(void 0, i) : r.complete()) }, o) }) } const { isArray: NV } = Array; function EC(n) { return 1 === n.length && NV(n[0]) ? n[0] : n } function qc(...n) { const t = cl(n), e = EC(n); return e.length ? new Ce(i => { let r = e.map(() => []), o = e.map(() => !1); i.add(() => { r = o = null }); for (let s = 0; !i.closed && s < e.length; s++)Et(e[s]).subscribe(new Ie(i, a => { if (r[s].push(a), r.every(l => l.length)) { const l = r.map(c => c.shift()); i.next(t ? t(...l) : l), r.some((c, u) => !c.length && o[u]) && i.complete() } }, () => { o[s] = !0, !r[s].length && i.complete() })); return () => { r = o = null } }) : Mn } function Le(n) { return Ge((t, e) => { Et(n).subscribe(new Ie(e, () => e.complete(), Bi)), !e.closed && t.subscribe(e) }) } function Oa(n, t = gi) { return n = null != n ? n : OV, Ge((e, i) => { let r, o = !0; e.subscribe(new Ie(i, s => { const a = t(s); (o || !n(r, a)) && (o = !1, r = a, i.next(s)) })) }) } function OV(n, t) { return n === t } function Op(...n) { const t = cl(n); return Ge((e, i) => { const r = n.length, o = new Array(r); let s = n.map(() => !1), a = !1; for (let l = 0; l < r; l++)Et(n[l]).subscribe(new Ie(i, c => { o[l] = c, !a && !s[l] && (s[l] = !0, (a = s.every(gi)) && (s = null)) }, Bi)); e.subscribe(new Ie(i, l => { if (a) { const c = [l, ...o]; i.next(t ? t(...c) : c) } })) }) } function MC(...n) { const t = cl(n), { args: e, keys: i } = n1(n), r = new Ce(o => { const { length: s } = e; if (!s) return void o.complete(); const a = new Array(s); let l = s, c = s; for (let u = 0; u < s; u++) { let d = !1; Et(e[u]).subscribe(new Ie(o, h => { d || (d = !0, c--), a[u] = h }, () => l--, void 0, () => { (!l || !d) && (c || o.next(i ? r1(i, a) : a), o.complete()) })) } }); return t ? r.pipe(Jf(t)) : r } new Ce(Bi); let NC = (() => { class n { constructor(e, i) { this._renderer = e, this._elementRef = i, this.onChange = r => { }, this.onTouched = () => { } } setProperty(e, i) { this._renderer.setProperty(this._elementRef.nativeElement, e, i) } registerOnTouched(e) { this.onTouched = e } registerOnChange(e) { this.onChange = e } setDisabledState(e) { this.setProperty("disabled", e) } } return n.\u0275fac = function(e) { return new (e || n)(g(Hn), g(X)) }, n.\u0275dir = S({ type: n }), n })(), Pr = (() => { class n extends NC { } return n.\u0275fac = function() { let t; return function(i) { return (t || (t = function Kt(n) { return Hi(() => { const t = n.prototype.constructor, e = t[yi] || Id(t), i = Object.prototype; let r = Object.getPrototypeOf(n.prototype).constructor; for (; r && r !== i;) { const o = r[yi] || Id(r); if (o && o !== e) return o; r = Object.getPrototypeOf(r) } return o => new o }) }(n)))(i || n) } }(), n.\u0275dir = S({ type: n, features: [ie] }), n })(); const vn = new P("NgValueAccessor"), LV = { provide: vn, useExisting: ge(() => is), multi: !0 }, VV = new P("CompositionEventMode"); let is = (() => { class n extends NC { constructor(e, i, r) { super(e, i), this._compositionMode = r, this._composing = !1, null == this._compositionMode && (this._compositionMode = !function BV() { const n = si() ? si().getUserAgent() : ""; return /android (\d+)/.test(n.toLowerCase()) }()) } writeValue(e) { this.setProperty("value", null == e ? "" : e) } _handleInput(e) { (!this._compositionMode || this._compositionMode && !this._composing) && this.onChange(e) } _compositionStart() { this._composing = !0 } _compositionEnd(e) { this._composing = !1, this._compositionMode && this.onChange(e) } } return n.\u0275fac = function(e) { return new (e || n)(g(Hn), g(X), g(VV, 8)) }, n.\u0275dir = S({ type: n, selectors: [["input", "formControlName", "", 3, "type", "checkbox"], ["textarea", "formControlName", ""], ["input", "formControl", "", 3, "type", "checkbox"], ["textarea", "formControl", ""], ["input", "ngModel", "", 3, "type", "checkbox"], ["textarea", "ngModel", ""], ["", "ngDefaultControl", ""]], hostBindings: function(e, i) { 1 & e && B("input", function(o) { return i._handleInput(o.target.value) })("blur", function() { return i.onTouched() })("compositionstart", function() { return i._compositionStart() })("compositionend", function(o) { return i._compositionEnd(o.target.value) }) }, features: [Se([LV]), ie] }), n })(); const Pt = new P("NgValidators"), nr = new P("NgAsyncValidators"); function HC(n) { return null != n } function jC(n) { const t = Zs(n) ? bt(n) : n; return $h(t), t } function UC(n) { let t = {}; return n.forEach(e => { t = null != e ? Object.assign(Object.assign({}, t), e) : t }), 0 === Object.keys(t).length ? null : t } function $C(n, t) { return t.map(e => e(n)) } function GC(n) { return n.map(t => function jV(n) { return !n.validate }(t) ? t : e => t.validate(e)) } function xp(n) { return null != n ? function WC(n) { if (!n) return null; const t = n.filter(HC); return 0 == t.length ? null : function(e) { return UC($C(e, t)) } }(GC(n)) : null } function Pp(n) { return null != n ? function zC(n) { if (!n) return null; const t = n.filter(HC); return 0 == t.length ? null : function(e) { return MC($C(e, t).map(jC)).pipe(W(UC)) } }(GC(n)) : null } function KC(n, t) { return null === n ? [t] : Array.isArray(n) ? [...n, t] : [n, t] } function kp(n) { return n ? Array.isArray(n) ? n : [n] : [] } function Yc(n, t) { return Array.isArray(n) ? n.includes(t) : n === t } function QC(n, t) { const e = kp(t); return kp(n).forEach(r => { Yc(e, r) || e.push(r) }), e } function JC(n, t) { return kp(t).filter(e => !Yc(n, e)) } class ZC { constructor() { this._rawValidators = [], this._rawAsyncValidators = [], this._onDestroyCallbacks = [] } get value() { return this.control ? this.control.value : null } get valid() { return this.control ? this.control.valid : null } get invalid() { return this.control ? this.control.invalid : null } get pending() { return this.control ? this.control.pending : null } get disabled() { return this.control ? this.control.disabled : null } get enabled() { return this.control ? this.control.enabled : null } get errors() { return this.control ? this.control.errors : null } get pristine() { return this.control ? this.control.pristine : null } get dirty() { return this.control ? this.control.dirty : null } get touched() { return this.control ? this.control.touched : null } get status() { return this.control ? this.control.status : null } get untouched() { return this.control ? this.control.untouched : null } get statusChanges() { return this.control ? this.control.statusChanges : null } get valueChanges() { return this.control ? this.control.valueChanges : null } get path() { return null } _setValidators(t) { this._rawValidators = t || [], this._composedValidatorFn = xp(this._rawValidators) } _setAsyncValidators(t) { this._rawAsyncValidators = t || [], this._composedAsyncValidatorFn = Pp(this._rawAsyncValidators) } get validator() { return this._composedValidatorFn || null } get asyncValidator() { return this._composedAsyncValidatorFn || null } _registerOnDestroy(t) { this._onDestroyCallbacks.push(t) } _invokeOnDestroyCallbacks() { this._onDestroyCallbacks.forEach(t => t()), this._onDestroyCallbacks = [] } reset(t) { this.control && this.control.reset(t) } hasError(t, e) { return !!this.control && this.control.hasError(t, e) } getError(t, e) { return this.control ? this.control.getError(t, e) : null } } class ir extends ZC { constructor() { super(...arguments), this._parent = null, this.name = null, this.valueAccessor = null } } class Ut extends ZC { get formDirective() { return null } get path() { return null } } class XC { constructor(t) { this._cd = t } is(t) { var e, i, r; return "submitted" === t ? !!(null === (e = this._cd) || void 0 === e ? void 0 : e.submitted) : !!(null === (r = null === (i = this._cd) || void 0 === i ? void 0 : i.control) || void 0 === r ? void 0 : r[t]) } } let Qc = (() => { class n extends XC { constructor(e) { super(e) } } return n.\u0275fac = function(e) { return new (e || n)(g(ir, 2)) }, n.\u0275dir = S({ type: n, selectors: [["", "formControlName", ""], ["", "ngModel", ""], ["", "formControl", ""]], hostVars: 14, hostBindings: function(e, i) { 2 & e && de("ng-untouched", i.is("untouched"))("ng-touched", i.is("touched"))("ng-pristine", i.is("pristine"))("ng-dirty", i.is("dirty"))("ng-valid", i.is("valid"))("ng-invalid", i.is("invalid"))("ng-pending", i.is("pending")) }, features: [ie] }), n })(), rs = (() => { class n extends XC { constructor(e) { super(e) } } return n.\u0275fac = function(e) { return new (e || n)(g(Ut, 10)) }, n.\u0275dir = S({ type: n, selectors: [["", "formGroupName", ""], ["", "formArrayName", ""], ["", "ngModelGroup", ""], ["", "formGroup", ""], ["form", 3, "ngNoForm", ""], ["", "ngForm", ""]], hostVars: 16, hostBindings: function(e, i) { 2 & e && de("ng-untouched", i.is("untouched"))("ng-touched", i.is("touched"))("ng-pristine", i.is("pristine"))("ng-dirty", i.is("dirty"))("ng-valid", i.is("valid"))("ng-invalid", i.is("invalid"))("ng-pending", i.is("pending"))("ng-submitted", i.is("submitted")) }, features: [ie] }), n })(); function Pa(n, t) { Bp(n, t), t.valueAccessor.writeValue(n.value), function YV(n, t) { t.valueAccessor.registerOnChange(e => { n._pendingValue = e, n._pendingChange = !0, n._pendingDirty = !0, "change" === n.updateOn && tE(n, t) }) }(n, t), function JV(n, t) { const e = (i, r) => { t.valueAccessor.writeValue(i), r && t.viewToModelUpdate(i) }; n.registerOnChange(e), t._registerOnDestroy(() => { n._unregisterOnChange(e) }) }(n, t), function QV(n, t) { t.valueAccessor.registerOnTouched(() => { n._pendingTouched = !0, "blur" === n.updateOn && n._pendingChange && tE(n, t), "submit" !== n.updateOn && n.markAsTouched() }) }(n, t), function qV(n, t) { if (t.valueAccessor.setDisabledState) { const e = i => { t.valueAccessor.setDisabledState(i) }; n.registerOnDisabledChange(e), t._registerOnDestroy(() => { n._unregisterOnDisabledChange(e) }) } }(n, t) } function eu(n, t) { n.forEach(e => { e.registerOnValidatorChange && e.registerOnValidatorChange(t) }) } function Bp(n, t) { const e = function qC(n) { return n._rawValidators }(n); null !== t.validator ? n.setValidators(KC(e, t.validator)) : "function" == typeof e && n.setValidators([e]); const i = function YC(n) { return n._rawAsyncValidators }(n); null !== t.asyncValidator ? n.setAsyncValidators(KC(i, t.asyncValidator)) : "function" == typeof i && n.setAsyncValidators([i]); const r = () => n.updateValueAndValidity(); eu(t._rawValidators, r), eu(t._rawAsyncValidators, r) } function tE(n, t) { n._pendingDirty && n.markAsDirty(), n.setValue(n._pendingValue, { emitModelToViewChange: !1 }), t.viewToModelUpdate(n._pendingValue), n._pendingChange = !1 } function nu(n, t) { const e = n.indexOf(t); e > -1 && n.splice(e, 1) } const ka = "VALID", iu = "INVALID", os = "PENDING", Fa = "DISABLED"; function Up(n) { return (Gp(n) ? n.validators : n) || null } function rE(n) { return Array.isArray(n) ? xp(n) : n || null } function $p(n, t) { return (Gp(t) ? t.asyncValidators : n) || null } function oE(n) { return Array.isArray(n) ? Pp(n) : n || null } function Gp(n) { return null != n && !Array.isArray(n) && "object" == typeof n } const Wp = n => n instanceof Kp; function aE(n) { return (n => n instanceof uE)(n) ? n.value : n.getRawValue() } function lE(n, t) { const e = Wp(n), i = n.controls; if (!(e ? Object.keys(i) : i).length) throw new _e(1e3, ""); if (!i[t]) throw new _e(1001, "") } function cE(n, t) { Wp(n), n._forEachChild((i, r) => { if (void 0 === t[r]) throw new _e(1002, "") }) } class zp { constructor(t, e) { this._pendingDirty = !1, this._hasOwnPendingAsyncValidator = !1, this._pendingTouched = !1, this._onCollectionChange = () => { }, this._parent = null, this.pristine = !0, this.touched = !1, this._onDisabledChange = [], this._rawValidators = t, this._rawAsyncValidators = e, this._composedValidatorFn = rE(this._rawValidators), this._composedAsyncValidatorFn = oE(this._rawAsyncValidators) } get validator() { return this._composedValidatorFn } set validator(t) { this._rawValidators = this._composedValidatorFn = t } get asyncValidator() { return this._composedAsyncValidatorFn } set asyncValidator(t) { this._rawAsyncValidators = this._composedAsyncValidatorFn = t } get parent() { return this._parent } get valid() { return this.status === ka } get invalid() { return this.status === iu } get pending() { return this.status == os } get disabled() { return this.status === Fa } get enabled() { return this.status !== Fa } get dirty() { return !this.pristine } get untouched() { return !this.touched } get updateOn() { return this._updateOn ? this._updateOn : this.parent ? this.parent.updateOn : "change" } setValidators(t) { this._rawValidators = t, this._composedValidatorFn = rE(t) } setAsyncValidators(t) { this._rawAsyncValidators = t, this._composedAsyncValidatorFn = oE(t) } addValidators(t) { this.setValidators(QC(t, this._rawValidators)) } addAsyncValidators(t) { this.setAsyncValidators(QC(t, this._rawAsyncValidators)) } removeValidators(t) { this.setValidators(JC(t, this._rawValidators)) } removeAsyncValidators(t) { this.setAsyncValidators(JC(t, this._rawAsyncValidators)) } hasValidator(t) { return Yc(this._rawValidators, t) } hasAsyncValidator(t) { return Yc(this._rawAsyncValidators, t) } clearValidators() { this.validator = null } clearAsyncValidators() { this.asyncValidator = null } markAsTouched(t = {}) { this.touched = !0, this._parent && !t.onlySelf && this._parent.markAsTouched(t) } markAllAsTouched() { this.markAsTouched({ onlySelf: !0 }), this._forEachChild(t => t.markAllAsTouched()) } markAsUntouched(t = {}) { this.touched = !1, this._pendingTouched = !1, this._forEachChild(e => { e.markAsUntouched({ onlySelf: !0 }) }), this._parent && !t.onlySelf && this._parent._updateTouched(t) } markAsDirty(t = {}) { this.pristine = !1, this._parent && !t.onlySelf && this._parent.markAsDirty(t) } markAsPristine(t = {}) { this.pristine = !0, this._pendingDirty = !1, this._forEachChild(e => { e.markAsPristine({ onlySelf: !0 }) }), this._parent && !t.onlySelf && this._parent._updatePristine(t) } markAsPending(t = {}) { this.status = os, !1 !== t.emitEvent && this.statusChanges.emit(this.status), this._parent && !t.onlySelf && this._parent.markAsPending(t) } disable(t = {}) { const e = this._parentMarkedDirty(t.onlySelf); this.status = Fa, this.errors = null, this._forEachChild(i => { i.disable(Object.assign(Object.assign({}, t), { onlySelf: !0 })) }), this._updateValue(), !1 !== t.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._updateAncestors(Object.assign(Object.assign({}, t), { skipPristineCheck: e })), this._onDisabledChange.forEach(i => i(!0)) } enable(t = {}) { const e = this._parentMarkedDirty(t.onlySelf); this.status = ka, this._forEachChild(i => { i.enable(Object.assign(Object.assign({}, t), { onlySelf: !0 })) }), this.updateValueAndValidity({ onlySelf: !0, emitEvent: t.emitEvent }), this._updateAncestors(Object.assign(Object.assign({}, t), { skipPristineCheck: e })), this._onDisabledChange.forEach(i => i(!1)) } _updateAncestors(t) { this._parent && !t.onlySelf && (this._parent.updateValueAndValidity(t), t.skipPristineCheck || this._parent._updatePristine(), this._parent._updateTouched()) } setParent(t) { this._parent = t } updateValueAndValidity(t = {}) { this._setInitialStatus(), this._updateValue(), this.enabled && (this._cancelExistingSubscription(), this.errors = this._runValidator(), this.status = this._calculateStatus(), (this.status === ka || this.status === os) && this._runAsyncValidator(t.emitEvent)), !1 !== t.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._parent && !t.onlySelf && this._parent.updateValueAndValidity(t) } _updateTreeValidity(t = { emitEvent: !0 }) { this._forEachChild(e => e._updateTreeValidity(t)), this.updateValueAndValidity({ onlySelf: !0, emitEvent: t.emitEvent }) } _setInitialStatus() { this.status = this._allControlsDisabled() ? Fa : ka } _runValidator() { return this.validator ? this.validator(this) : null } _runAsyncValidator(t) { if (this.asyncValidator) { this.status = os, this._hasOwnPendingAsyncValidator = !0; const e = jC(this.asyncValidator(this)); this._asyncValidationSubscription = e.subscribe(i => { this._hasOwnPendingAsyncValidator = !1, this.setErrors(i, { emitEvent: t }) }) } } _cancelExistingSubscription() { this._asyncValidationSubscription && (this._asyncValidationSubscription.unsubscribe(), this._hasOwnPendingAsyncValidator = !1) } setErrors(t, e = {}) { this.errors = t, this._updateControlsErrors(!1 !== e.emitEvent) } get(t) { return function tH(n, t, e) { if (null == t || (Array.isArray(t) || (t = t.split(e)), Array.isArray(t) && 0 === t.length)) return null; let i = n; return t.forEach(r => { i = Wp(i) ? i.controls.hasOwnProperty(r) ? i.controls[r] : null : (n => n instanceof iH)(i) && i.at(r) || null }), i }(this, t, ".") } getError(t, e) { const i = e ? this.get(e) : this; return i && i.errors ? i.errors[t] : null } hasError(t, e) { return !!this.getError(t, e) } get root() { let t = this; for (; t._parent;)t = t._parent; return t } _updateControlsErrors(t) { this.status = this._calculateStatus(), t && this.statusChanges.emit(this.status), this._parent && this._parent._updateControlsErrors(t) } _initObservables() { this.valueChanges = new L, this.statusChanges = new L } _calculateStatus() { return this._allControlsDisabled() ? Fa : this.errors ? iu : this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(os) ? os : this._anyControlsHaveStatus(iu) ? iu : ka } _anyControlsHaveStatus(t) { return this._anyControls(e => e.status === t) } _anyControlsDirty() { return this._anyControls(t => t.dirty) } _anyControlsTouched() { return this._anyControls(t => t.touched) } _updatePristine(t = {}) { this.pristine = !this._anyControlsDirty(), this._parent && !t.onlySelf && this._parent._updatePristine(t) } _updateTouched(t = {}) { this.touched = this._anyControlsTouched(), this._parent && !t.onlySelf && this._parent._updateTouched(t) } _isBoxedValue(t) { return "object" == typeof t && null !== t && 2 === Object.keys(t).length && "value" in t && "disabled" in t } _registerOnCollectionChange(t) { this._onCollectionChange = t } _setUpdateStrategy(t) { Gp(t) && null != t.updateOn && (this._updateOn = t.updateOn) } _parentMarkedDirty(t) { return !t && !(!this._parent || !this._parent.dirty) && !this._parent._anyControlsDirty() } } class uE extends zp { constructor(t = null, e, i) { super(Up(e), $p(i, e)), this._onChange = [], this._pendingChange = !1, this._applyFormState(t), this._setUpdateStrategy(e), this._initObservables(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!this.asyncValidator }) } setValue(t, e = {}) { this.value = this._pendingValue = t, this._onChange.length && !1 !== e.emitModelToViewChange && this._onChange.forEach(i => i(this.value, !1 !== e.emitViewToModelChange)), this.updateValueAndValidity(e) } patchValue(t, e = {}) { this.setValue(t, e) } reset(t = null, e = {}) { this._applyFormState(t), this.markAsPristine(e), this.markAsUntouched(e), this.setValue(this.value, e), this._pendingChange = !1 } _updateValue() { } _anyControls(t) { return !1 } _allControlsDisabled() { return this.disabled } registerOnChange(t) { this._onChange.push(t) } _unregisterOnChange(t) { nu(this._onChange, t) } registerOnDisabledChange(t) { this._onDisabledChange.push(t) } _unregisterOnDisabledChange(t) { nu(this._onDisabledChange, t) } _forEachChild(t) { } _syncPendingControls() { return !("submit" !== this.updateOn || (this._pendingDirty && this.markAsDirty(), this._pendingTouched && this.markAsTouched(), !this._pendingChange) || (this.setValue(this._pendingValue, { onlySelf: !0, emitModelToViewChange: !1 }), 0)) } _applyFormState(t) { this._isBoxedValue(t) ? (this.value = this._pendingValue = t.value, t.disabled ? this.disable({ onlySelf: !0, emitEvent: !1 }) : this.enable({ onlySelf: !0, emitEvent: !1 })) : this.value = this._pendingValue = t } } class Kp extends zp { constructor(t, e, i) { super(Up(e), $p(i, e)), this.controls = t, this._initObservables(), this._setUpdateStrategy(e), this._setUpControls(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!this.asyncValidator }) } registerControl(t, e) { return this.controls[t] ? this.controls[t] : (this.controls[t] = e, e.setParent(this), e._registerOnCollectionChange(this._onCollectionChange), e) } addControl(t, e, i = {}) { this.registerControl(t, e), this.updateValueAndValidity({ emitEvent: i.emitEvent }), this._onCollectionChange() } removeControl(t, e = {}) { this.controls[t] && this.controls[t]._registerOnCollectionChange(() => { }), delete this.controls[t], this.updateValueAndValidity({ emitEvent: e.emitEvent }), this._onCollectionChange() } setControl(t, e, i = {}) { this.controls[t] && this.controls[t]._registerOnCollectionChange(() => { }), delete this.controls[t], e && this.registerControl(t, e), this.updateValueAndValidity({ emitEvent: i.emitEvent }), this._onCollectionChange() } contains(t) { return this.controls.hasOwnProperty(t) && this.controls[t].enabled } setValue(t, e = {}) { cE(this, t), Object.keys(t).forEach(i => { lE(this, i), this.controls[i].setValue(t[i], { onlySelf: !0, emitEvent: e.emitEvent }) }), this.updateValueAndValidity(e) } patchValue(t, e = {}) { null != t && (Object.keys(t).forEach(i => { this.controls[i] && this.controls[i].patchValue(t[i], { onlySelf: !0, emitEvent: e.emitEvent }) }), this.updateValueAndValidity(e)) } reset(t = {}, e = {}) { this._forEachChild((i, r) => { i.reset(t[r], { onlySelf: !0, emitEvent: e.emitEvent }) }), this._updatePristine(e), this._updateTouched(e), this.updateValueAndValidity(e) } getRawValue() { return this._reduceChildren({}, (t, e, i) => (t[i] = aE(e), t)) } _syncPendingControls() { let t = this._reduceChildren(!1, (e, i) => !!i._syncPendingControls() || e); return t && this.updateValueAndValidity({ onlySelf: !0 }), t } _forEachChild(t) { Object.keys(this.controls).forEach(e => { const i = this.controls[e]; i && t(i, e) }) } _setUpControls() { this._forEachChild(t => { t.setParent(this), t._registerOnCollectionChange(this._onCollectionChange) }) } _updateValue() { this.value = this._reduceValue() } _anyControls(t) { for (const e of Object.keys(this.controls)) { const i = this.controls[e]; if (this.contains(e) && t(i)) return !0 } return !1 } _reduceValue() { return this._reduceChildren({}, (t, e, i) => ((e.enabled || this.disabled) && (t[i] = e.value), t)) } _reduceChildren(t, e) { let i = t; return this._forEachChild((r, o) => { i = e(i, r, o) }), i } _allControlsDisabled() { for (const t of Object.keys(this.controls)) if (this.controls[t].enabled) return !1; return Object.keys(this.controls).length > 0 || this.disabled } } class iH extends zp { constructor(t, e, i) { super(Up(e), $p(i, e)), this.controls = t, this._initObservables(), this._setUpdateStrategy(e), this._setUpControls(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!this.asyncValidator }) } at(t) { return this.controls[t] } push(t, e = {}) { this.controls.push(t), this._registerControl(t), this.updateValueAndValidity({ emitEvent: e.emitEvent }), this._onCollectionChange() } insert(t, e, i = {}) { this.controls.splice(t, 0, e), this._registerControl(e), this.updateValueAndValidity({ emitEvent: i.emitEvent }) } removeAt(t, e = {}) { this.controls[t] && this.controls[t]._registerOnCollectionChange(() => { }), this.controls.splice(t, 1), this.updateValueAndValidity({ emitEvent: e.emitEvent }) } setControl(t, e, i = {}) { this.controls[t] && this.controls[t]._registerOnCollectionChange(() => { }), this.controls.splice(t, 1), e && (this.controls.splice(t, 0, e), this._registerControl(e)), this.updateValueAndValidity({ emitEvent: i.emitEvent }), this._onCollectionChange() } get length() { return this.controls.length } setValue(t, e = {}) { cE(this, t), t.forEach((i, r) => { lE(this, r), this.at(r).setValue(i, { onlySelf: !0, emitEvent: e.emitEvent }) }), this.updateValueAndValidity(e) } patchValue(t, e = {}) { null != t && (t.forEach((i, r) => { this.at(r) && this.at(r).patchValue(i, { onlySelf: !0, emitEvent: e.emitEvent }) }), this.updateValueAndValidity(e)) } reset(t = [], e = {}) { this._forEachChild((i, r) => { i.reset(t[r], { onlySelf: !0, emitEvent: e.emitEvent }) }), this._updatePristine(e), this._updateTouched(e), this.updateValueAndValidity(e) } getRawValue() { return this.controls.map(t => aE(t)) } clear(t = {}) { this.controls.length < 1 || (this._forEachChild(e => e._registerOnCollectionChange(() => { })), this.controls.splice(0), this.updateValueAndValidity({ emitEvent: t.emitEvent })) } _syncPendingControls() { let t = this.controls.reduce((e, i) => !!i._syncPendingControls() || e, !1); return t && this.updateValueAndValidity({ onlySelf: !0 }), t } _forEachChild(t) { this.controls.forEach((e, i) => { t(e, i) }) } _updateValue() { this.value = this.controls.filter(t => t.enabled || this.disabled).map(t => t.value) } _anyControls(t) { return this.controls.some(e => e.enabled && t(e)) } _setUpControls() { this._forEachChild(t => this._registerControl(t)) } _allControlsDisabled() { for (const t of this.controls) if (t.enabled) return !1; return this.controls.length > 0 || this.disabled } _registerControl(t) { t.setParent(this), t._registerOnCollectionChange(this._onCollectionChange) } } const rH = { provide: Ut, useExisting: ge(() => rr) }, La = (() => Promise.resolve(null))(); let rr = (() => { class n extends Ut { constructor(e, i) { super(), this.submitted = !1, this._directives = [], this.ngSubmit = new L, this.form = new Kp({}, xp(e), Pp(i)) } ngAfterViewInit() { this._setUpdateStrategy() } get formDirective() { return this } get control() { return this.form } get path() { return [] } get controls() { return this.form.controls } addControl(e) { La.then(() => { const i = this._findContainer(e.path); e.control = i.registerControl(e.name, e.control), Pa(e.control, e), e.control.updateValueAndValidity({ emitEvent: !1 }), this._directives.push(e) }) } getControl(e) { return this.form.get(e.path) } removeControl(e) { La.then(() => { const i = this._findContainer(e.path); i && i.removeControl(e.name), nu(this._directives, e) }) } addFormGroup(e) { La.then(() => { const i = this._findContainer(e.path), r = new Kp({}); (function nE(n, t) { Bp(n, t) })(r, e), i.registerControl(e.name, r), r.updateValueAndValidity({ emitEvent: !1 }) }) } removeFormGroup(e) { La.then(() => { const i = this._findContainer(e.path); i && i.removeControl(e.name) }) } getFormGroup(e) { return this.form.get(e.path) } updateModel(e, i) { La.then(() => { this.form.get(e.path).setValue(i) }) } setValue(e) { this.control.setValue(e) } onSubmit(e) { return this.submitted = !0, function iE(n, t) { n._syncPendingControls(), t.forEach(e => { const i = e.control; "submit" === i.updateOn && i._pendingChange && (e.viewToModelUpdate(i._pendingValue), i._pendingChange = !1) }) }(this.form, this._directives), this.ngSubmit.emit(e), !1 } onReset() { this.resetForm() } resetForm(e) { this.form.reset(e), this.submitted = !1 } _setUpdateStrategy() { this.options && null != this.options.updateOn && (this.form._updateOn = this.options.updateOn) } _findContainer(e) { return e.pop(), e.length ? this.form.get(e) : this.form } } return n.\u0275fac = function(e) { return new (e || n)(g(Pt, 10), g(nr, 10)) }, n.\u0275dir = S({ type: n, selectors: [["form", 3, "ngNoForm", "", 3, "formGroup", ""], ["ng-form"], ["", "ngForm", ""]], hostBindings: function(e, i) { 1 & e && B("submit", function(o) { return i.onSubmit(o) })("reset", function() { return i.onReset() }) }, inputs: { options: ["ngFormOptions", "options"] }, outputs: { ngSubmit: "ngSubmit" }, exportAs: ["ngForm"], features: [Se([rH]), ie] }), n })(); const sH = { provide: ir, useExisting: ge(() => Ba) }, fE = (() => Promise.resolve(null))(); let Ba = (() => { class n extends ir { constructor(e, i, r, o) { super(), this.control = new uE, this._registered = !1, this.update = new L, this._parent = e, this._setValidators(i), this._setAsyncValidators(r), this.valueAccessor = function Hp(n, t) { if (!t) return null; let e, i, r; return Array.isArray(t), t.forEach(o => { o.constructor === is ? e = o : function eH(n) { return Object.getPrototypeOf(n.constructor) === Pr }(o) ? i = o : r = o }), r || i || e || null }(0, o) } ngOnChanges(e) { this._checkForErrors(), this._registered || this._setUpControl(), "isDisabled" in e && this._updateDisabled(e), function Vp(n, t) { if (!n.hasOwnProperty("model")) return !1; const e = n.model; return !!e.isFirstChange() || !Object.is(t, e.currentValue) }(e, this.viewModel) && (this._updateValue(this.model), this.viewModel = this.model) } ngOnDestroy() { this.formDirective && this.formDirective.removeControl(this) } get path() { return this._parent ? function Zc(n, t) { return [...t.path, n] }(this.name, this._parent) : [this.name] } get formDirective() { return this._parent ? this._parent.formDirective : null } viewToModelUpdate(e) { this.viewModel = e, this.update.emit(e) } _setUpControl() { this._setUpdateStrategy(), this._isStandalone() ? this._setUpStandalone() : this.formDirective.addControl(this), this._registered = !0 } _setUpdateStrategy() { this.options && null != this.options.updateOn && (this.control._updateOn = this.options.updateOn) } _isStandalone() { return !this._parent || !(!this.options || !this.options.standalone) } _setUpStandalone() { Pa(this.control, this), this.control.updateValueAndValidity({ emitEvent: !1 }) } _checkForErrors() { this._isStandalone() || this._checkParentType(), this._checkName() } _checkParentType() { } _checkName() { this.options && this.options.name && (this.name = this.options.name), this._isStandalone() } _updateValue(e) { fE.then(() => { this.control.setValue(e, { emitViewToModelChange: !1 }) }) } _updateDisabled(e) { const i = e.isDisabled.currentValue, r = "" === i || i && "false" !== i; fE.then(() => { r && !this.control.disabled ? this.control.disable() : !r && this.control.disabled && this.control.enable() }) } } return n.\u0275fac = function(e) { return new (e || n)(g(Ut, 9), g(Pt, 10), g(nr, 10), g(vn, 10)) }, n.\u0275dir = S({ type: n, selectors: [["", "ngModel", "", 3, "formControlName", "", 3, "formControl", ""]], inputs: { name: "name", isDisabled: ["disabled", "isDisabled"], model: ["ngModel", "model"], options: ["ngModelOptions", "options"] }, outputs: { update: "ngModelChange" }, exportAs: ["ngModel"], features: [Se([sH]), ie, wt] }), n })(), ss = (() => { class n { } return n.\u0275fac = function(e) { return new (e || n) }, n.\u0275dir = S({ type: n, selectors: [["form", 3, "ngNoForm", "", 3, "ngNativeValidate", ""]], hostAttrs: ["novalidate", ""] }), n })(), gE = (() => { class n { } return n.\u0275fac = function(e) { return new (e || n) }, n.\u0275mod = se({ type: n }), n.\u0275inj = te({}), n })(), IH = (() => { class n { } return n.\u0275fac = function(e) { return new (e || n) }, n.\u0275mod = se({ type: n }), n.\u0275inj = te({ imports: [[gE]] }), n })(), xE = (() => { class n { } return n.\u0275fac = function(e) { return new (e || n) }, n.\u0275mod = se({ type: n }), n.\u0275inj = te({ imports: [IH] }), n })(); Math, Math, Math; const Vj = ["*"], iU = ["dialog"]; function Fr(n) { return null != n } function hs(n) { return (n || document.body).getBoundingClientRect() } const YE = { animation: !0, transitionTimerDelayMs: 5 }, ZU = () => { }, { transitionTimerDelayMs: XU } = YE, za = new Map, $t = (n, t, e, i) => { let r = i.context || {}; const o = za.get(t); if (o) switch (i.runningTransition) { case "continue": return Mn; case "stop": n.run(() => o.transition$.complete()), r = Object.assign(o.context, r), za.delete(t) }const s = e(t, i.animation, r) || ZU; if (!i.animation || "none" === window.getComputedStyle(t).transitionProperty) return n.run(() => s()), U(void 0).pipe(function QU(n) { return t => new Ce(e => t.subscribe({ next: s => n.run(() => e.next(s)), error: s => n.run(() => e.error(s)), complete: () => n.run(() => e.complete()) })) }(n)); const a = new be, l = new be, c = a.pipe(function RV(...n) { return t => _a(t, U(...n)) }(!0)); za.set(t, { transition$: a, complete: () => { l.next(), l.complete() }, context: r }); const u = function JU(n) { const { transitionDelay: t, transitionDuration: e } = window.getComputedStyle(n); return 1e3 * (parseFloat(t) + parseFloat(e)) }(t); return n.runOutsideAngular(() => { const d = Ct(t, "transitionend").pipe(Le(c), jt(({ target: f }) => f === t)); (function wC(...n) { return 1 === (n = EC(n)).length ? Et(n[0]) : new Ce(function IV(n) { return t => { let e = []; for (let i = 0; e && !t.closed && i < n.length; i++)e.push(Et(n[i]).subscribe(new Ie(t, r => { if (e) { for (let o = 0; o < e.length; o++)o !== i && e[o].unsubscribe(); e = null } t.next(r) }))) } }(n)) })(Ra(u + XU).pipe(Le(c)), d, l).pipe(Le(c)).subscribe(() => { za.delete(t), n.run(() => { s(), a.next(), a.complete() }) }) }), a.asObservable() }; let cu = (() => { class n { constructor() { this.animation = YE.animation } } return n.\u0275fac = function(e) { return new (e || n) }, n.\u0275prov = R({ token: n, factory: n.\u0275fac, providedIn: "root" }), n })(), tw = (() => { class n { } return n.\u0275fac = function(e) { return new (e || n) }, n.\u0275mod = se({ type: n }), n.\u0275inj = te({ imports: [[Qt]] }), n })(), nw = (() => { class n { } return n.\u0275fac = function(e) { return new (e || n) }, n.\u0275mod = se({ type: n }), n.\u0275inj = te({ imports: [[Qt]] }), n })(), rw = (() => { class n { } return n.\u0275fac = function(e) { return new (e || n) }, n.\u0275mod = se({ type: n }), n.\u0275inj = te({}), n })(), aw = (() => { class n { } return n.\u0275fac = function(e) { return new (e || n) }, n.\u0275mod = se({ type: n }), n.\u0275inj = te({ imports: [[Qt]] }), n })(), lw = (() => { class n { } return n.\u0275fac = function(e) { return new (e || n) }, n.\u0275mod = se({ type: n }), n.\u0275inj = te({}), n })(); var mt = (() => { return (n = mt || (mt = {}))[n.Tab = 9] = "Tab", n[n.Enter = 13] = "Enter", n[n.Escape = 27] = "Escape", n[n.Space = 32] = "Space", n[n.PageUp = 33] = "PageUp", n[n.PageDown = 34] = "PageDown", n[n.End = 35] = "End", n[n.Home = 36] = "Home", n[n.ArrowLeft = 37] = "ArrowLeft", n[n.ArrowUp = 38] = "ArrowUp", n[n.ArrowRight = 39] = "ArrowRight", n[n.ArrowDown = 40] = "ArrowDown", mt; var n })(); "undefined" != typeof navigator && navigator.userAgent && (/iPad|iPhone|iPod/.test(navigator.userAgent) || /Macintosh/.test(navigator.userAgent) && navigator.maxTouchPoints && navigator.maxTouchPoints > 2 || /Android/.test(navigator.userAgent)); const uw = ["a[href]", "button:not([disabled])", 'input:not([disabled]):not([type="hidden"])', "select:not([disabled])", "textarea:not([disabled])", "[contenteditable]", '[tabindex]:not([tabindex="-1"])'].join(", "); function dw(n) { const t = Array.from(n.querySelectorAll(uw)).filter(e => -1 !== e.tabIndex); return [t[0], t[t.length - 1]] } new Date(1882, 10, 12), new Date(2174, 10, 25); let bw = (() => { class n { } return n.\u0275fac = function(e) { return new (e || n) }, n.\u0275mod = se({ type: n }), n.\u0275inj = te({ imports: [[Qt, xE]] }), n })(), mg = (() => { class n { } return n.\u0275fac = function(e) { return new (e || n) }, n.\u0275dir = S({ type: n, selectors: [["", 8, "navbar"]] }), n })(), Cw = (() => { class n { } return n.\u0275fac = function(e) { return new (e || n) }, n.\u0275mod = se({ type: n }), n.\u0275inj = te({}), n })(); class Hr { constructor(t, e, i) { this.nodes = t, this.viewRef = e, this.componentRef = i } } let W$ = (() => { class n { constructor(e, i) { this._el = e, this._zone = i } ngOnInit() { this._zone.onStable.asObservable().pipe(ct(1)).subscribe(() => { $t(this._zone, this._el.nativeElement, (e, i) => { i && hs(e), e.classList.add("show") }, { animation: this.animation, runningTransition: "continue" }) }) } hide() { return $t(this._zone, this._el.nativeElement, ({ classList: e }) => e.remove("show"), { animation: this.animation, runningTransition: "stop" }) } } return n.\u0275fac = function(e) { return new (e || n)(g(X), g(he)) }, n.\u0275cmp = We({ type: n, selectors: [["ngb-modal-backdrop"]], hostAttrs: [2, "z-index", "1055"], hostVars: 6, hostBindings: function(e, i) { 2 & e && (wr("modal-backdrop" + (i.backdropClass ? " " + i.backdropClass : "")), de("show", !i.animation)("fade", i.animation)) }, inputs: { animation: "animation", backdropClass: "backdropClass" }, decls: 0, vars: 0, template: function(e, i) { }, encapsulation: 2 }), n })(); class Ew { close(t) { } dismiss(t) { } } class z$ { constructor(t, e, i, r) { this._windowCmptRef = t, this._contentRef = e, this._backdropCmptRef = i, this._beforeDismiss = r, this._closed = new be, this._dismissed = new be, this._hidden = new be, t.instance.dismissEvent.subscribe(o => { this.dismiss(o) }), this.result = new Promise((o, s) => { this._resolve = o, this._reject = s }), this.result.then(null, () => { }) } get componentInstance() { if (this._contentRef && this._contentRef.componentRef) return this._contentRef.componentRef.instance } get closed() { return this._closed.asObservable().pipe(Le(this._hidden)) } get dismissed() { return this._dismissed.asObservable().pipe(Le(this._hidden)) } get hidden() { return this._hidden.asObservable() } get shown() { return this._windowCmptRef.instance.shown.asObservable() } close(t) { this._windowCmptRef && (this._closed.next(t), this._resolve(t), this._removeModalElements()) } _dismiss(t) { this._dismissed.next(t), this._reject(t), this._removeModalElements() } dismiss(t) { if (this._windowCmptRef) if (this._beforeDismiss) { const e = this._beforeDismiss(); !function qU(n) { return n && n.then }(e) ? !1 !== e && this._dismiss(t) : e.then(i => { !1 !== i && this._dismiss(t) }, () => { }) } else this._dismiss(t) } _removeModalElements() { const t = this._windowCmptRef.instance.hide(), e = this._backdropCmptRef ? this._backdropCmptRef.instance.hide() : U(void 0); t.subscribe(() => { const { nativeElement: i } = this._windowCmptRef.location; i.parentNode.removeChild(i), this._windowCmptRef.destroy(), this._contentRef && this._contentRef.viewRef && this._contentRef.viewRef.destroy(), this._windowCmptRef = null, this._contentRef = null }), e.subscribe(() => { if (this._backdropCmptRef) { const { nativeElement: i } = this._backdropCmptRef.location; i.parentNode.removeChild(i), this._backdropCmptRef.destroy(), this._backdropCmptRef = null } }), qc(t, e).subscribe(() => { this._hidden.next(), this._hidden.complete() }) } } var Qa = (() => { return (n = Qa || (Qa = {}))[n.BACKDROP_CLICK = 0] = "BACKDROP_CLICK", n[n.ESC = 1] = "ESC", Qa; var n })(); let K$ = (() => { class n { constructor(e, i, r) { this._document = e, this._elRef = i, this._zone = r, this._closed$ = new be, this._elWithFocus = null, this.backdrop = !0, this.keyboard = !0, this.dismissEvent = new L, this.shown = new be, this.hidden = new be } dismiss(e) { this.dismissEvent.emit(e) } ngOnInit() { this._elWithFocus = this._document.activeElement, this._zone.onStable.asObservable().pipe(ct(1)).subscribe(() => { this._show() }) } ngOnDestroy() { this._disableEventHandling() } hide() { const { nativeElement: e } = this._elRef, i = { animation: this.animation, runningTransition: "stop" }, s = qc($t(this._zone, e, () => e.classList.remove("show"), i), $t(this._zone, this._dialogEl.nativeElement, () => { }, i)); return s.subscribe(() => { this.hidden.next(), this.hidden.complete() }), this._disableEventHandling(), this._restoreFocus(), s } _show() { const e = { animation: this.animation, runningTransition: "continue" }; qc($t(this._zone, this._elRef.nativeElement, (o, s) => { s && hs(o), o.classList.add("show") }, e), $t(this._zone, this._dialogEl.nativeElement, () => { }, e)).subscribe(() => { this.shown.next(), this.shown.complete() }), this._enableEventHandling(), this._setFocus() } _enableEventHandling() { const { nativeElement: e } = this._elRef; this._zone.runOutsideAngular(() => { Ct(e, "keydown").pipe(Le(this._closed$), jt(r => r.which === mt.Escape)).subscribe(r => { this.keyboard ? requestAnimationFrame(() => { r.defaultPrevented || this._zone.run(() => this.dismiss(Qa.ESC)) }) : "static" === this.backdrop && this._bumpBackdrop() }); let i = !1; Ct(this._dialogEl.nativeElement, "mousedown").pipe(Le(this._closed$), _t(() => i = !1), Ii(() => Ct(e, "mouseup").pipe(Le(this._closed$), ct(1))), jt(({ target: r }) => e === r)).subscribe(() => { i = !0 }), Ct(e, "click").pipe(Le(this._closed$)).subscribe(({ target: r }) => { e === r && ("static" === this.backdrop ? this._bumpBackdrop() : !0 === this.backdrop && !i && this._zone.run(() => this.dismiss(Qa.BACKDROP_CLICK))), i = !1 }) }) } _disableEventHandling() { this._closed$.next() } _setFocus() { const { nativeElement: e } = this._elRef; if (!e.contains(document.activeElement)) { const i = e.querySelector("[ngbAutofocus]"), r = dw(e)[0]; (i || r || e).focus() } } _restoreFocus() { const e = this._document.body, i = this._elWithFocus; let r; r = i && i.focus && e.contains(i) ? i : e, this._zone.runOutsideAngular(() => { setTimeout(() => r.focus()), this._elWithFocus = null }) } _bumpBackdrop() { "static" === this.backdrop && $t(this._zone, this._elRef.nativeElement, ({ classList: e }) => (e.add("modal-static"), () => e.remove("modal-static")), { animation: this.animation, runningTransition: "continue" }) } } return n.\u0275fac = function(e) { return new (e || n)(g(De), g(X), g(he)) }, n.\u0275cmp = We({ type: n, selectors: [["ngb-modal-window"]], viewQuery: function(e, i) { if (1 & e && qt(iU, 7), 2 & e) { let r; le(r = ce()) && (i._dialogEl = r.first) } }, hostAttrs: ["role", "dialog", "tabindex", "-1"], hostVars: 7, hostBindings: function(e, i) { 2 & e && (ve("aria-modal", !0)("aria-labelledby", i.ariaLabelledBy)("aria-describedby", i.ariaDescribedBy), wr("modal d-block" + (i.windowClass ? " " + i.windowClass : "")), de("fade", i.animation)) }, inputs: { animation: "animation", ariaLabelledBy: "ariaLabelledBy", ariaDescribedBy: "ariaDescribedBy", backdrop: "backdrop", centered: "centered", keyboard: "keyboard", scrollable: "scrollable", size: "size", windowClass: "windowClass", modalDialogClass: "modalDialogClass" }, outputs: { dismissEvent: "dismiss" }, ngContentSelectors: Vj, decls: 4, vars: 2, consts: [["role", "document"], ["dialog", ""], [1, "modal-content"]], template: function(e, i) { 1 & e && (Po(), v(0, "div", 0, 1), v(2, "div", 2), ko(3), D(), D()), 2 & e && wr("modal-dialog" + (i.size ? " modal-" + i.size : "") + (i.centered ? " modal-dialog-centered" : "") + (i.scrollable ? " modal-dialog-scrollable" : "") + (i.modalDialogClass ? " " + i.modalDialogClass : "")) }, styles: ["ngb-modal-window .component-host-scrollable{display:flex;flex-direction:column;overflow:hidden}\n"], encapsulation: 2 }), n })(), q$ = (() => { class n { constructor(e) { this._document = e } hide() { const e = Math.abs(window.innerWidth - this._document.documentElement.clientWidth), i = this._document.body, r = i.style, { overflow: o, paddingRight: s } = r; if (e > 0) { const a = parseFloat(window.getComputedStyle(i).paddingRight); r.paddingRight = `${a + e}px` } return r.overflow = "hidden", () => { e > 0 && (r.paddingRight = s), r.overflow = o } } } return n.\u0275fac = function(e) { return new (e || n)(E(De)) }, n.\u0275prov = R({ token: n, factory: n.\u0275fac, providedIn: "root" }), n })(), Y$ = (() => { class n { constructor(e, i, r, o, s, a) { this._applicationRef = e, this._injector = i, this._document = r, this._scrollBar = o, this._rendererFactory = s, this._ngZone = a, this._activeWindowCmptHasChanged = new be, this._ariaHiddenValues = new Map, this._scrollBarRestoreFn = null, this._backdropAttributes = ["animation", "backdropClass"], this._modalRefs = [], this._windowAttributes = ["animation", "ariaLabelledBy", "ariaDescribedBy", "backdrop", "centered", "keyboard", "scrollable", "size", "windowClass", "modalDialogClass"], this._windowCmpts = [], this._activeInstances = new L, this._activeWindowCmptHasChanged.subscribe(() => { if (this._windowCmpts.length) { const l = this._windowCmpts[this._windowCmpts.length - 1]; ((n, t, e, i = !1) => { this._ngZone.runOutsideAngular(() => { const r = Ct(t, "focusin").pipe(Le(e), W(o => o.target)); Ct(t, "keydown").pipe(Le(e), jt(o => o.which === mt.Tab), Op(r)).subscribe(([o, s]) => { const [a, l] = dw(t); (s === a || s === t) && o.shiftKey && (l.focus(), o.preventDefault()), s === l && !o.shiftKey && (a.focus(), o.preventDefault()) }), i && Ct(t, "click").pipe(Le(e), Op(r), W(o => o[1])).subscribe(o => o.focus()) }) })(0, l.location.nativeElement, this._activeWindowCmptHasChanged), this._revertAriaHidden(), this._setAriaHidden(l.location.nativeElement) } }) } _restoreScrollBar() { const e = this._scrollBarRestoreFn; e && (this._scrollBarRestoreFn = null, e()) } _hideScrollBar() { this._scrollBarRestoreFn || (this._scrollBarRestoreFn = this._scrollBar.hide()) } open(e, i, r, o) { const s = o.container instanceof HTMLElement ? o.container : Fr(o.container) ? this._document.querySelector(o.container) : this._document.body, a = this._rendererFactory.createRenderer(null, null), l = () => { this._modalRefs.length || (a.removeClass(this._document.body, "modal-open"), this._restoreScrollBar(), this._revertAriaHidden()) }; if (!s) throw new Error(`The specified modal container "${o.container || "body"}" was not found in the DOM.`); this._hideScrollBar(); const c = new Ew, u = this._getContentRef(e, o.injector || i, r, c, o); let d = !1 !== o.backdrop ? this._attachBackdrop(e, s) : void 0, h = this._attachWindowComponent(e, s, u), f = new z$(h, u, d, o.beforeDismiss); return this._registerModalRef(f), this._registerWindowCmpt(h), f.result.then(l, l), c.close = p => { f.close(p) }, c.dismiss = p => { f.dismiss(p) }, this._applyWindowOptions(h.instance, o), 1 === this._modalRefs.length && a.addClass(this._document.body, "modal-open"), d && d.instance && (this._applyBackdropOptions(d.instance, o), d.changeDetectorRef.detectChanges()), h.changeDetectorRef.detectChanges(), f } get activeInstances() { return this._activeInstances } dismissAll(e) { this._modalRefs.forEach(i => i.dismiss(e)) } hasOpenModals() { return this._modalRefs.length > 0 } _attachBackdrop(e, i) { let o = e.resolveComponentFactory(W$).create(this._injector); return this._applicationRef.attachView(o.hostView), i.appendChild(o.location.nativeElement), o } _attachWindowComponent(e, i, r) { let s = e.resolveComponentFactory(K$).create(this._injector, r.nodes); return this._applicationRef.attachView(s.hostView), i.appendChild(s.location.nativeElement), s } _applyWindowOptions(e, i) { this._windowAttributes.forEach(r => { Fr(i[r]) && (e[r] = i[r]) }) } _applyBackdropOptions(e, i) { this._backdropAttributes.forEach(r => { Fr(i[r]) && (e[r] = i[r]) }) } _getContentRef(e, i, r, o, s) { return r ? r instanceof ke ? this._createFromTemplateRef(r, o) : function qE(n) { return "string" == typeof n }(r) ? this._createFromString(r) : this._createFromComponent(e, i, r, o, s) : new Hr([]) } _createFromTemplateRef(e, i) { const o = e.createEmbeddedView({ $implicit: i, close(s) { i.close(s) }, dismiss(s) { i.dismiss(s) } }); return this._applicationRef.attachView(o), new Hr([o.rootNodes], o) } _createFromString(e) { const i = this._document.createTextNode(`${e}`); return new Hr([[i]]) } _createFromComponent(e, i, r, o, s) { const a = e.resolveComponentFactory(r), l = et.create({ providers: [{ provide: Ew, useValue: o }], parent: i }), c = a.create(l), u = c.location.nativeElement; return s.scrollable && u.classList.add("component-host-scrollable"), this._applicationRef.attachView(c.hostView), new Hr([[u]], c.hostView, c) } _setAriaHidden(e) { const i = e.parentElement; i && e !== this._document.body && (Array.from(i.children).forEach(r => { r !== e && "SCRIPT" !== r.nodeName && (this._ariaHiddenValues.set(r, r.getAttribute("aria-hidden")), r.setAttribute("aria-hidden", "true")) }), this._setAriaHidden(i)) } _revertAriaHidden() { this._ariaHiddenValues.forEach((e, i) => { e ? i.setAttribute("aria-hidden", e) : i.removeAttribute("aria-hidden") }), this._ariaHiddenValues.clear() } _registerModalRef(e) { const i = () => { const r = this._modalRefs.indexOf(e); r > -1 && (this._modalRefs.splice(r, 1), this._activeInstances.emit(this._modalRefs)) }; this._modalRefs.push(e), this._activeInstances.emit(this._modalRefs), e.result.then(i, i) } _registerWindowCmpt(e) { this._windowCmpts.push(e), this._activeWindowCmptHasChanged.next(), e.onDestroy(() => { const i = this._windowCmpts.indexOf(e); i > -1 && (this._windowCmpts.splice(i, 1), this._activeWindowCmptHasChanged.next()) }) } } return n.\u0275fac = function(e) { return new (e || n)(E(Ko), E(et), E(De), E(q$), E(Ho), E(he)) }, n.\u0275prov = R({ token: n, factory: n.\u0275fac, providedIn: "root" }), n })(), Q$ = (() => { class n { constructor(e) { this._ngbConfig = e, this.backdrop = !0, this.keyboard = !0 } get animation() { return void 0 === this._animation ? this._ngbConfig.animation : this._animation } set animation(e) { this._animation = e } } return n.\u0275fac = function(e) { return new (e || n)(E(cu)) }, n.\u0275prov = R({ token: n, factory: n.\u0275fac, providedIn: "root" }), n })(), ww = (() => { class n { constructor(e, i, r, o) { this._moduleCFR = e, this._injector = i, this._modalStack = r, this._config = o } open(e, i = {}) { const r = Object.assign(Object.assign(Object.assign({}, this._config), { animation: this._config.animation }), i); return this._modalStack.open(this._moduleCFR, this._injector, e, r) } get activeInstances() { return this._modalStack.activeInstances } dismissAll(e) { this._modalStack.dismissAll(e) } hasOpenModals() { return this._modalStack.hasOpenModals() } } return n.\u0275fac = function(e) { return new (e || n)(E(wi), E(et), E(Y$), E(Q$)) }, n.\u0275prov = R({ token: n, factory: n.\u0275fac, providedIn: "root" }), n })(), Tw = (() => { class n { } return n.\u0275fac = function(e) { return new (e || n) }, n.\u0275mod = se({ type: n }), n.\u0275inj = te({ providers: [ww] }), n })(), Nw = (() => { class n { } return n.\u0275fac = function(e) { return new (e || n) }, n.\u0275mod = se({ type: n }), n.\u0275inj = te({ imports: [[Qt]] }), n })(), Lw = (() => { class n { } return n.\u0275fac = function(e) { return new (e || n) }, n.\u0275mod = se({ type: n }), n.\u0275inj = te({ imports: [[Qt]] }), n })(), Vw = (() => { class n { } return n.\u0275fac = function(e) { return new (e || n) }, n.\u0275mod = se({ type: n }), n.\u0275inj = te({ imports: [[Qt]] }), n })(), Hw = (() => { class n { } return n.\u0275fac = function(e) { return new (e || n) }, n.\u0275mod = se({ type: n }), n.\u0275inj = te({ imports: [[Qt]] }), n })(), jw = (() => { class n { } return n.\u0275fac = function(e) { return new (e || n) }, n.\u0275mod = se({ type: n }), n.\u0275inj = te({ imports: [[Qt]] }), n })(), Uw = (() => { class n { } return n.\u0275fac = function(e) { return new (e || n) }, n.\u0275mod = se({ type: n }), n.\u0275inj = te({ imports: [[Qt]] }), n })(), $w = (() => { class n { } return n.\u0275fac = function(e) { return new (e || n) }, n.\u0275mod = se({ type: n }), n.\u0275inj = te({ imports: [[Qt]] }), n })(), Gw = (() => { class n { } return n.\u0275fac = function(e) { return new (e || n) }, n.\u0275mod = se({ type: n }), n.\u0275inj = te({}), n })(); new P("live announcer delay", { providedIn: "root", factory: function u3() { return 100 } }); let Ww = (() => { class n { } return n.\u0275fac = function(e) { return new (e || n) }, n.\u0275mod = se({ type: n }), n.\u0275inj = te({ imports: [[Qt]] }), n })(); const d3 = [tw, nw, rw, aw, lw, bw, Cw, Tw, Nw, Lw, Vw, Hw, jw, Uw, $w, Gw, Ww]; let Dg, h3 = (() => { class n { } return n.\u0275fac = function(e) { return new (e || n) }, n.\u0275mod = se({ type: n }), n.\u0275inj = te({ imports: [d3, tw, nw, rw, aw, lw, bw, Cw, Tw, Nw, Lw, Vw, Hw, jw, Uw, $w, Gw, Ww] }), n })(); try { Dg = "undefined" != typeof Intl && Intl.v8BreakIterator } catch (n) { Dg = !1 } let Ja, Cg, ar = (() => { class n { constructor(e) { this._platformId = e, this.isBrowser = this._platformId ? function VD(n) { return n === BD }(this._platformId) : "object" == typeof document && !!document, this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent), this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent), this.BLINK = this.isBrowser && !(!window.chrome && !Dg) && "undefined" != typeof CSS && !this.EDGE && !this.TRIDENT, this.WEBKIT = this.isBrowser && /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT, this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !("MSStream" in window), this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent), this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT, this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT } } return n.\u0275fac = function(e) { return new (e || n)(E(zo)) }, n.\u0275prov = R({ token: n, factory: n.\u0275fac, providedIn: "root" }), n })(); function mu(n) { return function f3() { if (null == Ja && "undefined" != typeof window) try { window.addEventListener("test", null, Object.defineProperty({}, "passive", { get: () => Ja = !0 })) } finally { Ja = Ja || !1 } return Ja }() ? n : !!n.capture } function Za(n) { return n.composedPath ? n.composedPath()[0] : n.target } function Kw(n, ...t) { return t.length ? t.some(e => n[e]) : n.altKey || n.shiftKey || n.ctrlKey || n.metaKey } function qw(n, t = Rp) { return Ge((e, i) => { let r = null, o = null, s = null; const a = () => { if (r) { r.unsubscribe(), r = null; const c = o; o = null, i.next(c) } }; function l() { const c = s + n, u = t.now(); if (u < c) return r = this.schedule(void 0, c - u), void i.add(r); a() } e.subscribe(new Ie(i, c => { o = c, s = t.now(), r || (r = t.schedule(l, n), i.add(r)) }, () => { a(), i.complete() }, void 0, () => { o = r = null })) }) } function gs(n) { return null != n && "false" != `${n}` } function bu(n, t = 0) { return function k3(n) { return !isNaN(parseFloat(n)) && !isNaN(Number(n)) }(n) ? Number(n) : t } function _s(n) { return n instanceof X ? n.nativeElement : n } let Yw = (() => { class n { create(e) { return "undefined" == typeof MutationObserver ? null : new MutationObserver(e) } } return n.\u0275fac = function(e) { return new (e || n) }, n.\u0275prov = R({ token: n, factory: n.\u0275fac, providedIn: "root" }), n })(), F3 = (() => { class n { constructor(e) { this._mutationObserverFactory = e, this._observedElements = new Map } ngOnDestroy() { this._observedElements.forEach((e, i) => this._cleanupObserver(i)) } observe(e) { const i = _s(e); return new Ce(r => { const s = this._observeElement(i).subscribe(r); return () => { s.unsubscribe(), this._unobserveElement(i) } }) } _observeElement(e) { if (this._observedElements.has(e)) this._observedElements.get(e).count++; else { const i = new be, r = this._mutationObserverFactory.create(o => i.next(o)); r && r.observe(e, { characterData: !0, childList: !0, subtree: !0 }), this._observedElements.set(e, { observer: r, stream: i, count: 1 }) } return this._observedElements.get(e).stream } _unobserveElement(e) { this._observedElements.has(e) && (this._observedElements.get(e).count--, this._observedElements.get(e).count || this._cleanupObserver(e)) } _cleanupObserver(e) { if (this._observedElements.has(e)) { const { observer: i, stream: r } = this._observedElements.get(e); i && i.disconnect(), r.complete(), this._observedElements.delete(e) } } } return n.\u0275fac = function(e) { return new (e || n)(E(Yw)) }, n.\u0275prov = R({ token: n, factory: n.\u0275fac, providedIn: "root" }), n })(), L3 = (() => { class n { constructor(e, i, r) { this._contentObserver = e, this._elementRef = i, this._ngZone = r, this.event = new L, this._disabled = !1, this._currentSubscription = null } get disabled() { return this._disabled } set disabled(e) { this._disabled = gs(e), this._disabled ? this._unsubscribe() : this._subscribe() } get debounce() { return this._debounce } set debounce(e) { this._debounce = bu(e), this._subscribe() } ngAfterContentInit() { !this._currentSubscription && !this.disabled && this._subscribe() } ngOnDestroy() { this._unsubscribe() } _subscribe() { this._unsubscribe(); const e = this._contentObserver.observe(this._elementRef); this._ngZone.runOutsideAngular(() => { this._currentSubscription = (this.debounce ? e.pipe(qw(this.debounce)) : e).subscribe(this.event) }) } _unsubscribe() { var e; null === (e = this._currentSubscription) || void 0 === e || e.unsubscribe() } } return n.\u0275fac = function(e) { return new (e || n)(g(F3), g(X), g(he)) }, n.\u0275dir = S({ type: n, selectors: [["", "cdkObserveContent", ""]], inputs: { disabled: ["cdkObserveContentDisabled", "disabled"], debounce: "debounce" }, outputs: { event: "cdkObserveContent" }, exportAs: ["cdkObserveContent"] }), n })(), Qw = (() => { class n { } return n.\u0275fac = function(e) { return new (e || n) }, n.\u0275mod = se({ type: n }), n.\u0275inj = te({ providers: [Yw] }), n })(); class j3 extends class H3 { constructor(t) { this._items = t, this._activeItemIndex = -1, this._activeItem = null, this._wrap = !1, this._letterKeyStream = new be, this._typeaheadSubscription = Ze.EMPTY, this._vertical = !0, this._allowedModifierKeys = [], this._homeAndEnd = !1, this._skipPredicateFn = e => e.disabled, this._pressedLetters = [], this.tabOut = new be, this.change = new be, t instanceof $o && t.changes.subscribe(e => { if (this._activeItem) { const r = e.toArray().indexOf(this._activeItem); r > -1 && r !== this._activeItemIndex && (this._activeItemIndex = r) } }) } skipPredicate(t) { return this._skipPredicateFn = t, this } withWrap(t = !0) { return this._wrap = t, this } withVerticalOrientation(t = !0) { return this._vertical = t, this } withHorizontalOrientation(t) { return this._horizontal = t, this } withAllowedModifierKeys(t) { return this._allowedModifierKeys = t, this } withTypeAhead(t = 200) { return this._typeaheadSubscription.unsubscribe(), this._typeaheadSubscription = this._letterKeyStream.pipe(_t(e => this._pressedLetters.push(e)), qw(t), jt(() => this._pressedLetters.length > 0), W(() => this._pressedLetters.join(""))).subscribe(e => { const i = this._getItemsArray(); for (let r = 1; r < i.length + 1; r++) { const o = (this._activeItemIndex + r) % i.length, s = i[o]; if (!this._skipPredicateFn(s) && 0 === s.getLabel().toUpperCase().trim().indexOf(e)) { this.setActiveItem(o); break } } this._pressedLetters = [] }), this } withHomeAndEnd(t = !0) { return this._homeAndEnd = t, this } setActiveItem(t) { const e = this._activeItem; this.updateActiveItem(t), this._activeItem !== e && this.change.next(this._activeItemIndex) } onKeydown(t) { const e = t.keyCode, r = ["altKey", "ctrlKey", "metaKey", "shiftKey"].every(o => !t[o] || this._allowedModifierKeys.indexOf(o) > -1); switch (e) { case 9: return void this.tabOut.next(); case 40: if (this._vertical && r) { this.setNextItemActive(); break } return; case 38: if (this._vertical && r) { this.setPreviousItemActive(); break } return; case 39: if (this._horizontal && r) { "rtl" === this._horizontal ? this.setPreviousItemActive() : this.setNextItemActive(); break } return; case 37: if (this._horizontal && r) { "rtl" === this._horizontal ? this.setNextItemActive() : this.setPreviousItemActive(); break } return; case 36: if (this._homeAndEnd && r) { this.setFirstItemActive(); break } return; case 35: if (this._homeAndEnd && r) { this.setLastItemActive(); break } return; default: return void ((r || Kw(t, "shiftKey")) && (t.key && 1 === t.key.length ? this._letterKeyStream.next(t.key.toLocaleUpperCase()) : (e >= 65 && e <= 90 || e >= 48 && e <= 57) && this._letterKeyStream.next(String.fromCharCode(e)))) }this._pressedLetters = [], t.preventDefault() } get activeItemIndex() { return this._activeItemIndex } get activeItem() { return this._activeItem } isTyping() { return this._pressedLetters.length > 0 } setFirstItemActive() { this._setActiveItemByIndex(0, 1) } setLastItemActive() { this._setActiveItemByIndex(this._items.length - 1, -1) } setNextItemActive() { this._activeItemIndex < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1) } setPreviousItemActive() { this._activeItemIndex < 0 && this._wrap ? this.setLastItemActive() : this._setActiveItemByDelta(-1) } updateActiveItem(t) { const e = this._getItemsArray(), i = "number" == typeof t ? t : e.indexOf(t), r = e[i]; this._activeItem = null == r ? null : r, this._activeItemIndex = i } _setActiveItemByDelta(t) { this._wrap ? this._setActiveInWrapMode(t) : this._setActiveInDefaultMode(t) } _setActiveInWrapMode(t) { const e = this._getItemsArray(); for (let i = 1; i <= e.length; i++) { const r = (this._activeItemIndex + t * i + e.length) % e.length; if (!this._skipPredicateFn(e[r])) return void this.setActiveItem(r) } } _setActiveInDefaultMode(t) { this._setActiveItemByIndex(this._activeItemIndex + t, t) } _setActiveItemByIndex(t, e) { const i = this._getItemsArray(); if (i[t]) { for (; this._skipPredicateFn(i[t]);)if (!i[t += e]) return; this.setActiveItem(t) } } _getItemsArray() { return this._items instanceof $o ? this._items.toArray() : this._items } }{ constructor() { super(...arguments), this._origin = "program" } setFocusOrigin(t) { return this._origin = t, this } setActiveItem(t) { super.setActiveItem(t), this.activeItem && this.activeItem.focus(this._origin) } } function eT(n) { return 0 === n.buttons || 0 === n.offsetX && 0 === n.offsetY } function tT(n) { const t = n.touches && n.touches[0] || n.changedTouches && n.changedTouches[0]; return !(!t || -1 !== t.identifier || null != t.radiusX && 1 !== t.radiusX || null != t.radiusY && 1 !== t.radiusY) } const K3 = new P("cdk-input-modality-detector-options"), q3 = { ignoreKeys: [18, 17, 224, 91, 16] }, ms = mu({ passive: !0, capture: !0 }); let Y3 = (() => { class n { constructor(e, i, r, o) { this._platform = e, this._mostRecentTarget = null, this._modality = new gt(null), this._lastTouchMs = 0, this._onKeydown = s => { var a, l; (null === (l = null === (a = this._options) || void 0 === a ? void 0 : a.ignoreKeys) || void 0 === l ? void 0 : l.some(c => c === s.keyCode)) || (this._modality.next("keyboard"), this._mostRecentTarget = Za(s)) }, this._onMousedown = s => { Date.now() - this._lastTouchMs < 650 || (this._modality.next(eT(s) ? "keyboard" : "mouse"), this._mostRecentTarget = Za(s)) }, this._onTouchstart = s => { tT(s) ? this._modality.next("keyboard") : (this._lastTouchMs = Date.now(), this._modality.next("touch"), this._mostRecentTarget = Za(s)) }, this._options = Object.assign(Object.assign({}, q3), o), this.modalityDetected = this._modality.pipe(function AC(n) { return jt((t, e) => n <= e) }(1)), this.modalityChanged = this.modalityDetected.pipe(Oa()), e.isBrowser && i.runOutsideAngular(() => { r.addEventListener("keydown", this._onKeydown, ms), r.addEventListener("mousedown", this._onMousedown, ms), r.addEventListener("touchstart", this._onTouchstart, ms) }) } get mostRecentModality() { return this._modality.value } ngOnDestroy() { this._modality.complete(), this._platform.isBrowser && (document.removeEventListener("keydown", this._onKeydown, ms), document.removeEventListener("mousedown", this._onMousedown, ms), document.removeEventListener("touchstart", this._onTouchstart, ms)) } } return n.\u0275fac = function(e) { return new (e || n)(E(ar), E(he), E(De), E(K3, 8)) }, n.\u0275prov = R({ token: n, factory: n.\u0275fac, providedIn: "root" }), n })(); const J3 = new P("cdk-focus-monitor-default-options"), vu = mu({ passive: !0, capture: !0 }); let iT = (() => { class n { constructor(e, i, r, o, s) { this._ngZone = e, this._platform = i, this._inputModalityDetector = r, this._origin = null, this._windowFocused = !1, this._originFromTouchInteraction = !1, this._elementInfo = new Map, this._monitoredElementCount = 0, this._rootNodeFocusListenerCount = new Map, this._windowFocusListener = () => { this._windowFocused = !0, this._windowFocusTimeoutId = window.setTimeout(() => this._windowFocused = !1) }, this._stopInputModalityDetector = new be, this._rootNodeFocusAndBlurListener = a => { const l = Za(a), c = "focus" === a.type ? this._onFocus : this._onBlur; for (let u = l; u; u = u.parentElement)c.call(this, a, u) }, this._document = o, this._detectionMode = (null == s ? void 0 : s.detectionMode) || 0 } monitor(e, i = !1) { const r = _s(e); if (!this._platform.isBrowser || 1 !== r.nodeType) return U(null); const o = function g3(n) { if (function p3() { if (null == Cg) { const n = "undefined" != typeof document ? document.head : null; Cg = !(!n || !n.createShadowRoot && !n.attachShadow) } return Cg }()) { const t = n.getRootNode ? n.getRootNode() : null; if ("undefined" != typeof ShadowRoot && ShadowRoot && t instanceof ShadowRoot) return t } return null }(r) || this._getDocument(), s = this._elementInfo.get(r); if (s) return i && (s.checkChildren = !0), s.subject; const a = { checkChildren: i, subject: new be, rootNode: o }; return this._elementInfo.set(r, a), this._registerGlobalListeners(a), a.subject } stopMonitoring(e) { const i = _s(e), r = this._elementInfo.get(i); r && (r.subject.complete(), this._setClasses(i), this._elementInfo.delete(i), this._removeGlobalListeners(r)) } focusVia(e, i, r) { const o = _s(e); o === this._getDocument().activeElement ? this._getClosestElementsInfo(o).forEach(([a, l]) => this._originChanged(a, i, l)) : (this._setOrigin(i), "function" == typeof o.focus && o.focus(r)) } ngOnDestroy() { this._elementInfo.forEach((e, i) => this.stopMonitoring(i)) } _getDocument() { return this._document || document } _getWindow() { return this._getDocument().defaultView || window } _getFocusOrigin(e) { return this._origin ? this._originFromTouchInteraction ? this._shouldBeAttributedToTouch(e) ? "touch" : "program" : this._origin : this._windowFocused && this._lastFocusOrigin ? this._lastFocusOrigin : "program" } _shouldBeAttributedToTouch(e) { return 1 === this._detectionMode || !!(null == e ? void 0 : e.contains(this._inputModalityDetector._mostRecentTarget)) } _setClasses(e, i) { e.classList.toggle("cdk-focused", !!i), e.classList.toggle("cdk-touch-focused", "touch" === i), e.classList.toggle("cdk-keyboard-focused", "keyboard" === i), e.classList.toggle("cdk-mouse-focused", "mouse" === i), e.classList.toggle("cdk-program-focused", "program" === i) } _setOrigin(e, i = !1) { this._ngZone.runOutsideAngular(() => { this._origin = e, this._originFromTouchInteraction = "touch" === e && i, 0 === this._detectionMode && (clearTimeout(this._originTimeoutId), this._originTimeoutId = setTimeout(() => this._origin = null, this._originFromTouchInteraction ? 650 : 1)) }) } _onFocus(e, i) { const r = this._elementInfo.get(i), o = Za(e); !r || !r.checkChildren && i !== o || this._originChanged(i, this._getFocusOrigin(o), r) } _onBlur(e, i) { const r = this._elementInfo.get(i); !r || r.checkChildren && e.relatedTarget instanceof Node && i.contains(e.relatedTarget) || (this._setClasses(i), this._emitOrigin(r.subject, null)) } _emitOrigin(e, i) { this._ngZone.run(() => e.next(i)) } _registerGlobalListeners(e) { if (!this._platform.isBrowser) return; const i = e.rootNode, r = this._rootNodeFocusListenerCount.get(i) || 0; r || this._ngZone.runOutsideAngular(() => { i.addEventListener("focus", this._rootNodeFocusAndBlurListener, vu), i.addEventListener("blur", this._rootNodeFocusAndBlurListener, vu) }), this._rootNodeFocusListenerCount.set(i, r + 1), 1 == ++this._monitoredElementCount && (this._ngZone.runOutsideAngular(() => { this._getWindow().addEventListener("focus", this._windowFocusListener) }), this._inputModalityDetector.modalityDetected.pipe(Le(this._stopInputModalityDetector)).subscribe(o => { this._setOrigin(o, !0) })) } _removeGlobalListeners(e) { const i = e.rootNode; if (this._rootNodeFocusListenerCount.has(i)) { const r = this._rootNodeFocusListenerCount.get(i); r > 1 ? this._rootNodeFocusListenerCount.set(i, r - 1) : (i.removeEventListener("focus", this._rootNodeFocusAndBlurListener, vu), i.removeEventListener("blur", this._rootNodeFocusAndBlurListener, vu), this._rootNodeFocusListenerCount.delete(i)) } --this._monitoredElementCount || (this._getWindow().removeEventListener("focus", this._windowFocusListener), this._stopInputModalityDetector.next(), clearTimeout(this._windowFocusTimeoutId), clearTimeout(this._originTimeoutId)) } _originChanged(e, i, r) { this._setClasses(e, i), this._emitOrigin(r.subject, i), this._lastFocusOrigin = i } _getClosestElementsInfo(e) { const i = []; return this._elementInfo.forEach((r, o) => { (o === e || r.checkChildren && o.contains(e)) && i.push([o, r]) }), i } } return n.\u0275fac = function(e) { return new (e || n)(E(he), E(ar), E(Y3), E(De, 8), E(J3, 8)) }, n.\u0275prov = R({ token: n, factory: n.\u0275fac, providedIn: "root" }), n })(), Z3 = (() => { class n { constructor(e, i) { this._elementRef = e, this._focusMonitor = i, this.cdkFocusChange = new L } ngAfterViewInit() { const e = this._elementRef.nativeElement; this._monitorSubscription = this._focusMonitor.monitor(e, 1 === e.nodeType && e.hasAttribute("cdkMonitorSubtreeFocus")).subscribe(i => this.cdkFocusChange.emit(i)) } ngOnDestroy() { this._focusMonitor.stopMonitoring(this._elementRef), this._monitorSubscription && this._monitorSubscription.unsubscribe() } } return n.\u0275fac = function(e) { return new (e || n)(g(X), g(iT)) }, n.\u0275dir = S({ type: n, selectors: [["", "cdkMonitorElementFocus", ""], ["", "cdkMonitorSubtreeFocus", ""]], outputs: { cdkFocusChange: "cdkFocusChange" } }), n })(); const rT = "cdk-high-contrast-black-on-white", oT = "cdk-high-contrast-white-on-black", Eg = "cdk-high-contrast-active"; let sT = (() => { class n { constructor(e, i) { this._platform = e, this._document = i } getHighContrastMode() { if (!this._platform.isBrowser) return 0; const e = this._document.createElement("div"); e.style.backgroundColor = "rgb(1,2,3)", e.style.position = "absolute", this._document.body.appendChild(e); const i = this._document.defaultView || window, r = i && i.getComputedStyle ? i.getComputedStyle(e) : null, o = (r && r.backgroundColor || "").replace(/ /g, ""); switch (e.remove(), o) { case "rgb(0,0,0)": return 2; case "rgb(255,255,255)": return 1 }return 0 } _applyBodyHighContrastModeCssClasses() { if (!this._hasCheckedHighContrastMode && this._platform.isBrowser && this._document.body) { const e = this._document.body.classList; e.remove(Eg), e.remove(rT), e.remove(oT), this._hasCheckedHighContrastMode = !0; const i = this.getHighContrastMode(); 1 === i ? (e.add(Eg), e.add(rT)) : 2 === i && (e.add(Eg), e.add(oT)) } } } return n.\u0275fac = function(e) { return new (e || n)(E(ar), E(De)) }, n.\u0275prov = R({ token: n, factory: n.\u0275fac, providedIn: "root" }), n })(), X3 = (() => { class n { constructor(e) { e._applyBodyHighContrastModeCssClasses() } } return n.\u0275fac = function(e) { return new (e || n)(E(sT)) }, n.\u0275mod = se({ type: n }), n.\u0275inj = te({ imports: [[Qw]] }), n })(); class wg { attach(t) { return this._attachedHost = t, t.attach(this) } detach() { let t = this._attachedHost; null != t && (this._attachedHost = null, t.detach()) } get isAttached() { return null != this._attachedHost } setAttachedHost(t) { this._attachedHost = t } } class e8 extends wg { constructor(t, e, i, r) { super(), this.component = t, this.viewContainerRef = e, this.injector = i, this.componentFactoryResolver = r } } class Tg extends wg { constructor(t, e, i) { super(), this.templateRef = t, this.viewContainerRef = e, this.context = i } get origin() { return this.templateRef.elementRef } attach(t, e = this.context) { return this.context = e, super.attach(t) } detach() { return this.context = void 0, super.detach() } } class t8 extends wg { constructor(t) { super(), this.element = t instanceof X ? t.nativeElement : t } } let i8 = (() => { class n extends Tg { constructor(e, i) { super(e, i) } } return n.\u0275fac = function(e) { return new (e || n)(g(ke), g(Rt)) }, n.\u0275dir = S({ type: n, selectors: [["", "cdkPortal", ""]], exportAs: ["cdkPortal"], features: [ie] }), n })(), Sg = (() => { class n extends class n8 { constructor() { this._isDisposed = !1, this.attachDomPortal = null } hasAttached() { return !!this._attachedPortal } attach(t) { return t instanceof e8 ? (this._attachedPortal = t, this.attachComponentPortal(t)) : t instanceof Tg ? (this._attachedPortal = t, this.attachTemplatePortal(t)) : this.attachDomPortal && t instanceof t8 ? (this._attachedPortal = t, this.attachDomPortal(t)) : void 0 } detach() { this._attachedPortal && (this._attachedPortal.setAttachedHost(null), this._attachedPortal = null), this._invokeDisposeFn() } dispose() { this.hasAttached() && this.detach(), this._invokeDisposeFn(), this._isDisposed = !0 } setDisposeFn(t) { this._disposeFn = t } _invokeDisposeFn() { this._disposeFn && (this._disposeFn(), this._disposeFn = null) } }{ constructor(e, i, r) { super(), this._componentFactoryResolver = e, this._viewContainerRef = i, this._isInitialized = !1, this.attached = new L, this.attachDomPortal = o => { const s = o.element, a = this._document.createComment("dom-portal"); o.setAttachedHost(this), s.parentNode.insertBefore(a, s), this._getRootNode().appendChild(s), this._attachedPortal = o, super.setDisposeFn(() => { a.parentNode && a.parentNode.replaceChild(s, a) }) }, this._document = r } get portal() { return this._attachedPortal } set portal(e) { this.hasAttached() && !e && !this._isInitialized || (this.hasAttached() && super.detach(), e && super.attach(e), this._attachedPortal = e || null) } get attachedRef() { return this._attachedRef } ngOnInit() { this._isInitialized = !0 } ngOnDestroy() { super.dispose(), this._attachedPortal = null, this._attachedRef = null } attachComponentPortal(e) { e.setAttachedHost(this); const i = null != e.viewContainerRef ? e.viewContainerRef : this._viewContainerRef, o = (e.componentFactoryResolver || this._componentFactoryResolver).resolveComponentFactory(e.component), s = i.createComponent(o, i.length, e.injector || i.injector); return i !== this._viewContainerRef && this._getRootNode().appendChild(s.hostView.rootNodes[0]), super.setDisposeFn(() => s.destroy()), this._attachedPortal = e, this._attachedRef = s, this.attached.emit(s), s } attachTemplatePortal(e) { e.setAttachedHost(this); const i = this._viewContainerRef.createEmbeddedView(e.templateRef, e.context); return super.setDisposeFn(() => this._viewContainerRef.clear()), this._attachedPortal = e, this._attachedRef = i, this.attached.emit(i), i } _getRootNode() { const e = this._viewContainerRef.element.nativeElement; return e.nodeType === e.ELEMENT_NODE ? e : e.parentNode } } return n.\u0275fac = function(e) { return new (e || n)(g(wi), g(Rt), g(De)) }, n.\u0275dir = S({ type: n, selectors: [["", "cdkPortalOutlet", ""]], inputs: { portal: ["cdkPortalOutlet", "portal"] }, outputs: { attached: "attached" }, exportAs: ["cdkPortalOutlet"], features: [ie] }), n })(), r8 = (() => { class n { } return n.\u0275fac = function(e) { return new (e || n) }, n.\u0275mod = se({ type: n }), n.\u0275inj = te({}), n })(); const o8 = new P("cdk-dir-doc", { providedIn: "root", factory: function s8() { return Fd(De) } }), a8 = /^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)/i; let Xa = (() => { class n { constructor(e) { if (this.value = "ltr", this.change = new L, e) { const r = e.documentElement ? e.documentElement.dir : null; this.value = function l8(n) { const t = (null == n ? void 0 : n.toLowerCase()) || ""; return "auto" === t && "undefined" != typeof navigator && (null == navigator ? void 0 : navigator.language) ? a8.test(navigator.language) ? "rtl" : "ltr" : "rtl" === t ? "rtl" : "ltr" }((e.body ? e.body.dir : null) || r || "ltr") } } ngOnDestroy() { this.change.complete() } } return n.\u0275fac = function(e) { return new (e || n)(E(o8, 8)) }, n.\u0275prov = R({ token: n, factory: n.\u0275fac, providedIn: "root" }), n })(), aT = (() => { class n { } return n.\u0275fac = function(e) { return new (e || n) }, n.\u0275mod = se({ type: n }), n.\u0275inj = te({}), n })(); class cT { } const Fi = "*"; function u8(n, t) { return { type: 7, name: n, definitions: t, options: {} } } function Ag(n, t = null) { return { type: 4, styles: t, timings: n } } function uT(n, t = null) { return { type: 2, steps: n, options: t } } function Ur(n) { return { type: 6, styles: n, offset: null } } function Mg(n, t, e) { return { type: 0, name: n, styles: t, options: e } } function Ng(n, t, e = null) { return { type: 1, expr: n, animation: t, options: e } } function dT(n) { Promise.resolve(null).then(n) } class ys { constructor(t = 0, e = 0) { this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._started = !1, this._destroyed = !1, this._finished = !1, this._position = 0, this.parentPlayer = null, this.totalTime = t + e } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(t => t()), this._onDoneFns = []) } onStart(t) { this._onStartFns.push(t) } onDone(t) { this._onDoneFns.push(t) } onDestroy(t) { this._onDestroyFns.push(t) } hasStarted() { return this._started } init() { } play() { this.hasStarted() || (this._onStart(), this.triggerMicrotask()), this._started = !0 } triggerMicrotask() { dT(() => this._onFinish()) } _onStart() { this._onStartFns.forEach(t => t()), this._onStartFns = [] } pause() { } restart() { } finish() { this._onFinish() } destroy() { this._destroyed || (this._destroyed = !0, this.hasStarted() || this._onStart(), this.finish(), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = []) } reset() { this._started = !1 } setPosition(t) { this._position = this.totalTime ? t * this.totalTime : 1 } getPosition() { return this.totalTime ? this._position / this.totalTime : 1 } triggerCallback(t) { const e = "start" == t ? this._onStartFns : this._onDoneFns; e.forEach(i => i()), e.length = 0 } } class hT { constructor(t) { this._onDoneFns = [], this._onStartFns = [], this._finished = !1, this._started = !1, this._destroyed = !1, this._onDestroyFns = [], this.parentPlayer = null, this.totalTime = 0, this.players = t; let e = 0, i = 0, r = 0; const o = this.players.length; 0 == o ? dT(() => this._onFinish()) : this.players.forEach(s => { s.onDone(() => { ++e == o && this._onFinish() }), s.onDestroy(() => { ++i == o && this._onDestroy() }), s.onStart(() => { ++r == o && this._onStart() }) }), this.totalTime = this.players.reduce((s, a) => Math.max(s, a.totalTime), 0) } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(t => t()), this._onDoneFns = []) } init() { this.players.forEach(t => t.init()) } onStart(t) { this._onStartFns.push(t) } _onStart() { this.hasStarted() || (this._started = !0, this._onStartFns.forEach(t => t()), this._onStartFns = []) } onDone(t) { this._onDoneFns.push(t) } onDestroy(t) { this._onDestroyFns.push(t) } hasStarted() { return this._started } play() { this.parentPlayer || this.init(), this._onStart(), this.players.forEach(t => t.play()) } pause() { this.players.forEach(t => t.pause()) } restart() { this.players.forEach(t => t.restart()) } finish() { this._onFinish(), this.players.forEach(t => t.finish()) } destroy() { this._onDestroy() } _onDestroy() { this._destroyed || (this._destroyed = !0, this._onFinish(), this.players.forEach(t => t.destroy()), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = []) } reset() { this.players.forEach(t => t.reset()), this._destroyed = !1, this._finished = !1, this._started = !1 } setPosition(t) { const e = t * this.totalTime; this.players.forEach(i => { const r = i.totalTime ? Math.min(1, e / i.totalTime) : 1; i.setPosition(r) }) } getPosition() { const t = this.players.reduce((e, i) => null === e || i.totalTime > e.totalTime ? i : e, null); return null != t ? t.getPosition() : 0 } beforeDestroy() { this.players.forEach(t => { t.beforeDestroy && t.beforeDestroy() }) } triggerCallback(t) { const e = "start" == t ? this._onStartFns : this._onDoneFns; e.forEach(i => i()), e.length = 0 } } function fT() { return "undefined" != typeof window && void 0 !== window.document } function Rg() { return "undefined" != typeof process && "[object process]" === {}.toString.call(process) } function lr(n) { switch (n.length) { case 0: return new ys; case 1: return n[0]; default: return new hT(n) } } function pT(n, t, e, i, r = {}, o = {}) { const s = [], a = []; let l = -1, c = null; if (i.forEach(u => { const d = u.offset, h = d == l, f = h && c || {}; Object.keys(u).forEach(p => { let _ = p, y = u[p]; if ("offset" !== p) switch (_ = t.normalizePropertyName(_, s), y) { case "!": y = r[p]; break; case Fi: y = o[p]; break; default: y = t.normalizeStyleValue(p, _, y, s) }f[_] = y }), h || a.push(f), c = f, l = d }), s.length) { const u = "\n - "; throw new Error(`Unable to animate due to the following errors:${u}${s.join(u)}`) } return a } function Og(n, t, e, i) { switch (t) { case "start": n.onStart(() => i(e && xg(e, "start", n))); break; case "done": n.onDone(() => i(e && xg(e, "done", n))); break; case "destroy": n.onDestroy(() => i(e && xg(e, "destroy", n))) } } function xg(n, t, e) { const i = e.totalTime, o = Pg(n.element, n.triggerName, n.fromState, n.toState, t || n.phaseName, null == i ? n.totalTime : i, !!e.disabled), s = n._data; return null != s && (o._data = s), o } function Pg(n, t, e, i, r = "", o = 0, s) { return { element: n, triggerName: t, fromState: e, toState: i, phaseName: r, totalTime: o, disabled: !!s } } function ln(n, t, e) { let i; return n instanceof Map ? (i = n.get(t), i || n.set(t, i = e)) : (i = n[t], i || (i = n[t] = e)), i } function gT(n) { const t = n.indexOf(":"); return [n.substring(1, t), n.substr(t + 1)] } let kg = (n, t) => !1, _T = (n, t, e) => []; (Rg() || "undefined" != typeof Element) && (kg = fT() ? (n, t) => { for (; t && t !== document.documentElement;) { if (t === n) return !0; t = t.parentNode || t.host } return !1 } : (n, t) => n.contains(t), _T = (n, t, e) => { if (e) return Array.from(n.querySelectorAll(t)); const i = n.querySelector(t); return i ? [i] : [] }); let $r = null, mT = !1; function Fg(n) { $r || ($r = function h8() { return "undefined" != typeof document ? document.body : null }() || {}, mT = !!$r.style && "WebkitAppearance" in $r.style); let t = !0; return $r.style && !function d8(n) { return "ebkit" == n.substring(1, 6) }(n) && (t = n in $r.style, !t && mT && (t = "Webkit" + n.charAt(0).toUpperCase() + n.substr(1) in $r.style)), t } const Lg = kg, Bg = _T; function yT(n) { const t = {}; return Object.keys(n).forEach(e => { const i = e.replace(/([a-z])([A-Z])/g, "$1-$2"); t[i] = n[e] }), t } let bT = (() => { class n { validateStyleProperty(e) { return Fg(e) } matchesElement(e, i) { return !1 } containsElement(e, i) { return Lg(e, i) } query(e, i, r) { return Bg(e, i, r) } computeStyle(e, i, r) { return r || "" } animate(e, i, r, o, s, a = [], l) { return new ys(r, o) } } return n.\u0275fac = function(e) { return new (e || n) }, n.\u0275prov = R({ token: n, factory: n.\u0275fac }), n })(), Vg = (() => { class n { } return n.NOOP = new bT, n })(); const Hg = "ng-enter", Du = "ng-leave", Cu = "ng-trigger", Eu = ".ng-trigger", DT = "ng-animating", jg = ".ng-animating"; function Gr(n) { if ("number" == typeof n) return n; const t = n.match(/^(-?[\.\d]+)(m?s)/); return !t || t.length < 2 ? 0 : Ug(parseFloat(t[1]), t[2]) } function Ug(n, t) { return "s" === t ? 1e3 * n : n } function wu(n, t, e) { return n.hasOwnProperty("duration") ? n : function g8(n, t, e) { let r, o = 0, s = ""; if ("string" == typeof n) { const a = n.match(/^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i); if (null === a) return t.push(`The provided timing value "${n}" is invalid.`), { duration: 0, delay: 0, easing: "" }; r = Ug(parseFloat(a[1]), a[2]); const l = a[3]; null != l && (o = Ug(parseFloat(l), a[4])); const c = a[5]; c && (s = c) } else r = n; if (!e) { let a = !1, l = t.length; r < 0 && (t.push("Duration values below 0 are not allowed for this animation step."), a = !0), o < 0 && (t.push("Delay values below 0 are not allowed for this animation step."), a = !0), a && t.splice(l, 0, `The provided timing value "${n}" is invalid.`) } return { duration: r, delay: o, easing: s } }(n, t, e) } function bs(n, t = {}) { return Object.keys(n).forEach(e => { t[e] = n[e] }), t } function cr(n, t, e = {}) { if (t) for (let i in n) e[i] = n[i]; else bs(n, e); return e } function ET(n, t, e) { return e ? t + ":" + e + ";" : "" } function wT(n) { let t = ""; for (let e = 0; e < n.style.length; e++) { const i = n.style.item(e); t += ET(0, i, n.style.getPropertyValue(i)) } for (const e in n.style) n.style.hasOwnProperty(e) && !e.startsWith("_") && (t += ET(0, y8(e), n.style[e])); n.setAttribute("style", t) } function fi(n, t, e) { n.style && (Object.keys(t).forEach(i => { const r = Gg(i); e && !e.hasOwnProperty(i) && (e[i] = n.style[r]), n.style[r] = t[i] }), Rg() && wT(n)) } function Wr(n, t) { n.style && (Object.keys(t).forEach(e => { const i = Gg(e); n.style[i] = "" }), Rg() && wT(n)) } function el(n) { return Array.isArray(n) ? 1 == n.length ? n[0] : uT(n) : n } const $g = new RegExp("{{\\s*(.+?)\\s*}}", "g"); function TT(n) { let t = []; if ("string" == typeof n) { let e; for (; e = $g.exec(n);)t.push(e[1]); $g.lastIndex = 0 } return t } function Tu(n, t, e) { const i = n.toString(), r = i.replace($g, (o, s) => { let a = t[s]; return t.hasOwnProperty(s) || (e.push(`Please provide a value for the animation param ${s}`), a = ""), a.toString() }); return r == i ? n : r } function Su(n) { const t = []; let e = n.next(); for (; !e.done;)t.push(e.value), e = n.next(); return t } const m8 = /-+([a-z0-9])/g; function Gg(n) { return n.replace(m8, (...t) => t[1].toUpperCase()) } function y8(n) { return n.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase() } function ST(n, t) { return 0 === n || 0 === t } function AT(n, t, e) { const i = Object.keys(e); if (i.length && t.length) { let o = t[0], s = []; if (i.forEach(a => { o.hasOwnProperty(a) || s.push(a), o[a] = e[a] }), s.length) for (var r = 1; r < t.length; r++) { let a = t[r]; s.forEach(function(l) { a[l] = Wg(n, l) }) } } return t } function cn(n, t, e) { switch (t.type) { case 7: return n.visitTrigger(t, e); case 0: return n.visitState(t, e); case 1: return n.visitTransition(t, e); case 2: return n.visitSequence(t, e); case 3: return n.visitGroup(t, e); case 4: return n.visitAnimate(t, e); case 5: return n.visitKeyframes(t, e); case 6: return n.visitStyle(t, e); case 8: return n.visitReference(t, e); case 9: return n.visitAnimateChild(t, e); case 10: return n.visitAnimateRef(t, e); case 11: return n.visitQuery(t, e); case 12: return n.visitStagger(t, e); default: throw new Error(`Unable to resolve animation metadata node #${t.type}`) } } function Wg(n, t) { return window.getComputedStyle(n)[t] } function b8(n, t) { const e = []; return "string" == typeof n ? n.split(/\s*,\s*/).forEach(i => function v8(n, t, e) { if (":" == n[0]) { const l = function D8(n, t) { switch (n) { case ":enter": return "void => *"; case ":leave": return "* => void"; case ":increment": return (e, i) => parseFloat(i) > parseFloat(e); case ":decrement": return (e, i) => parseFloat(i) < parseFloat(e); default: return t.push(`The transition alias value "${n}" is not supported`), "* => *" } }(n, e); if ("function" == typeof l) return void t.push(l); n = l } const i = n.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/); if (null == i || i.length < 4) return e.push(`The provided transition expression "${n}" is not supported`), t; const r = i[1], o = i[2], s = i[3]; t.push(MT(r, s)); "<" == o[0] && !("*" == r && "*" == s) && t.push(MT(s, r)) }(i, e, t)) : e.push(n), e } const Mu = new Set(["true", "1"]), Nu = new Set(["false", "0"]); function MT(n, t) { const e = Mu.has(n) || Nu.has(n), i = Mu.has(t) || Nu.has(t); return (r, o) => { let s = "*" == n || n == r, a = "*" == t || t == o; return !s && e && "boolean" == typeof r && (s = r ? Mu.has(n) : Nu.has(n)), !a && i && "boolean" == typeof o && (a = o ? Mu.has(t) : Nu.has(t)), s && a } } const C8 = new RegExp("s*:selfs*,?", "g"); function zg(n, t, e) { return new E8(n).build(t, e) } class E8 { constructor(t) { this._driver = t } build(t, e) { const i = new S8(e); return this._resetContextStyleTimingState(i), cn(this, el(t), i) } _resetContextStyleTimingState(t) { t.currentQuerySelector = "", t.collectedStyles = {}, t.collectedStyles[""] = {}, t.currentTime = 0 } visitTrigger(t, e) { let i = e.queryCount = 0, r = e.depCount = 0; const o = [], s = []; return "@" == t.name.charAt(0) && e.errors.push("animation triggers cannot be prefixed with an `@` sign (e.g. trigger('@foo', [...]))"), t.definitions.forEach(a => { if (this._resetContextStyleTimingState(e), 0 == a.type) { const l = a, c = l.name; c.toString().split(/\s*,\s*/).forEach(u => { l.name = u, o.push(this.visitState(l, e)) }), l.name = c } else if (1 == a.type) { const l = this.visitTransition(a, e); i += l.queryCount, r += l.depCount, s.push(l) } else e.errors.push("only state() and transition() definitions can sit inside of a trigger()") }), { type: 7, name: t.name, states: o, transitions: s, queryCount: i, depCount: r, options: null } } visitState(t, e) { const i = this.visitStyle(t.styles, e), r = t.options && t.options.params || null; if (i.containsDynamicStyles) { const o = new Set, s = r || {}; if (i.styles.forEach(a => { if (Iu(a)) { const l = a; Object.keys(l).forEach(c => { TT(l[c]).forEach(u => { s.hasOwnProperty(u) || o.add(u) }) }) } }), o.size) { const a = Su(o.values()); e.errors.push(`state("${t.name}", ...) must define default values for all the following style substitutions: ${a.join(", ")}`) } } return { type: 0, name: t.name, style: i, options: r ? { params: r } : null } } visitTransition(t, e) { e.queryCount = 0, e.depCount = 0; const i = cn(this, el(t.animation), e); return { type: 1, matchers: b8(t.expr, e.errors), animation: i, queryCount: e.queryCount, depCount: e.depCount, options: zr(t.options) } } visitSequence(t, e) { return { type: 2, steps: t.steps.map(i => cn(this, i, e)), options: zr(t.options) } } visitGroup(t, e) { const i = e.currentTime; let r = 0; const o = t.steps.map(s => { e.currentTime = i; const a = cn(this, s, e); return r = Math.max(r, e.currentTime), a }); return e.currentTime = r, { type: 3, steps: o, options: zr(t.options) } } visitAnimate(t, e) { const i = function M8(n, t) { let e = null; if (n.hasOwnProperty("duration")) e = n; else if ("number" == typeof n) return Kg(wu(n, t).duration, 0, ""); const i = n; if (i.split(/\s+/).some(o => "{" == o.charAt(0) && "{" == o.charAt(1))) { const o = Kg(0, 0, ""); return o.dynamic = !0, o.strValue = i, o } return e = e || wu(i, t), Kg(e.duration, e.delay, e.easing) }(t.timings, e.errors); e.currentAnimateTimings = i; let r, o = t.styles ? t.styles : Ur({}); if (5 == o.type) r = this.visitKeyframes(o, e); else { let s = t.styles, a = !1; if (!s) { a = !0; const c = {}; i.easing && (c.easing = i.easing), s = Ur(c) } e.currentTime += i.duration + i.delay; const l = this.visitStyle(s, e); l.isEmptyStep = a, r = l } return e.currentAnimateTimings = null, { type: 4, timings: i, style: r, options: null } } visitStyle(t, e) { const i = this._makeStyleAst(t, e); return this._validateStyleAst(i, e), i } _makeStyleAst(t, e) { const i = []; Array.isArray(t.styles) ? t.styles.forEach(s => { "string" == typeof s ? s == Fi ? i.push(s) : e.errors.push(`The provided style string value ${s} is not allowed.`) : i.push(s) }) : i.push(t.styles); let r = !1, o = null; return i.forEach(s => { if (Iu(s)) { const a = s, l = a.easing; if (l && (o = l, delete a.easing), !r) for (let c in a) if (a[c].toString().indexOf("{{") >= 0) { r = !0; break } } }), { type: 6, styles: i, easing: o, offset: t.offset, containsDynamicStyles: r, options: null } } _validateStyleAst(t, e) { const i = e.currentAnimateTimings; let r = e.currentTime, o = e.currentTime; i && o > 0 && (o -= i.duration + i.delay), t.styles.forEach(s => { "string" != typeof s && Object.keys(s).forEach(a => { if (!this._driver.validateStyleProperty(a)) return void e.errors.push(`The provided animation property "${a}" is not a supported CSS property for animations`); const l = e.collectedStyles[e.currentQuerySelector], c = l[a]; let u = !0; c && (o != r && o >= c.startTime && r <= c.endTime && (e.errors.push(`The CSS property "${a}" that exists between the times of "${c.startTime}ms" and "${c.endTime}ms" is also being animated in a parallel animation between the times of "${o}ms" and "${r}ms"`), u = !1), o = c.startTime), u && (l[a] = { startTime: o, endTime: r }), e.options && function _8(n, t, e) { const i = t.params || {}, r = TT(n); r.length && r.forEach(o => { i.hasOwnProperty(o) || e.push(`Unable to resolve the local animation param ${o} in the given list of values`) }) }(s[a], e.options, e.errors) }) }) } visitKeyframes(t, e) { const i = { type: 5, styles: [], options: null }; if (!e.currentAnimateTimings) return e.errors.push("keyframes() must be placed inside of a call to animate()"), i; let o = 0; const s = []; let a = !1, l = !1, c = 0; const u = t.steps.map(b => { const m = this._makeStyleAst(b, e); let C = null != m.offset ? m.offset : function A8(n) { if ("string" == typeof n) return null; let t = null; if (Array.isArray(n)) n.forEach(e => { if (Iu(e) && e.hasOwnProperty("offset")) { const i = e; t = parseFloat(i.offset), delete i.offset } }); else if (Iu(n) && n.hasOwnProperty("offset")) { const e = n; t = parseFloat(e.offset), delete e.offset } return t }(m.styles), T = 0; return null != C && (o++, T = m.offset = C), l = l || T < 0 || T > 1, a = a || T < c, c = T, s.push(T), m }); l && e.errors.push("Please ensure that all keyframe offsets are between 0 and 1"), a && e.errors.push("Please ensure that all keyframe offsets are in order"); const d = t.steps.length; let h = 0; o > 0 && o < d ? e.errors.push("Not all style() steps within the declared keyframes() contain offsets") : 0 == o && (h = 1 / (d - 1)); const f = d - 1, p = e.currentTime, _ = e.currentAnimateTimings, y = _.duration; return u.forEach((b, m) => { const C = h > 0 ? m == f ? 1 : h * m : s[m], T = C * y; e.currentTime = p + _.delay + T, _.duration = T, this._validateStyleAst(b, e), b.offset = C, i.styles.push(b) }), i } visitReference(t, e) { return { type: 8, animation: cn(this, el(t.animation), e), options: zr(t.options) } } visitAnimateChild(t, e) { return e.depCount++, { type: 9, options: zr(t.options) } } visitAnimateRef(t, e) { return { type: 10, animation: this.visitReference(t.animation, e), options: zr(t.options) } } visitQuery(t, e) { const i = e.currentQuerySelector, r = t.options || {}; e.queryCount++, e.currentQuery = t; const [o, s] = function w8(n) { const t = !!n.split(/\s*,\s*/).find(e => ":self" == e); return t && (n = n.replace(C8, "")), n = n.replace(/@\*/g, Eu).replace(/@\w+/g, e => Eu + "-" + e.substr(1)).replace(/:animating/g, jg), [n, t] }(t.selector); e.currentQuerySelector = i.length ? i + " " + o : o, ln(e.collectedStyles, e.currentQuerySelector, {}); const a = cn(this, el(t.animation), e); return e.currentQuery = null, e.currentQuerySelector = i, { type: 11, selector: o, limit: r.limit || 0, optional: !!r.optional, includeSelf: s, animation: a, originalSelector: t.selector, options: zr(t.options) } } visitStagger(t, e) { e.currentQuery || e.errors.push("stagger() can only be used inside of query()"); const i = "full" === t.timings ? { duration: 0, delay: 0, easing: "full" } : wu(t.timings, e.errors, !0); return { type: 12, animation: cn(this, el(t.animation), e), timings: i, options: null } } } class S8 { constructor(t) { this.errors = t, this.queryCount = 0, this.depCount = 0, this.currentTransition = null, this.currentQuery = null, this.currentQuerySelector = null, this.currentAnimateTimings = null, this.currentTime = 0, this.collectedStyles = {}, this.options = null } } function Iu(n) { return !Array.isArray(n) && "object" == typeof n } function zr(n) { return n ? (n = bs(n)).params && (n.params = function T8(n) { return n ? bs(n) : null }(n.params)) : n = {}, n } function Kg(n, t, e) { return { duration: n, delay: t, easing: e } } function qg(n, t, e, i, r, o, s = null, a = !1) { return { type: 1, element: n, keyframes: t, preStyleProps: e, postStyleProps: i, duration: r, delay: o, totalTime: r + o, easing: s, subTimeline: a } } class Ru { constructor() { this._map = new Map } get(t) { return this._map.get(t) || [] } append(t, e) { let i = this._map.get(t); i || this._map.set(t, i = []), i.push(...e) } has(t) { return this._map.has(t) } clear() { this._map.clear() } } const R8 = new RegExp(":enter", "g"), x8 = new RegExp(":leave", "g"); function Yg(n, t, e, i, r, o = {}, s = {}, a, l, c = []) { return (new P8).buildKeyframes(n, t, e, i, r, o, s, a, l, c) } class P8 { buildKeyframes(t, e, i, r, o, s, a, l, c, u = []) { c = c || new Ru; const d = new Qg(t, e, c, r, o, u, []); d.options = l, d.currentTimeline.setStyles([s], null, d.errors, l), cn(this, i, d); const h = d.timelines.filter(f => f.containsAnimation()); if (Object.keys(a).length) { let f; for (let p = h.length - 1; p >= 0; p--) { const _ = h[p]; if (_.element === e) { f = _; break } } f && !f.allowOnlyTimelineStyles() && f.setStyles([a], null, d.errors, l) } return h.length ? h.map(f => f.buildKeyframes()) : [qg(e, [], [], [], 0, 0, "", !1)] } visitTrigger(t, e) { } visitState(t, e) { } visitTransition(t, e) { } visitAnimateChild(t, e) { const i = e.subInstructions.get(e.element); if (i) { const r = e.createSubContext(t.options), o = e.currentTimeline.currentTime, s = this._visitSubInstructions(i, r, r.options); o != s && e.transformIntoNewTimeline(s) } e.previousNode = t } visitAnimateRef(t, e) { const i = e.createSubContext(t.options); i.transformIntoNewTimeline(), this.visitReference(t.animation, i), e.transformIntoNewTimeline(i.currentTimeline.currentTime), e.previousNode = t } _visitSubInstructions(t, e, i) { let o = e.currentTimeline.currentTime; const s = null != i.duration ? Gr(i.duration) : null, a = null != i.delay ? Gr(i.delay) : null; return 0 !== s && t.forEach(l => { const c = e.appendInstructionToTimeline(l, s, a); o = Math.max(o, c.duration + c.delay) }), o } visitReference(t, e) { e.updateOptions(t.options, !0), cn(this, t.animation, e), e.previousNode = t } visitSequence(t, e) { const i = e.subContextCount; let r = e; const o = t.options; if (o && (o.params || o.delay) && (r = e.createSubContext(o), r.transformIntoNewTimeline(), null != o.delay)) { 6 == r.previousNode.type && (r.currentTimeline.snapshotCurrentStyles(), r.previousNode = Ou); const s = Gr(o.delay); r.delayNextStep(s) } t.steps.length && (t.steps.forEach(s => cn(this, s, r)), r.currentTimeline.applyStylesToKeyframe(), r.subContextCount > i && r.transformIntoNewTimeline()), e.previousNode = t } visitGroup(t, e) { const i = []; let r = e.currentTimeline.currentTime; const o = t.options && t.options.delay ? Gr(t.options.delay) : 0; t.steps.forEach(s => { const a = e.createSubContext(t.options); o && a.delayNextStep(o), cn(this, s, a), r = Math.max(r, a.currentTimeline.currentTime), i.push(a.currentTimeline) }), i.forEach(s => e.currentTimeline.mergeTimelineCollectedStyles(s)), e.transformIntoNewTimeline(r), e.previousNode = t } _visitTiming(t, e) { if (t.dynamic) { const i = t.strValue; return wu(e.params ? Tu(i, e.params, e.errors) : i, e.errors) } return { duration: t.duration, delay: t.delay, easing: t.easing } } visitAnimate(t, e) { const i = e.currentAnimateTimings = this._visitTiming(t.timings, e), r = e.currentTimeline; i.delay && (e.incrementTime(i.delay), r.snapshotCurrentStyles()); const o = t.style; 5 == o.type ? this.visitKeyframes(o, e) : (e.incrementTime(i.duration), this.visitStyle(o, e), r.applyStylesToKeyframe()), e.currentAnimateTimings = null, e.previousNode = t } visitStyle(t, e) { const i = e.currentTimeline, r = e.currentAnimateTimings; !r && i.getCurrentStyleProperties().length && i.forwardFrame(); const o = r && r.easing || t.easing; t.isEmptyStep ? i.applyEmptyStep(o) : i.setStyles(t.styles, o, e.errors, e.options), e.previousNode = t } visitKeyframes(t, e) { const i = e.currentAnimateTimings, r = e.currentTimeline.duration, o = i.duration, a = e.createSubContext().currentTimeline; a.easing = i.easing, t.styles.forEach(l => { a.forwardTime((l.offset || 0) * o), a.setStyles(l.styles, l.easing, e.errors, e.options), a.applyStylesToKeyframe() }), e.currentTimeline.mergeTimelineCollectedStyles(a), e.transformIntoNewTimeline(r + o), e.previousNode = t } visitQuery(t, e) { const i = e.currentTimeline.currentTime, r = t.options || {}, o = r.delay ? Gr(r.delay) : 0; o && (6 === e.previousNode.type || 0 == i && e.currentTimeline.getCurrentStyleProperties().length) && (e.currentTimeline.snapshotCurrentStyles(), e.previousNode = Ou); let s = i; const a = e.invokeQuery(t.selector, t.originalSelector, t.limit, t.includeSelf, !!r.optional, e.errors); e.currentQueryTotal = a.length; let l = null; a.forEach((c, u) => { e.currentQueryIndex = u; const d = e.createSubContext(t.options, c); o && d.delayNextStep(o), c === e.element && (l = d.currentTimeline), cn(this, t.animation, d), d.currentTimeline.applyStylesToKeyframe(), s = Math.max(s, d.currentTimeline.currentTime) }), e.currentQueryIndex = 0, e.currentQueryTotal = 0, e.transformIntoNewTimeline(s), l && (e.currentTimeline.mergeTimelineCollectedStyles(l), e.currentTimeline.snapshotCurrentStyles()), e.previousNode = t } visitStagger(t, e) { const i = e.parentContext, r = e.currentTimeline, o = t.timings, s = Math.abs(o.duration), a = s * (e.currentQueryTotal - 1); let l = s * e.currentQueryIndex; switch (o.duration < 0 ? "reverse" : o.easing) { case "reverse": l = a - l; break; case "full": l = i.currentStaggerTime }const u = e.currentTimeline; l && u.delayNextStep(l); const d = u.currentTime; cn(this, t.animation, e), e.previousNode = t, i.currentStaggerTime = r.currentTime - d + (r.startTime - i.currentTimeline.startTime) } } const Ou = {}; class Qg { constructor(t, e, i, r, o, s, a, l) { this._driver = t, this.element = e, this.subInstructions = i, this._enterClassName = r, this._leaveClassName = o, this.errors = s, this.timelines = a, this.parentContext = null, this.currentAnimateTimings = null, this.previousNode = Ou, this.subContextCount = 0, this.options = {}, this.currentQueryIndex = 0, this.currentQueryTotal = 0, this.currentStaggerTime = 0, this.currentTimeline = l || new xu(this._driver, e, 0), a.push(this.currentTimeline) } get params() { return this.options.params } updateOptions(t, e) { if (!t) return; const i = t; let r = this.options; null != i.duration && (r.duration = Gr(i.duration)), null != i.delay && (r.delay = Gr(i.delay)); const o = i.params; if (o) { let s = r.params; s || (s = this.options.params = {}), Object.keys(o).forEach(a => { (!e || !s.hasOwnProperty(a)) && (s[a] = Tu(o[a], s, this.errors)) }) } } _copyOptions() { const t = {}; if (this.options) { const e = this.options.params; if (e) { const i = t.params = {}; Object.keys(e).forEach(r => { i[r] = e[r] }) } } return t } createSubContext(t = null, e, i) { const r = e || this.element, o = new Qg(this._driver, r, this.subInstructions, this._enterClassName, this._leaveClassName, this.errors, this.timelines, this.currentTimeline.fork(r, i || 0)); return o.previousNode = this.previousNode, o.currentAnimateTimings = this.currentAnimateTimings, o.options = this._copyOptions(), o.updateOptions(t), o.currentQueryIndex = this.currentQueryIndex, o.currentQueryTotal = this.currentQueryTotal, o.parentContext = this, this.subContextCount++, o } transformIntoNewTimeline(t) { return this.previousNode = Ou, this.currentTimeline = this.currentTimeline.fork(this.element, t), this.timelines.push(this.currentTimeline), this.currentTimeline } appendInstructionToTimeline(t, e, i) { const r = { duration: null != e ? e : t.duration, delay: this.currentTimeline.currentTime + (null != i ? i : 0) + t.delay, easing: "" }, o = new k8(this._driver, t.element, t.keyframes, t.preStyleProps, t.postStyleProps, r, t.stretchStartingKeyframe); return this.timelines.push(o), r } incrementTime(t) { this.currentTimeline.forwardTime(this.currentTimeline.duration + t) } delayNextStep(t) { t > 0 && this.currentTimeline.delayNextStep(t) } invokeQuery(t, e, i, r, o, s) { let a = []; if (r && a.push(this.element), t.length > 0) { t = (t = t.replace(R8, "." + this._enterClassName)).replace(x8, "." + this._leaveClassName); let c = this._driver.query(this.element, t, 1 != i); 0 !== i && (c = i < 0 ? c.slice(c.length + i, c.length) : c.slice(0, i)), a.push(...c) } return !o && 0 == a.length && s.push(`\`query("${e}")\` returned zero elements. (Use \`query("${e}", { optional: true })\` if you wish to allow this.)`), a } } class xu { constructor(t, e, i, r) { this._driver = t, this.element = e, this.startTime = i, this._elementTimelineStylesLookup = r, this.duration = 0, this._previousKeyframe = {}, this._currentKeyframe = {}, this._keyframes = new Map, this._styleSummary = {}, this._pendingStyles = {}, this._backFill = {}, this._currentEmptyStepKeyframe = null, this._elementTimelineStylesLookup || (this._elementTimelineStylesLookup = new Map), this._localTimelineStyles = Object.create(this._backFill, {}), this._globalTimelineStyles = this._elementTimelineStylesLookup.get(e), this._globalTimelineStyles || (this._globalTimelineStyles = this._localTimelineStyles, this._elementTimelineStylesLookup.set(e, this._localTimelineStyles)), this._loadKeyframe() } containsAnimation() { switch (this._keyframes.size) { case 0: return !1; case 1: return this.getCurrentStyleProperties().length > 0; default: return !0 } } getCurrentStyleProperties() { return Object.keys(this._currentKeyframe) } get currentTime() { return this.startTime + this.duration } delayNextStep(t) { const e = 1 == this._keyframes.size && Object.keys(this._pendingStyles).length; this.duration || e ? (this.forwardTime(this.currentTime + t), e && this.snapshotCurrentStyles()) : this.startTime += t } fork(t, e) { return this.applyStylesToKeyframe(), new xu(this._driver, t, e || this.currentTime, this._elementTimelineStylesLookup) } _loadKeyframe() { this._currentKeyframe && (this._previousKeyframe = this._currentKeyframe), this._currentKeyframe = this._keyframes.get(this.duration), this._currentKeyframe || (this._currentKeyframe = Object.create(this._backFill, {}), this._keyframes.set(this.duration, this._currentKeyframe)) } forwardFrame() { this.duration += 1, this._loadKeyframe() } forwardTime(t) { this.applyStylesToKeyframe(), this.duration = t, this._loadKeyframe() } _updateStyle(t, e) { this._localTimelineStyles[t] = e, this._globalTimelineStyles[t] = e, this._styleSummary[t] = { time: this.currentTime, value: e } } allowOnlyTimelineStyles() { return this._currentEmptyStepKeyframe !== this._currentKeyframe } applyEmptyStep(t) { t && (this._previousKeyframe.easing = t), Object.keys(this._globalTimelineStyles).forEach(e => { this._backFill[e] = this._globalTimelineStyles[e] || Fi, this._currentKeyframe[e] = Fi }), this._currentEmptyStepKeyframe = this._currentKeyframe } setStyles(t, e, i, r) { e && (this._previousKeyframe.easing = e); const o = r && r.params || {}, s = function F8(n, t) { const e = {}; let i; return n.forEach(r => { "*" === r ? (i = i || Object.keys(t), i.forEach(o => { e[o] = Fi })) : cr(r, !1, e) }), e }(t, this._globalTimelineStyles); Object.keys(s).forEach(a => { const l = Tu(s[a], o, i); this._pendingStyles[a] = l, this._localTimelineStyles.hasOwnProperty(a) || (this._backFill[a] = this._globalTimelineStyles.hasOwnProperty(a) ? this._globalTimelineStyles[a] : Fi), this._updateStyle(a, l) }) } applyStylesToKeyframe() { const t = this._pendingStyles, e = Object.keys(t); 0 != e.length && (this._pendingStyles = {}, e.forEach(i => { this._currentKeyframe[i] = t[i] }), Object.keys(this._localTimelineStyles).forEach(i => { this._currentKeyframe.hasOwnProperty(i) || (this._currentKeyframe[i] = this._localTimelineStyles[i]) })) } snapshotCurrentStyles() { Object.keys(this._localTimelineStyles).forEach(t => { const e = this._localTimelineStyles[t]; this._pendingStyles[t] = e, this._updateStyle(t, e) }) } getFinalKeyframe() { return this._keyframes.get(this.duration) } get properties() { const t = []; for (let e in this._currentKeyframe) t.push(e); return t } mergeTimelineCollectedStyles(t) { Object.keys(t._styleSummary).forEach(e => { const i = this._styleSummary[e], r = t._styleSummary[e]; (!i || r.time > i.time) && this._updateStyle(e, r.value) }) } buildKeyframes() { this.applyStylesToKeyframe(); const t = new Set, e = new Set, i = 1 === this._keyframes.size && 0 === this.duration; let r = []; this._keyframes.forEach((a, l) => { const c = cr(a, !0); Object.keys(c).forEach(u => { const d = c[u]; "!" == d ? t.add(u) : d == Fi && e.add(u) }), i || (c.offset = l / this.duration), r.push(c) }); const o = t.size ? Su(t.values()) : [], s = e.size ? Su(e.values()) : []; if (i) { const a = r[0], l = bs(a); a.offset = 0, l.offset = 1, r = [a, l] } return qg(this.element, r, o, s, this.duration, this.startTime, this.easing, !1) } } class k8 extends xu { constructor(t, e, i, r, o, s, a = !1) { super(t, e, s.delay), this.keyframes = i, this.preStyleProps = r, this.postStyleProps = o, this._stretchStartingKeyframe = a, this.timings = { duration: s.duration, delay: s.delay, easing: s.easing } } containsAnimation() { return this.keyframes.length > 1 } buildKeyframes() { let t = this.keyframes, { delay: e, duration: i, easing: r } = this.timings; if (this._stretchStartingKeyframe && e) { const o = [], s = i + e, a = e / s, l = cr(t[0], !1); l.offset = 0, o.push(l); const c = cr(t[0], !1); c.offset = RT(a), o.push(c); const u = t.length - 1; for (let d = 1; d <= u; d++) { let h = cr(t[d], !1); h.offset = RT((e + h.offset * i) / s), o.push(h) } i = s, e = 0, r = "", t = o } return qg(this.element, t, this.preStyleProps, this.postStyleProps, i, e, r, !0) } } function RT(n, t = 3) { const e = Math.pow(10, t - 1); return Math.round(n * e) / e } class Jg { } class L8 extends Jg { normalizePropertyName(t, e) { return Gg(t) } normalizeStyleValue(t, e, i, r) { let o = ""; const s = i.toString().trim(); if (B8[e] && 0 !== i && "0" !== i) if ("number" == typeof i) o = "px"; else { const a = i.match(/^[+-]?[\d\.]+([a-z]*)$/); a && 0 == a[1].length && r.push(`Please provide a CSS unit value for ${t}:${i}`) } return s + o } } const B8 = (() => function V8(n) { const t = {}; return n.forEach(e => t[e] = !0), t }("width,height,minWidth,minHeight,maxWidth,maxHeight,left,top,bottom,right,fontSize,outlineWidth,outlineOffset,paddingTop,paddingLeft,paddingBottom,paddingRight,marginTop,marginLeft,marginBottom,marginRight,borderRadius,borderWidth,borderTopWidth,borderLeftWidth,borderRightWidth,borderBottomWidth,textIndent,perspective".split(",")))(); function OT(n, t, e, i, r, o, s, a, l, c, u, d, h) { return { type: 0, element: n, triggerName: t, isRemovalTransition: r, fromState: e, fromStyles: o, toState: i, toStyles: s, timelines: a, queriedElements: l, preStyleProps: c, postStyleProps: u, totalTime: d, errors: h } } const Zg = {}; class xT { constructor(t, e, i) { this._triggerName = t, this.ast = e, this._stateStyles = i } match(t, e, i, r) { return function H8(n, t, e, i, r) { return n.some(o => o(t, e, i, r)) }(this.ast.matchers, t, e, i, r) } buildStyles(t, e, i) { const r = this._stateStyles["*"], o = this._stateStyles[t], s = r ? r.buildStyles(e, i) : {}; return o ? o.buildStyles(e, i) : s } build(t, e, i, r, o, s, a, l, c, u) { const d = [], h = this.ast.options && this.ast.options.params || Zg, p = this.buildStyles(i, a && a.params || Zg, d), _ = l && l.params || Zg, y = this.buildStyles(r, _, d), b = new Set, m = new Map, C = new Map, T = "void" === r, M = { params: Object.assign(Object.assign({}, h), _) }, k = u ? [] : Yg(t, e, this.ast.animation, o, s, p, y, M, c, d); let H = 0; if (k.forEach(we => { H = Math.max(we.duration + we.delay, H) }), d.length) return OT(e, this._triggerName, i, r, T, p, y, [], [], m, C, H, d); k.forEach(we => { const Te = we.element, Ne = ln(m, Te, {}); we.preStyleProps.forEach(He => Ne[He] = !0); const nt = ln(C, Te, {}); we.postStyleProps.forEach(He => nt[He] = !0), Te !== e && b.add(Te) }); const J = Su(b.values()); return OT(e, this._triggerName, i, r, T, p, y, k, J, m, C, H) } } class j8 { constructor(t, e, i) { this.styles = t, this.defaultParams = e, this.normalizer = i } buildStyles(t, e) { const i = {}, r = bs(this.defaultParams); return Object.keys(t).forEach(o => { const s = t[o]; null != s && (r[o] = s) }), this.styles.styles.forEach(o => { if ("string" != typeof o) { const s = o; Object.keys(s).forEach(a => { let l = s[a]; l.length > 1 && (l = Tu(l, r, e)); const c = this.normalizer.normalizePropertyName(a, e); l = this.normalizer.normalizeStyleValue(a, c, l, e), i[c] = l }) } }), i } } class $8 { constructor(t, e, i) { this.name = t, this.ast = e, this._normalizer = i, this.transitionFactories = [], this.states = {}, e.states.forEach(r => { this.states[r.name] = new j8(r.style, r.options && r.options.params || {}, i) }), PT(this.states, "true", "1"), PT(this.states, "false", "0"), e.transitions.forEach(r => { this.transitionFactories.push(new xT(t, r, this.states)) }), this.fallbackTransition = function G8(n, t, e) { return new xT(n, { type: 1, animation: { type: 2, steps: [], options: null }, matchers: [(s, a) => !0], options: null, queryCount: 0, depCount: 0 }, t) }(t, this.states) } get containsQueries() { return this.ast.queryCount > 0 } matchTransition(t, e, i, r) { return this.transitionFactories.find(s => s.match(t, e, i, r)) || null } matchStyles(t, e, i) { return this.fallbackTransition.buildStyles(t, e, i) } } function PT(n, t, e) { n.hasOwnProperty(t) ? n.hasOwnProperty(e) || (n[e] = n[t]) : n.hasOwnProperty(e) && (n[t] = n[e]) } const W8 = new Ru; class z8 { constructor(t, e, i) { this.bodyNode = t, this._driver = e, this._normalizer = i, this._animations = {}, this._playersById = {}, this.players = [] } register(t, e) { const i = [], r = zg(this._driver, e, i); if (i.length) throw new Error(`Unable to build the animation due to the following errors: ${i.join("\n")}`); this._animations[t] = r } _buildPlayer(t, e, i) { const r = t.element, o = pT(0, this._normalizer, 0, t.keyframes, e, i); return this._driver.animate(r, o, t.duration, t.delay, t.easing, [], !0) } create(t, e, i = {}) { const r = [], o = this._animations[t]; let s; const a = new Map; if (o ? (s = Yg(this._driver, e, o, Hg, Du, {}, {}, i, W8, r), s.forEach(u => { const d = ln(a, u.element, {}); u.postStyleProps.forEach(h => d[h] = null) })) : (r.push("The requested animation doesn't exist or has already been destroyed"), s = []), r.length) throw new Error(`Unable to create the animation due to the following errors: ${r.join("\n")}`); a.forEach((u, d) => { Object.keys(u).forEach(h => { u[h] = this._driver.computeStyle(d, h, Fi) }) }); const c = lr(s.map(u => { const d = a.get(u.element); return this._buildPlayer(u, {}, d) })); return this._playersById[t] = c, c.onDestroy(() => this.destroy(t)), this.players.push(c), c } destroy(t) { const e = this._getPlayer(t); e.destroy(), delete this._playersById[t]; const i = this.players.indexOf(e); i >= 0 && this.players.splice(i, 1) } _getPlayer(t) { const e = this._playersById[t]; if (!e) throw new Error(`Unable to find the timeline player referenced by ${t}`); return e } listen(t, e, i, r) { const o = Pg(e, "", "", ""); return Og(this._getPlayer(t), i, o, r), () => { } } command(t, e, i, r) { if ("register" == i) return void this.register(t, r[0]); if ("create" == i) return void this.create(t, e, r[0] || {}); const o = this._getPlayer(t); switch (i) { case "play": o.play(); break; case "pause": o.pause(); break; case "reset": o.reset(); break; case "restart": o.restart(); break; case "finish": o.finish(); break; case "init": o.init(); break; case "setPosition": o.setPosition(parseFloat(r[0])); break; case "destroy": this.destroy(t) } } } const kT = "ng-animate-queued", Xg = "ng-animate-disabled", J8 = [], FT = { namespaceId: "", setForRemoval: !1, setForMove: !1, hasAnimation: !1, removedBeforeQueried: !1 }, Z8 = { namespaceId: "", setForMove: !1, setForRemoval: !1, hasAnimation: !1, removedBeforeQueried: !0 }, En = "__ng_removed"; class e_ { constructor(t, e = "") { this.namespaceId = e; const i = t && t.hasOwnProperty("value"); if (this.value = function n5(n) { return null != n ? n : null }(i ? t.value : t), i) { const o = bs(t); delete o.value, this.options = o } else this.options = {}; this.options.params || (this.options.params = {}) } get params() { return this.options.params } absorbOptions(t) { const e = t.params; if (e) { const i = this.options.params; Object.keys(e).forEach(r => { null == i[r] && (i[r] = e[r]) }) } } } const tl = "void", t_ = new e_(tl); class X8 { constructor(t, e, i) { this.id = t, this.hostElement = e, this._engine = i, this.players = [], this._triggers = {}, this._queue = [], this._elementListeners = new Map, this._hostClassName = "ng-tns-" + t, wn(e, this._hostClassName) } listen(t, e, i, r) { if (!this._triggers.hasOwnProperty(e)) throw new Error(`Unable to listen on the animation trigger event "${i}" because the animation trigger "${e}" doesn't exist!`); if (null == i || 0 == i.length) throw new Error(`Unable to listen on the animation trigger "${e}" because the provided event is undefined!`); if (!function r5(n) { return "start" == n || "done" == n }(i)) throw new Error(`The provided animation trigger event "${i}" for the animation trigger "${e}" is not supported!`); const o = ln(this._elementListeners, t, []), s = { name: e, phase: i, callback: r }; o.push(s); const a = ln(this._engine.statesByElement, t, {}); return a.hasOwnProperty(e) || (wn(t, Cu), wn(t, Cu + "-" + e), a[e] = t_), () => { this._engine.afterFlush(() => { const l = o.indexOf(s); l >= 0 && o.splice(l, 1), this._triggers[e] || delete a[e] }) } } register(t, e) { return !this._triggers[t] && (this._triggers[t] = e, !0) } _getTrigger(t) { const e = this._triggers[t]; if (!e) throw new Error(`The provided animation trigger "${t}" has not been registered!`); return e } trigger(t, e, i, r = !0) { const o = this._getTrigger(e), s = new n_(this.id, e, t); let a = this._engine.statesByElement.get(t); a || (wn(t, Cu), wn(t, Cu + "-" + e), this._engine.statesByElement.set(t, a = {})); let l = a[e]; const c = new e_(i, this.id); if (!(i && i.hasOwnProperty("value")) && l && c.absorbOptions(l.options), a[e] = c, l || (l = t_), c.value !== tl && l.value === c.value) { if (!function a5(n, t) { const e = Object.keys(n), i = Object.keys(t); if (e.length != i.length) return !1; for (let r = 0; r < e.length; r++) { const o = e[r]; if (!t.hasOwnProperty(o) || n[o] !== t[o]) return !1 } return !0 }(l.params, c.params)) { const _ = [], y = o.matchStyles(l.value, l.params, _), b = o.matchStyles(c.value, c.params, _); _.length ? this._engine.reportError(_) : this._engine.afterFlush(() => { Wr(t, y), fi(t, b) }) } return } const h = ln(this._engine.playersByElement, t, []); h.forEach(_ => { _.namespaceId == this.id && _.triggerName == e && _.queued && _.destroy() }); let f = o.matchTransition(l.value, c.value, t, c.params), p = !1; if (!f) { if (!r) return; f = o.fallbackTransition, p = !0 } return this._engine.totalQueuedPlayers++, this._queue.push({ element: t, triggerName: e, transition: f, fromState: l, toState: c, player: s, isFallbackTransition: p }), p || (wn(t, kT), s.onStart(() => { vs(t, kT) })), s.onDone(() => { let _ = this.players.indexOf(s); _ >= 0 && this.players.splice(_, 1); const y = this._engine.playersByElement.get(t); if (y) { let b = y.indexOf(s); b >= 0 && y.splice(b, 1) } }), this.players.push(s), h.push(s), s } deregister(t) { delete this._triggers[t], this._engine.statesByElement.forEach((e, i) => { delete e[t] }), this._elementListeners.forEach((e, i) => { this._elementListeners.set(i, e.filter(r => r.name != t)) }) } clearElementCache(t) { this._engine.statesByElement.delete(t), this._elementListeners.delete(t); const e = this._engine.playersByElement.get(t); e && (e.forEach(i => i.destroy()), this._engine.playersByElement.delete(t)) } _signalRemovalForInnerTriggers(t, e) { const i = this._engine.driver.query(t, Eu, !0); i.forEach(r => { if (r[En]) return; const o = this._engine.fetchNamespacesByElement(r); o.size ? o.forEach(s => s.triggerLeaveAnimation(r, e, !1, !0)) : this.clearElementCache(r) }), this._engine.afterFlushAnimationsDone(() => i.forEach(r => this.clearElementCache(r))) } triggerLeaveAnimation(t, e, i, r) { const o = this._engine.statesByElement.get(t), s = new Map; if (o) { const a = []; if (Object.keys(o).forEach(l => { if (s.set(l, o[l].value), this._triggers[l]) { const c = this.trigger(t, l, tl, r); c && a.push(c) } }), a.length) return this._engine.markElementAsRemoved(this.id, t, !0, e, s), i && lr(a).onDone(() => this._engine.processLeaveNode(t)), !0 } return !1 } prepareLeaveAnimationListeners(t) { const e = this._elementListeners.get(t), i = this._engine.statesByElement.get(t); if (e && i) { const r = new Set; e.forEach(o => { const s = o.name; if (r.has(s)) return; r.add(s); const l = this._triggers[s].fallbackTransition, c = i[s] || t_, u = new e_(tl), d = new n_(this.id, s, t); this._engine.totalQueuedPlayers++, this._queue.push({ element: t, triggerName: s, transition: l, fromState: c, toState: u, player: d, isFallbackTransition: !0 }) }) } } removeNode(t, e) { const i = this._engine; if (t.childElementCount && this._signalRemovalForInnerTriggers(t, e), this.triggerLeaveAnimation(t, e, !0)) return; let r = !1; if (i.totalAnimations) { const o = i.players.length ? i.playersByQueriedElement.get(t) : []; if (o && o.length) r = !0; else { let s = t; for (; s = s.parentNode;)if (i.statesByElement.get(s)) { r = !0; break } } } if (this.prepareLeaveAnimationListeners(t), r) i.markElementAsRemoved(this.id, t, !1, e); else { const o = t[En]; (!o || o === FT) && (i.afterFlush(() => this.clearElementCache(t)), i.destroyInnerAnimations(t), i._onRemovalComplete(t, e)) } } insertNode(t, e) { wn(t, this._hostClassName) } drainQueuedTransitions(t) { const e = []; return this._queue.forEach(i => { const r = i.player; if (r.destroyed) return; const o = i.element, s = this._elementListeners.get(o); s && s.forEach(a => { if (a.name == i.triggerName) { const l = Pg(o, i.triggerName, i.fromState.value, i.toState.value); l._data = t, Og(i.player, a.phase, l, a.callback) } }), r.markedForDestroy ? this._engine.afterFlush(() => { r.destroy() }) : e.push(i) }), this._queue = [], e.sort((i, r) => { const o = i.transition.ast.depCount, s = r.transition.ast.depCount; return 0 == o || 0 == s ? o - s : this._engine.driver.containsElement(i.element, r.element) ? 1 : -1 }) } destroy(t) { this.players.forEach(e => e.destroy()), this._signalRemovalForInnerTriggers(this.hostElement, t) } elementContainsData(t) { let e = !1; return this._elementListeners.has(t) && (e = !0), e = !!this._queue.find(i => i.element === t) || e, e } } class e5 { constructor(t, e, i) { this.bodyNode = t, this.driver = e, this._normalizer = i, this.players = [], this.newHostElements = new Map, this.playersByElement = new Map, this.playersByQueriedElement = new Map, this.statesByElement = new Map, this.disabledNodes = new Set, this.totalAnimations = 0, this.totalQueuedPlayers = 0, this._namespaceLookup = {}, this._namespaceList = [], this._flushFns = [], this._whenQuietFns = [], this.namespacesByHostElement = new Map, this.collectedEnterElements = [], this.collectedLeaveElements = [], this.onRemovalComplete = (r, o) => { } } _onRemovalComplete(t, e) { this.onRemovalComplete(t, e) } get queuedPlayers() { const t = []; return this._namespaceList.forEach(e => { e.players.forEach(i => { i.queued && t.push(i) }) }), t } createNamespace(t, e) { const i = new X8(t, e, this); return this.bodyNode && this.driver.containsElement(this.bodyNode, e) ? this._balanceNamespaceList(i, e) : (this.newHostElements.set(e, i), this.collectEnterElement(e)), this._namespaceLookup[t] = i } _balanceNamespaceList(t, e) { const i = this._namespaceList.length - 1; if (i >= 0) { let r = !1; for (let o = i; o >= 0; o--)if (this.driver.containsElement(this._namespaceList[o].hostElement, e)) { this._namespaceList.splice(o + 1, 0, t), r = !0; break } r || this._namespaceList.splice(0, 0, t) } else this._namespaceList.push(t); return this.namespacesByHostElement.set(e, t), t } register(t, e) { let i = this._namespaceLookup[t]; return i || (i = this.createNamespace(t, e)), i } registerTrigger(t, e, i) { let r = this._namespaceLookup[t]; r && r.register(e, i) && this.totalAnimations++ } destroy(t, e) { if (!t) return; const i = this._fetchNamespace(t); this.afterFlush(() => { this.namespacesByHostElement.delete(i.hostElement), delete this._namespaceLookup[t]; const r = this._namespaceList.indexOf(i); r >= 0 && this._namespaceList.splice(r, 1) }), this.afterFlushAnimationsDone(() => i.destroy(e)) } _fetchNamespace(t) { return this._namespaceLookup[t] } fetchNamespacesByElement(t) { const e = new Set, i = this.statesByElement.get(t); if (i) { const r = Object.keys(i); for (let o = 0; o < r.length; o++) { const s = i[r[o]].namespaceId; if (s) { const a = this._fetchNamespace(s); a && e.add(a) } } } return e } trigger(t, e, i, r) { if (Pu(e)) { const o = this._fetchNamespace(t); if (o) return o.trigger(e, i, r), !0 } return !1 } insertNode(t, e, i, r) { if (!Pu(e)) return; const o = e[En]; if (o && o.setForRemoval) { o.setForRemoval = !1, o.setForMove = !0; const s = this.collectedLeaveElements.indexOf(e); s >= 0 && this.collectedLeaveElements.splice(s, 1) } if (t) { const s = this._fetchNamespace(t); s && s.insertNode(e, i) } r && this.collectEnterElement(e) } collectEnterElement(t) { this.collectedEnterElements.push(t) } markElementAsDisabled(t, e) { e ? this.disabledNodes.has(t) || (this.disabledNodes.add(t), wn(t, Xg)) : this.disabledNodes.has(t) && (this.disabledNodes.delete(t), vs(t, Xg)) } removeNode(t, e, i, r) { if (Pu(e)) { const o = t ? this._fetchNamespace(t) : null; if (o ? o.removeNode(e, r) : this.markElementAsRemoved(t, e, !1, r), i) { const s = this.namespacesByHostElement.get(e); s && s.id !== t && s.removeNode(e, r) } } else this._onRemovalComplete(e, r) } markElementAsRemoved(t, e, i, r, o) { this.collectedLeaveElements.push(e), e[En] = { namespaceId: t, setForRemoval: r, hasAnimation: i, removedBeforeQueried: !1, previousTriggersValues: o } } listen(t, e, i, r, o) { return Pu(e) ? this._fetchNamespace(t).listen(e, i, r, o) : () => { } } _buildInstruction(t, e, i, r, o) { return t.transition.build(this.driver, t.element, t.fromState.value, t.toState.value, i, r, t.fromState.options, t.toState.options, e, o) } destroyInnerAnimations(t) { let e = this.driver.query(t, Eu, !0); e.forEach(i => this.destroyActiveAnimationsForElement(i)), 0 != this.playersByQueriedElement.size && (e = this.driver.query(t, jg, !0), e.forEach(i => this.finishActiveQueriedAnimationOnElement(i))) } destroyActiveAnimationsForElement(t) { const e = this.playersByElement.get(t); e && e.forEach(i => { i.queued ? i.markedForDestroy = !0 : i.destroy() }) } finishActiveQueriedAnimationOnElement(t) { const e = this.playersByQueriedElement.get(t); e && e.forEach(i => i.finish()) } whenRenderingDone() { return new Promise(t => { if (this.players.length) return lr(this.players).onDone(() => t()); t() }) } processLeaveNode(t) { var e; const i = t[En]; if (i && i.setForRemoval) { if (t[En] = FT, i.namespaceId) { this.destroyInnerAnimations(t); const r = this._fetchNamespace(i.namespaceId); r && r.clearElementCache(t) } this._onRemovalComplete(t, i.setForRemoval) } (null === (e = t.classList) || void 0 === e ? void 0 : e.contains(Xg)) && this.markElementAsDisabled(t, !1), this.driver.query(t, ".ng-animate-disabled", !0).forEach(r => { this.markElementAsDisabled(r, !1) }) } flush(t = -1) { let e = []; if (this.newHostElements.size && (this.newHostElements.forEach((i, r) => this._balanceNamespaceList(i, r)), this.newHostElements.clear()), this.totalAnimations && this.collectedEnterElements.length) for (let i = 0; i < this.collectedEnterElements.length; i++)wn(this.collectedEnterElements[i], "ng-star-inserted"); if (this._namespaceList.length && (this.totalQueuedPlayers || this.collectedLeaveElements.length)) { const i = []; try { e = this._flushAnimations(i, t) } finally { for (let r = 0; r < i.length; r++)i[r]() } } else for (let i = 0; i < this.collectedLeaveElements.length; i++)this.processLeaveNode(this.collectedLeaveElements[i]); if (this.totalQueuedPlayers = 0, this.collectedEnterElements.length = 0, this.collectedLeaveElements.length = 0, this._flushFns.forEach(i => i()), this._flushFns = [], this._whenQuietFns.length) { const i = this._whenQuietFns; this._whenQuietFns = [], e.length ? lr(e).onDone(() => { i.forEach(r => r()) }) : i.forEach(r => r()) } } reportError(t) { throw new Error(`Unable to process animations due to the following failed trigger transitions\n ${t.join("\n")}`) } _flushAnimations(t, e) { const i = new Ru, r = [], o = new Map, s = [], a = new Map, l = new Map, c = new Map, u = new Set; this.disabledNodes.forEach(A => { u.add(A); const x = this.driver.query(A, ".ng-animate-queued", !0); for (let V = 0; V < x.length; V++)u.add(x[V]) }); const d = this.bodyNode, h = Array.from(this.statesByElement.keys()), f = VT(h, this.collectedEnterElements), p = new Map; let _ = 0; f.forEach((A, x) => { const V = Hg + _++; p.set(x, V), A.forEach(oe => wn(oe, V)) }); const y = [], b = new Set, m = new Set; for (let A = 0; A < this.collectedLeaveElements.length; A++) { const x = this.collectedLeaveElements[A], V = x[En]; V && V.setForRemoval && (y.push(x), b.add(x), V.hasAnimation ? this.driver.query(x, ".ng-star-inserted", !0).forEach(oe => b.add(oe)) : m.add(x)) } const C = new Map, T = VT(h, Array.from(b)); T.forEach((A, x) => { const V = Du + _++; C.set(x, V), A.forEach(oe => wn(oe, V)) }), t.push(() => { f.forEach((A, x) => { const V = p.get(x); A.forEach(oe => vs(oe, V)) }), T.forEach((A, x) => { const V = C.get(x); A.forEach(oe => vs(oe, V)) }), y.forEach(A => { this.processLeaveNode(A) }) }); const M = [], k = []; for (let A = this._namespaceList.length - 1; A >= 0; A--)this._namespaceList[A].drainQueuedTransitions(e).forEach(V => { const oe = V.player, qe = V.element; if (M.push(oe), this.collectedEnterElements.length) { const lt = qe[En]; if (lt && lt.setForMove) { if (lt.previousTriggersValues && lt.previousTriggersValues.has(V.triggerName)) { const Gt = lt.previousTriggersValues.get(V.triggerName), An = this.statesByElement.get(V.element); An && An[V.triggerName] && (An[V.triggerName].value = Gt) } return void oe.destroy() } } const Jt = !d || !this.driver.containsElement(d, qe), yt = C.get(qe), un = p.get(qe), Ae = this._buildInstruction(V, i, un, yt, Jt); if (Ae.errors && Ae.errors.length) return void k.push(Ae); if (Jt) return oe.onStart(() => Wr(qe, Ae.fromStyles)), oe.onDestroy(() => fi(qe, Ae.toStyles)), void r.push(oe); if (V.isFallbackTransition) return oe.onStart(() => Wr(qe, Ae.fromStyles)), oe.onDestroy(() => fi(qe, Ae.toStyles)), void r.push(oe); const Yn = []; Ae.timelines.forEach(lt => { lt.stretchStartingKeyframe = !0, this.disabledNodes.has(lt.element) || Yn.push(lt) }), Ae.timelines = Yn, i.append(qe, Ae.timelines), s.push({ instruction: Ae, player: oe, element: qe }), Ae.queriedElements.forEach(lt => ln(a, lt, []).push(oe)), Ae.preStyleProps.forEach((lt, Gt) => { const An = Object.keys(lt); if (An.length) { let Li = l.get(Gt); Li || l.set(Gt, Li = new Set), An.forEach(Yr => Li.add(Yr)) } }), Ae.postStyleProps.forEach((lt, Gt) => { const An = Object.keys(lt); let Li = c.get(Gt); Li || c.set(Gt, Li = new Set), An.forEach(Yr => Li.add(Yr)) }) }); if (k.length) { const A = []; k.forEach(x => { A.push(`@${x.triggerName} has failed due to:\n`), x.errors.forEach(V => A.push(`- ${V}\n`)) }), M.forEach(x => x.destroy()), this.reportError(A) } const H = new Map, J = new Map; s.forEach(A => { const x = A.element; i.has(x) && (J.set(x, x), this._beforeAnimationBuild(A.player.namespaceId, A.instruction, H)) }), r.forEach(A => { const x = A.element; this._getPreviousPlayers(x, !1, A.namespaceId, A.triggerName, null).forEach(oe => { ln(H, x, []).push(oe), oe.destroy() }) }); const we = y.filter(A => jT(A, l, c)), Te = new Map; BT(Te, this.driver, m, c, Fi).forEach(A => { jT(A, l, c) && we.push(A) }); const nt = new Map; f.forEach((A, x) => { BT(nt, this.driver, new Set(A), l, "!") }), we.forEach(A => { const x = Te.get(A), V = nt.get(A); Te.set(A, Object.assign(Object.assign({}, x), V)) }); const He = [], Tn = [], Sn = {}; s.forEach(A => { const { element: x, player: V, instruction: oe } = A; if (i.has(x)) { if (u.has(x)) return V.onDestroy(() => fi(x, oe.toStyles)), V.disabled = !0, V.overrideTotalTime(oe.totalTime), void r.push(V); let qe = Sn; if (J.size > 1) { let yt = x; const un = []; for (; yt = yt.parentNode;) { const Ae = J.get(yt); if (Ae) { qe = Ae; break } un.push(yt) } un.forEach(Ae => J.set(Ae, qe)) } const Jt = this._buildAnimation(V.namespaceId, oe, H, o, nt, Te); if (V.setRealPlayer(Jt), qe === Sn) He.push(V); else { const yt = this.playersByElement.get(qe); yt && yt.length && (V.parentPlayer = lr(yt)), r.push(V) } } else Wr(x, oe.fromStyles), V.onDestroy(() => fi(x, oe.toStyles)), Tn.push(V), u.has(x) && r.push(V) }), Tn.forEach(A => { const x = o.get(A.element); if (x && x.length) { const V = lr(x); A.setRealPlayer(V) } }), r.forEach(A => { A.parentPlayer ? A.syncPlayerEvents(A.parentPlayer) : A.destroy() }); for (let A = 0; A < y.length; A++) { const x = y[A], V = x[En]; if (vs(x, Du), V && V.hasAnimation) continue; let oe = []; if (a.size) { let Jt = a.get(x); Jt && Jt.length && oe.push(...Jt); let yt = this.driver.query(x, jg, !0); for (let un = 0; un < yt.length; un++) { let Ae = a.get(yt[un]); Ae && Ae.length && oe.push(...Ae) } } const qe = oe.filter(Jt => !Jt.destroyed); qe.length ? o5(this, x, qe) : this.processLeaveNode(x) } return y.length = 0, He.forEach(A => { this.players.push(A), A.onDone(() => { A.destroy(); const x = this.players.indexOf(A); this.players.splice(x, 1) }), A.play() }), He } elementContainsData(t, e) { let i = !1; const r = e[En]; return r && r.setForRemoval && (i = !0), this.playersByElement.has(e) && (i = !0), this.playersByQueriedElement.has(e) && (i = !0), this.statesByElement.has(e) && (i = !0), this._fetchNamespace(t).elementContainsData(e) || i } afterFlush(t) { this._flushFns.push(t) } afterFlushAnimationsDone(t) { this._whenQuietFns.push(t) } _getPreviousPlayers(t, e, i, r, o) { let s = []; if (e) { const a = this.playersByQueriedElement.get(t); a && (s = a) } else { const a = this.playersByElement.get(t); if (a) { const l = !o || o == tl; a.forEach(c => { c.queued || !l && c.triggerName != r || s.push(c) }) } } return (i || r) && (s = s.filter(a => !(i && i != a.namespaceId || r && r != a.triggerName))), s } _beforeAnimationBuild(t, e, i) { const o = e.element, s = e.isRemovalTransition ? void 0 : t, a = e.isRemovalTransition ? void 0 : e.triggerName; for (const l of e.timelines) { const c = l.element, u = c !== o, d = ln(i, c, []); this._getPreviousPlayers(c, u, s, a, e.toState).forEach(f => { const p = f.getRealPlayer(); p.beforeDestroy && p.beforeDestroy(), f.destroy(), d.push(f) }) } Wr(o, e.fromStyles) } _buildAnimation(t, e, i, r, o, s) { const a = e.triggerName, l = e.element, c = [], u = new Set, d = new Set, h = e.timelines.map(p => { const _ = p.element; u.add(_); const y = _[En]; if (y && y.removedBeforeQueried) return new ys(p.duration, p.delay); const b = _ !== l, m = function s5(n) { const t = []; return HT(n, t), t }((i.get(_) || J8).map(H => H.getRealPlayer())).filter(H => !!H.element && H.element === _), C = o.get(_), T = s.get(_), M = pT(0, this._normalizer, 0, p.keyframes, C, T), k = this._buildPlayer(p, M, m); if (p.subTimeline && r && d.add(_), b) { const H = new n_(t, a, _); H.setRealPlayer(k), c.push(H) } return k }); c.forEach(p => { ln(this.playersByQueriedElement, p.element, []).push(p), p.onDone(() => function t5(n, t, e) { let i; if (n instanceof Map) { if (i = n.get(t), i) { if (i.length) { const r = i.indexOf(e); i.splice(r, 1) } 0 == i.length && n.delete(t) } } else if (i = n[t], i) { if (i.length) { const r = i.indexOf(e); i.splice(r, 1) } 0 == i.length && delete n[t] } return i }(this.playersByQueriedElement, p.element, p)) }), u.forEach(p => wn(p, DT)); const f = lr(h); return f.onDestroy(() => { u.forEach(p => vs(p, DT)), fi(l, e.toStyles) }), d.forEach(p => { ln(r, p, []).push(f) }), f } _buildPlayer(t, e, i) { return e.length > 0 ? this.driver.animate(t.element, e, t.duration, t.delay, t.easing, i) : new ys(t.duration, t.delay) } } class n_ { constructor(t, e, i) { this.namespaceId = t, this.triggerName = e, this.element = i, this._player = new ys, this._containsRealPlayer = !1, this._queuedCallbacks = {}, this.destroyed = !1, this.markedForDestroy = !1, this.disabled = !1, this.queued = !0, this.totalTime = 0 } setRealPlayer(t) { this._containsRealPlayer || (this._player = t, Object.keys(this._queuedCallbacks).forEach(e => { this._queuedCallbacks[e].forEach(i => Og(t, e, void 0, i)) }), this._queuedCallbacks = {}, this._containsRealPlayer = !0, this.overrideTotalTime(t.totalTime), this.queued = !1) } getRealPlayer() { return this._player } overrideTotalTime(t) { this.totalTime = t } syncPlayerEvents(t) { const e = this._player; e.triggerCallback && t.onStart(() => e.triggerCallback("start")), t.onDone(() => this.finish()), t.onDestroy(() => this.destroy()) } _queueEvent(t, e) { ln(this._queuedCallbacks, t, []).push(e) } onDone(t) { this.queued && this._queueEvent("done", t), this._player.onDone(t) } onStart(t) { this.queued && this._queueEvent("start", t), this._player.onStart(t) } onDestroy(t) { this.queued && this._queueEvent("destroy", t), this._player.onDestroy(t) } init() { this._player.init() } hasStarted() { return !this.queued && this._player.hasStarted() } play() { !this.queued && this._player.play() } pause() { !this.queued && this._player.pause() } restart() { !this.queued && this._player.restart() } finish() { this._player.finish() } destroy() { this.destroyed = !0, this._player.destroy() } reset() { !this.queued && this._player.reset() } setPosition(t) { this.queued || this._player.setPosition(t) } getPosition() { return this.queued ? 0 : this._player.getPosition() } triggerCallback(t) { const e = this._player; e.triggerCallback && e.triggerCallback(t) } } function Pu(n) { return n && 1 === n.nodeType } function LT(n, t) { const e = n.style.display; return n.style.display = null != t ? t : "none", e } function BT(n, t, e, i, r) { const o = []; e.forEach(l => o.push(LT(l))); const s = []; i.forEach((l, c) => { const u = {}; l.forEach(d => { const h = u[d] = t.computeStyle(c, d, r); (!h || 0 == h.length) && (c[En] = Z8, s.push(c)) }), n.set(c, u) }); let a = 0; return e.forEach(l => LT(l, o[a++])), s } function VT(n, t) { const e = new Map; if (n.forEach(a => e.set(a, [])), 0 == t.length) return e; const r = new Set(t), o = new Map; function s(a) { if (!a) return 1; let l = o.get(a); if (l) return l; const c = a.parentNode; return l = e.has(c) ? c : r.has(c) ? 1 : s(c), o.set(a, l), l } return t.forEach(a => { const l = s(a); 1 !== l && e.get(l).push(a) }), e } function wn(n, t) { var e; null === (e = n.classList) || void 0 === e || e.add(t) } function vs(n, t) { var e; null === (e = n.classList) || void 0 === e || e.remove(t) } function o5(n, t, e) { lr(e).onDone(() => n.processLeaveNode(t)) } function HT(n, t) { for (let e = 0; e < n.length; e++) { const i = n[e]; i instanceof hT ? HT(i.players, t) : t.push(i) } } function jT(n, t, e) { const i = e.get(n); if (!i) return !1; let r = t.get(n); return r ? i.forEach(o => r.add(o)) : t.set(n, i), e.delete(n), !0 } class ku { constructor(t, e, i) { this.bodyNode = t, this._driver = e, this._normalizer = i, this._triggerCache = {}, this.onRemovalComplete = (r, o) => { }, this._transitionEngine = new e5(t, e, i), this._timelineEngine = new z8(t, e, i), this._transitionEngine.onRemovalComplete = (r, o) => this.onRemovalComplete(r, o) } registerTrigger(t, e, i, r, o) { const s = t + "-" + r; let a = this._triggerCache[s]; if (!a) { const l = [], c = zg(this._driver, o, l); if (l.length) throw new Error(`The animation trigger "${r}" has failed to build due to the following errors:\n - ${l.join("\n - ")}`); a = function U8(n, t, e) { return new $8(n, t, e) }(r, c, this._normalizer), this._triggerCache[s] = a } this._transitionEngine.registerTrigger(e, r, a) } register(t, e) { this._transitionEngine.register(t, e) } destroy(t, e) { this._transitionEngine.destroy(t, e) } onInsert(t, e, i, r) { this._transitionEngine.insertNode(t, e, i, r) } onRemove(t, e, i, r) { this._transitionEngine.removeNode(t, e, r || !1, i) } disableAnimations(t, e) { this._transitionEngine.markElementAsDisabled(t, e) } process(t, e, i, r) { if ("@" == i.charAt(0)) { const [o, s] = gT(i); this._timelineEngine.command(o, e, s, r) } else this._transitionEngine.trigger(t, e, i, r) } listen(t, e, i, r, o) { if ("@" == i.charAt(0)) { const [s, a] = gT(i); return this._timelineEngine.listen(s, e, a, o) } return this._transitionEngine.listen(t, e, i, r, o) } flush(t = -1) { this._transitionEngine.flush(t) } get players() { return this._transitionEngine.players.concat(this._timelineEngine.players) } whenRenderingDone() { return this._transitionEngine.whenRenderingDone() } } function UT(n, t) { let e = null, i = null; return Array.isArray(t) && t.length ? (e = i_(t[0]), t.length > 1 && (i = i_(t[t.length - 1]))) : t && (e = i_(t)), e || i ? new l5(n, e, i) : null } let l5 = (() => { class n { constructor(e, i, r) { this._element = e, this._startStyles = i, this._endStyles = r, this._state = 0; let o = n.initialStylesByElement.get(e); o || n.initialStylesByElement.set(e, o = {}), this._initialStyles = o } start() { this._state < 1 && (this._startStyles && fi(this._element, this._startStyles, this._initialStyles), this._state = 1) } finish() { this.start(), this._state < 2 && (fi(this._element, this._initialStyles), this._endStyles && (fi(this._element, this._endStyles), this._endStyles = null), this._state = 1) } destroy() { this.finish(), this._state < 3 && (n.initialStylesByElement.delete(this._element), this._startStyles && (Wr(this._element, this._startStyles), this._endStyles = null), this._endStyles && (Wr(this._element, this._endStyles), this._endStyles = null), fi(this._element, this._initialStyles), this._state = 3) } } return n.initialStylesByElement = new WeakMap, n })(); function i_(n) { let t = null; const e = Object.keys(n); for (let i = 0; i < e.length; i++) { const r = e[i]; c5(r) && (t = t || {}, t[r] = n[r]) } return t } function c5(n) { return "display" === n || "position" === n } const $T = "animation", GT = "animationend"; class h5 { constructor(t, e, i, r, o, s, a) { this._element = t, this._name = e, this._duration = i, this._delay = r, this._easing = o, this._fillMode = s, this._onDoneFn = a, this._finished = !1, this._destroyed = !1, this._startTime = 0, this._position = 0, this._eventFn = l => this._handleCallback(l) } apply() { (function f5(n, t) { const e = o_(n, "").trim(); let i = 0; e.length && (i = function g5(n, t) { let e = 0; for (let i = 0; i < n.length; i++)n.charAt(i) === t && e++; return e }(e, ",") + 1, t = `${e}, ${t}`), Fu(n, "", t) })(this._element, `${this._duration}ms ${this._easing} ${this._delay}ms 1 normal ${this._fillMode} ${this._name}`), KT(this._element, this._eventFn, !1), this._startTime = Date.now() } pause() { WT(this._element, this._name, "paused") } resume() { WT(this._element, this._name, "running") } setPosition(t) { const e = zT(this._element, this._name); this._position = t * this._duration, Fu(this._element, "Delay", `-${this._position}ms`, e) } getPosition() { return this._position } _handleCallback(t) { const e = t._ngTestManualTimestamp || Date.now(), i = 1e3 * parseFloat(t.elapsedTime.toFixed(3)); t.animationName == this._name && Math.max(e - this._startTime, 0) >= this._delay && i >= this._duration && this.finish() } finish() { this._finished || (this._finished = !0, this._onDoneFn(), KT(this._element, this._eventFn, !0)) } destroy() { this._destroyed || (this._destroyed = !0, this.finish(), function p5(n, t) { const i = o_(n, "").split(","), r = r_(i, t); r >= 0 && (i.splice(r, 1), Fu(n, "", i.join(","))) }(this._element, this._name)) } } function WT(n, t, e) { Fu(n, "PlayState", e, zT(n, t)) } function zT(n, t) { const e = o_(n, ""); return e.indexOf(",") > 0 ? r_(e.split(","), t) : r_([e], t) } function r_(n, t) { for (let e = 0; e < n.length; e++)if (n[e].indexOf(t) >= 0) return e; return -1 } function KT(n, t, e) { e ? n.removeEventListener(GT, t) : n.addEventListener(GT, t) } function Fu(n, t, e, i) { const r = $T + t; if (null != i) { const o = n.style[r]; if (o.length) { const s = o.split(","); s[i] = e, e = s.join(",") } } n.style[r] = e } function o_(n, t) { return n.style[$T + t] || "" } class qT { constructor(t, e, i, r, o, s, a, l) { this.element = t, this.keyframes = e, this.animationName = i, this._duration = r, this._delay = o, this._finalStyles = a, this._specialStyles = l, this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this.currentSnapshot = {}, this._state = 0, this.easing = s || "linear", this.totalTime = r + o, this._buildStyler() } onStart(t) { this._onStartFns.push(t) } onDone(t) { this._onDoneFns.push(t) } onDestroy(t) { this._onDestroyFns.push(t) } destroy() { this.init(), !(this._state >= 4) && (this._state = 4, this._styler.destroy(), this._flushStartFns(), this._flushDoneFns(), this._specialStyles && this._specialStyles.destroy(), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = []) } _flushDoneFns() { this._onDoneFns.forEach(t => t()), this._onDoneFns = [] } _flushStartFns() { this._onStartFns.forEach(t => t()), this._onStartFns = [] } finish() { this.init(), !(this._state >= 3) && (this._state = 3, this._styler.finish(), this._flushStartFns(), this._specialStyles && this._specialStyles.finish(), this._flushDoneFns()) } setPosition(t) { this._styler.setPosition(t) } getPosition() { return this._styler.getPosition() } hasStarted() { return this._state >= 2 } init() { this._state >= 1 || (this._state = 1, this._styler.apply(), this._delay && this._styler.pause()) } play() { this.init(), this.hasStarted() || (this._flushStartFns(), this._state = 2, this._specialStyles && this._specialStyles.start()), this._styler.resume() } pause() { this.init(), this._styler.pause() } restart() { this.reset(), this.play() } reset() { this._state = 0, this._styler.destroy(), this._buildStyler(), this._styler.apply() } _buildStyler() { this._styler = new h5(this.element, this.animationName, this._duration, this._delay, this.easing, "forwards", () => this.finish()) } triggerCallback(t) { const e = "start" == t ? this._onStartFns : this._onDoneFns; e.forEach(i => i()), e.length = 0 } beforeDestroy() { this.init(); const t = {}; if (this.hasStarted()) { const e = this._state >= 3; Object.keys(this._finalStyles).forEach(i => { "offset" != i && (t[i] = e ? this._finalStyles[i] : Wg(this.element, i)) }) } this.currentSnapshot = t } } class y5 extends ys { constructor(t, e) { super(), this.element = t, this._startingStyles = {}, this.__initialized = !1, this._styles = yT(e) } init() { this.__initialized || !this._startingStyles || (this.__initialized = !0, Object.keys(this._styles).forEach(t => { this._startingStyles[t] = this.element.style[t] }), super.init()) } play() { !this._startingStyles || (this.init(), Object.keys(this._styles).forEach(t => this.element.style.setProperty(t, this._styles[t])), super.play()) } destroy() { !this._startingStyles || (Object.keys(this._startingStyles).forEach(t => { const e = this._startingStyles[t]; e ? this.element.style.setProperty(t, e) : this.element.style.removeProperty(t) }), this._startingStyles = null, super.destroy()) } } class QT { constructor() { this._count = 0 } validateStyleProperty(t) { return Fg(t) } matchesElement(t, e) { return !1 } containsElement(t, e) { return Lg(t, e) } query(t, e, i) { return Bg(t, e, i) } computeStyle(t, e, i) { return window.getComputedStyle(t)[e] } buildKeyframeElement(t, e, i) { i = i.map(a => yT(a)); let r = `@keyframes ${e} {\n`, o = ""; i.forEach(a => { o = " "; const l = parseFloat(a.offset); r += `${o}${100 * l}% {\n`, o += " ", Object.keys(a).forEach(c => { const u = a[c]; switch (c) { case "offset": return; case "easing": return void (u && (r += `${o}animation-timing-function: ${u};\n`)); default: return void (r += `${o}${c}: ${u};\n`) } }), r += `${o}}\n` }), r += "}\n"; const s = document.createElement("style"); return s.textContent = r, s } animate(t, e, i, r, o, s = [], a) { const l = s.filter(y => y instanceof qT), c = {}; ST(i, r) && l.forEach(y => { let b = y.currentSnapshot; Object.keys(b).forEach(m => c[m] = b[m]) }); const u = function D5(n) { let t = {}; return n && (Array.isArray(n) ? n : [n]).forEach(i => { Object.keys(i).forEach(r => { "offset" == r || "easing" == r || (t[r] = i[r]) }) }), t }(e = AT(t, e, c)); if (0 == i) return new y5(t, u); const d = "gen_css_kf_" + this._count++, h = this.buildKeyframeElement(t, d, e); (function v5(n) { var t; const e = null === (t = n.getRootNode) || void 0 === t ? void 0 : t.call(n); return "undefined" != typeof ShadowRoot && e instanceof ShadowRoot ? e : document.head })(t).appendChild(h); const p = UT(t, e), _ = new qT(t, e, d, i, r, o, u, p); return _.onDestroy(() => function C5(n) { n.parentNode.removeChild(n) }(h)), _ } } class ZT { constructor(t, e, i, r) { this.element = t, this.keyframes = e, this.options = i, this._specialStyles = r, this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._initialized = !1, this._finished = !1, this._started = !1, this._destroyed = !1, this.time = 0, this.parentPlayer = null, this.currentSnapshot = {}, this._duration = i.duration, this._delay = i.delay || 0, this.time = this._duration + this._delay } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(t => t()), this._onDoneFns = []) } init() { this._buildPlayer(), this._preparePlayerBeforeStart() } _buildPlayer() { if (this._initialized) return; this._initialized = !0; const t = this.keyframes; this.domPlayer = this._triggerWebAnimation(this.element, t, this.options), this._finalKeyframe = t.length ? t[t.length - 1] : {}, this.domPlayer.addEventListener("finish", () => this._onFinish()) } _preparePlayerBeforeStart() { this._delay ? this._resetDomPlayerState() : this.domPlayer.pause() } _triggerWebAnimation(t, e, i) { return t.animate(e, i) } onStart(t) { this._onStartFns.push(t) } onDone(t) { this._onDoneFns.push(t) } onDestroy(t) { this._onDestroyFns.push(t) } play() { this._buildPlayer(), this.hasStarted() || (this._onStartFns.forEach(t => t()), this._onStartFns = [], this._started = !0, this._specialStyles && this._specialStyles.start()), this.domPlayer.play() } pause() { this.init(), this.domPlayer.pause() } finish() { this.init(), this._specialStyles && this._specialStyles.finish(), this._onFinish(), this.domPlayer.finish() } reset() { this._resetDomPlayerState(), this._destroyed = !1, this._finished = !1, this._started = !1 } _resetDomPlayerState() { this.domPlayer && this.domPlayer.cancel() } restart() { this.reset(), this.play() } hasStarted() { return this._started } destroy() { this._destroyed || (this._destroyed = !0, this._resetDomPlayerState(), this._onFinish(), this._specialStyles && this._specialStyles.destroy(), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = []) } setPosition(t) { void 0 === this.domPlayer && this.init(), this.domPlayer.currentTime = t * this.time } getPosition() { return this.domPlayer.currentTime / this.time } get totalTime() { return this._delay + this._duration } beforeDestroy() { const t = {}; if (this.hasStarted()) { const e = this._finalKeyframe; Object.keys(e).forEach(i => { "offset" != i && (t[i] = this._finished ? e[i] : Wg(this.element, i)) }) } this.currentSnapshot = t } triggerCallback(t) { const e = "start" == t ? this._onStartFns : this._onDoneFns; e.forEach(i => i()), e.length = 0 } } class E5 { constructor() { this._isNativeImpl = /\{\s*\[native\s+code\]\s*\}/.test(XT().toString()), this._cssKeyframesDriver = new QT } validateStyleProperty(t) { return Fg(t) } matchesElement(t, e) { return !1 } containsElement(t, e) { return Lg(t, e) } query(t, e, i) { return Bg(t, e, i) } computeStyle(t, e, i) { return window.getComputedStyle(t)[e] } overrideWebAnimationsSupport(t) { this._isNativeImpl = t } animate(t, e, i, r, o, s = [], a) { if (!a && !this._isNativeImpl) return this._cssKeyframesDriver.animate(t, e, i, r, o, s); const u = { duration: i, delay: r, fill: 0 == r ? "both" : "forwards" }; o && (u.easing = o); const d = {}, h = s.filter(p => p instanceof ZT); ST(i, r) && h.forEach(p => { let _ = p.currentSnapshot; Object.keys(_).forEach(y => d[y] = _[y]) }); const f = UT(t, e = AT(t, e = e.map(p => cr(p, !1)), d)); return new ZT(t, e, u, f) } } function XT() { return fT() && Element.prototype.animate || {} } let T5 = (() => { class n extends cT { constructor(e, i) { super(), this._nextAnimationId = 0, this._renderer = e.createRenderer(i.body, { id: "0", encapsulation: In.None, styles: [], data: { animation: [] } }) } build(e) { const i = this._nextAnimationId.toString(); this._nextAnimationId++; const r = Array.isArray(e) ? uT(e) : e; return eS(this._renderer, null, i, "register", [r]), new S5(i, this._renderer) } } return n.\u0275fac = function(e) { return new (e || n)(E(Ho), E(De)) }, n.\u0275prov = R({ token: n, factory: n.\u0275fac }), n })(); class S5 extends class c8 { }{ constructor(t, e) { super(), this._id = t, this._renderer = e } create(t, e) { return new A5(this._id, t, e || {}, this._renderer) } } class A5 { constructor(t, e, i, r) { this.id = t, this.element = e, this._renderer = r, this.parentPlayer = null, this._started = !1, this.totalTime = 0, this._command("create", i) } _listen(t, e) { return this._renderer.listen(this.element, `@@${this.id}:${t}`, e) } _command(t, ...e) { return eS(this._renderer, this.element, this.id, t, e) } onDone(t) { this._listen("done", t) } onStart(t) { this._listen("start", t) } onDestroy(t) { this._listen("destroy", t) } init() { this._command("init") } hasStarted() { return this._started } play() { this._command("play"), this._started = !0 } pause() { this._command("pause") } restart() { this._command("restart") } finish() { this._command("finish") } destroy() { this._command("destroy") } reset() { this._command("reset"), this._started = !1 } setPosition(t) { this._command("setPosition", t) } getPosition() { var t, e; return null !== (e = null === (t = this._renderer.engine.players[+this.id]) || void 0 === t ? void 0 : t.getPosition()) && void 0 !== e ? e : 0 } } function eS(n, t, e, i, r) { return n.setProperty(t, `@@${e}:${i}`, r) } const tS = "@.disabled"; let M5 = (() => { class n { constructor(e, i, r) { this.delegate = e, this.engine = i, this._zone = r, this._currentId = 0, this._microtaskId = 1, this._animationCallbacksBuffer = [], this._rendererCache = new Map, this._cdRecurDepth = 0, this.promise = Promise.resolve(0), i.onRemovalComplete = (o, s) => { const a = null == s ? void 0 : s.parentNode(o); a && s.removeChild(a, o) } } createRenderer(e, i) { const o = this.delegate.createRenderer(e, i); if (!(e && i && i.data && i.data.animation)) { let u = this._rendererCache.get(o); return u || (u = new nS("", o, this.engine), this._rendererCache.set(o, u)), u } const s = i.id, a = i.id + "-" + this._currentId; this._currentId++, this.engine.register(a, e); const l = u => { Array.isArray(u) ? u.forEach(l) : this.engine.registerTrigger(s, a, e, u.name, u) }; return i.data.animation.forEach(l), new N5(this, a, o, this.engine) } begin() { this._cdRecurDepth++, this.delegate.begin && this.delegate.begin() } _scheduleCountTask() { this.promise.then(() => { this._microtaskId++ }) } scheduleListenerCallback(e, i, r) { e >= 0 && e < this._microtaskId ? this._zone.run(() => i(r)) : (0 == this._animationCallbacksBuffer.length && Promise.resolve(null).then(() => { this._zone.run(() => { this._animationCallbacksBuffer.forEach(o => { const [s, a] = o; s(a) }), this._animationCallbacksBuffer = [] }) }), this._animationCallbacksBuffer.push([i, r])) } end() { this._cdRecurDepth--, 0 == this._cdRecurDepth && this._zone.runOutsideAngular(() => { this._scheduleCountTask(), this.engine.flush(this._microtaskId) }), this.delegate.end && this.delegate.end() } whenRenderingDone() { return this.engine.whenRenderingDone() } } return n.\u0275fac = function(e) { return new (e || n)(E(Ho), E(ku), E(he)) }, n.\u0275prov = R({ token: n, factory: n.\u0275fac }), n })(); class nS { constructor(t, e, i) { this.namespaceId = t, this.delegate = e, this.engine = i, this.destroyNode = this.delegate.destroyNode ? r => e.destroyNode(r) : null } get data() { return this.delegate.data } destroy() { this.engine.destroy(this.namespaceId, this.delegate), this.delegate.destroy() } createElement(t, e) { return this.delegate.createElement(t, e) } createComment(t) { return this.delegate.createComment(t) } createText(t) { return this.delegate.createText(t) } appendChild(t, e) { this.delegate.appendChild(t, e), this.engine.onInsert(this.namespaceId, e, t, !1) } insertBefore(t, e, i, r = !0) { this.delegate.insertBefore(t, e, i), this.engine.onInsert(this.namespaceId, e, t, r) } removeChild(t, e, i) { this.engine.onRemove(this.namespaceId, e, this.delegate, i) } selectRootElement(t, e) { return this.delegate.selectRootElement(t, e) } parentNode(t) { return this.delegate.parentNode(t) } nextSibling(t) { return this.delegate.nextSibling(t) } setAttribute(t, e, i, r) { this.delegate.setAttribute(t, e, i, r) } removeAttribute(t, e, i) { this.delegate.removeAttribute(t, e, i) } addClass(t, e) { this.delegate.addClass(t, e) } removeClass(t, e) { this.delegate.removeClass(t, e) } setStyle(t, e, i, r) { this.delegate.setStyle(t, e, i, r) } removeStyle(t, e, i) { this.delegate.removeStyle(t, e, i) } setProperty(t, e, i) { "@" == e.charAt(0) && e == tS ? this.disableAnimations(t, !!i) : this.delegate.setProperty(t, e, i) } setValue(t, e) { this.delegate.setValue(t, e) } listen(t, e, i) { return this.delegate.listen(t, e, i) } disableAnimations(t, e) { this.engine.disableAnimations(t, e) } } class N5 extends nS { constructor(t, e, i, r) { super(e, i, r), this.factory = t, this.namespaceId = e } setProperty(t, e, i) { "@" == e.charAt(0) ? "." == e.charAt(1) && e == tS ? this.disableAnimations(t, i = void 0 === i || !!i) : this.engine.process(this.namespaceId, t, e.substr(1), i) : this.delegate.setProperty(t, e, i) } listen(t, e, i) { if ("@" == e.charAt(0)) { const r = function I5(n) { switch (n) { case "body": return document.body; case "document": return document; case "window": return window; default: return n } }(t); let o = e.substr(1), s = ""; return "@" != o.charAt(0) && ([o, s] = function R5(n) { const t = n.indexOf("."); return [n.substring(0, t), n.substr(t + 1)] }(o)), this.engine.listen(this.namespaceId, r, o, s, a => { this.factory.scheduleListenerCallback(a._data || -1, i, a) }) } return this.delegate.listen(t, e, i) } } let O5 = (() => { class n extends ku { constructor(e, i, r) { super(e.body, i, r) } ngOnDestroy() { this.flush() } } return n.\u0275fac = function(e) { return new (e || n)(E(De), E(Vg), E(Jg)) }, n.\u0275prov = R({ token: n, factory: n.\u0275fac }), n })(); const pi = new P("AnimationModuleType"), iS = [{ provide: cT, useClass: T5 }, { provide: Jg, useFactory: function P5() { return new L8 } }, { provide: ku, useClass: O5 }, { provide: Ho, useFactory: function k5(n, t, e) { return new M5(n, t, e) }, deps: [Mc, ku, he] }], rS = [{ provide: Vg, useFactory: function x5() { return function w5() { return "function" == typeof XT() }() ? new E5 : new QT } }, { provide: pi, useValue: "BrowserAnimations" }, ...iS], F5 = [{ provide: Vg, useClass: bT }, { provide: pi, useValue: "NoopAnimations" }, ...iS]; let L5 = (() => { class n { static withConfig(e) { return { ngModule: n, providers: e.disableAnimations ? F5 : rS } } } return n.\u0275fac = function(e) { return new (e || n) }, n.\u0275mod = se({ type: n }), n.\u0275inj = te({ providers: rS, imports: [ZD] }), n })(); const V5 = new P("mat-sanity-checks", { providedIn: "root", factory: function B5() { return !0 } }); let ur = (() => { class n { constructor(e, i, r) { this._sanityChecks = i, this._document = r, this._hasDoneGlobalChecks = !1, e._applyBodyHighContrastModeCssClasses(), this._hasDoneGlobalChecks || (this._hasDoneGlobalChecks = !0) } _checkIsEnabled(e) { return !function _3() { return "undefined" != typeof __karma__ && !!__karma__ || "undefined" != typeof jasmine && !!jasmine || "undefined" != typeof jest && !!jest || "undefined" != typeof Mocha && !!Mocha }() && ("boolean" == typeof this._sanityChecks ? this._sanityChecks : !!this._sanityChecks[e]) } } return n.\u0275fac = function(e) { return new (e || n)(E(sT), E(V5, 8), E(De)) }, n.\u0275mod = se({ type: n }), n.\u0275inj = te({ imports: [[aT], aT] }), n })(); function s_(n) { return class extends n { constructor(...t) { super(...t), this._disabled = !1 } get disabled() { return this._disabled } set disabled(t) { this._disabled = gs(t) } } } function a_(n, t) { return class extends n { constructor(...e) { super(...e), this.defaultColor = t, this.color = t } get color() { return this._color } set color(e) { const i = e || this.defaultColor; i !== this._color && (this._color && this._elementRef.nativeElement.classList.remove(`mat-${this._color}`), i && this._elementRef.nativeElement.classList.add(`mat-${i}`), this._color = i) } } } function sS(n) { return class extends n { constructor(...t) { super(...t), this._disableRipple = !1 } get disableRipple() { return this._disableRipple } set disableRipple(t) { this._disableRipple = gs(t) } } } class j5 { constructor(t, e, i) { this._renderer = t, this.element = e, this.config = i, this.state = 3 } fadeOut() { this._renderer.fadeOutRipple(this) } } const aS = { enterDuration: 225, exitDuration: 150 }, l_ = mu({ passive: !0 }), lS = ["mousedown", "touchstart"], cS = ["mouseup", "mouseleave", "touchend", "touchcancel"]; class $5 { constructor(t, e, i, r) { this._target = t, this._ngZone = e, this._isPointerDown = !1, this._activeRipples = new Set, this._pointerUpEventsRegistered = !1, r.isBrowser && (this._containerElement = _s(i)) } fadeInRipple(t, e, i = {}) { const r = this._containerRect = this._containerRect || this._containerElement.getBoundingClientRect(), o = Object.assign(Object.assign({}, aS), i.animation); i.centered && (t = r.left + r.width / 2, e = r.top + r.height / 2); const s = i.radius || function W5(n, t, e) { const i = Math.max(Math.abs(n - e.left), Math.abs(n - e.right)), r = Math.max(Math.abs(t - e.top), Math.abs(t - e.bottom)); return Math.sqrt(i * i + r * r) }(t, e, r), a = t - r.left, l = e - r.top, c = o.enterDuration, u = document.createElement("div"); u.classList.add("mat-ripple-element"), u.style.left = a - s + "px", u.style.top = l - s + "px", u.style.height = 2 * s + "px", u.style.width = 2 * s + "px", null != i.color && (u.style.backgroundColor = i.color), u.style.transitionDuration = `${c}ms`, this._containerElement.appendChild(u), function G5(n) { window.getComputedStyle(n).getPropertyValue("opacity") }(u), u.style.transform = "scale(1)"; const d = new j5(this, u, i); return d.state = 0, this._activeRipples.add(d), i.persistent || (this._mostRecentTransientRipple = d), this._runTimeoutOutsideZone(() => { const h = d === this._mostRecentTransientRipple; d.state = 1, !i.persistent && (!h || !this._isPointerDown) && d.fadeOut() }, c), d } fadeOutRipple(t) { const e = this._activeRipples.delete(t); if (t === this._mostRecentTransientRipple && (this._mostRecentTransientRipple = null), this._activeRipples.size || (this._containerRect = null), !e) return; const i = t.element, r = Object.assign(Object.assign({}, aS), t.config.animation); i.style.transitionDuration = `${r.exitDuration}ms`, i.style.opacity = "0", t.state = 2, this._runTimeoutOutsideZone(() => { t.state = 3, i.remove() }, r.exitDuration) } fadeOutAll() { this._activeRipples.forEach(t => t.fadeOut()) } fadeOutAllNonPersistent() { this._activeRipples.forEach(t => { t.config.persistent || t.fadeOut() }) } setupTriggerEvents(t) { const e = _s(t); !e || e === this._triggerElement || (this._removeTriggerEvents(), this._triggerElement = e, this._registerEvents(lS)) } handleEvent(t) { "mousedown" === t.type ? this._onMousedown(t) : "touchstart" === t.type ? this._onTouchStart(t) : this._onPointerUp(), this._pointerUpEventsRegistered || (this._registerEvents(cS), this._pointerUpEventsRegistered = !0) } _onMousedown(t) { const e = eT(t), i = this._lastTouchStartEvent && Date.now() < this._lastTouchStartEvent + 800; !this._target.rippleDisabled && !e && !i && (this._isPointerDown = !0, this.fadeInRipple(t.clientX, t.clientY, this._target.rippleConfig)) } _onTouchStart(t) { if (!this._target.rippleDisabled && !tT(t)) { this._lastTouchStartEvent = Date.now(), this._isPointerDown = !0; const e = t.changedTouches; for (let i = 0; i < e.length; i++)this.fadeInRipple(e[i].clientX, e[i].clientY, this._target.rippleConfig) } } _onPointerUp() { !this._isPointerDown || (this._isPointerDown = !1, this._activeRipples.forEach(t => { !t.config.persistent && (1 === t.state || t.config.terminateOnPointerUp && 0 === t.state) && t.fadeOut() })) } _runTimeoutOutsideZone(t, e = 0) { this._ngZone.runOutsideAngular(() => setTimeout(t, e)) } _registerEvents(t) { this._ngZone.runOutsideAngular(() => { t.forEach(e => { this._triggerElement.addEventListener(e, this, l_) }) }) } _removeTriggerEvents() { this._triggerElement && (lS.forEach(t => { this._triggerElement.removeEventListener(t, this, l_) }), this._pointerUpEventsRegistered && cS.forEach(t => { this._triggerElement.removeEventListener(t, this, l_) })) } } const z5 = new P("mat-ripple-global-options"); let Bu = (() => { class n { constructor(e, i, r, o, s) { this._elementRef = e, this._animationMode = s, this.radius = 0, this._disabled = !1, this._isInitialized = !1, this._globalOptions = o || {}, this._rippleRenderer = new $5(this, i, e, r) } get disabled() { return this._disabled } set disabled(e) { e && this.fadeOutAllNonPersistent(), this._disabled = e, this._setupTriggerEventsIfEnabled() } get trigger() { return this._trigger || this._elementRef.nativeElement } set trigger(e) { this._trigger = e, this._setupTriggerEventsIfEnabled() } ngOnInit() { this._isInitialized = !0, this._setupTriggerEventsIfEnabled() } ngOnDestroy() { this._rippleRenderer._removeTriggerEvents() } fadeOutAll() { this._rippleRenderer.fadeOutAll() } fadeOutAllNonPersistent() { this._rippleRenderer.fadeOutAllNonPersistent() } get rippleConfig() { return { centered: this.centered, radius: this.radius, color: this.color, animation: Object.assign(Object.assign(Object.assign({}, this._globalOptions.animation), "NoopAnimations" === this._animationMode ? { enterDuration: 0, exitDuration: 0 } : {}), this.animation), terminateOnPointerUp: this._globalOptions.terminateOnPointerUp } } get rippleDisabled() { return this.disabled || !!this._globalOptions.disabled } _setupTriggerEventsIfEnabled() { !this.disabled && this._isInitialized && this._rippleRenderer.setupTriggerEvents(this.trigger) } launch(e, i = 0, r) { return "number" == typeof e ? this._rippleRenderer.fadeInRipple(e, i, Object.assign(Object.assign({}, this.rippleConfig), r)) : this._rippleRenderer.fadeInRipple(0, 0, Object.assign(Object.assign({}, this.rippleConfig), e)) } } return n.\u0275fac = function(e) { return new (e || n)(g(X), g(he), g(ar), g(z5, 8), g(pi, 8)) }, n.\u0275dir = S({ type: n, selectors: [["", "mat-ripple", ""], ["", "matRipple", ""]], hostAttrs: [1, "mat-ripple"], hostVars: 2, hostBindings: function(e, i) { 2 & e && de("mat-ripple-unbounded", i.unbounded) }, inputs: { color: ["matRippleColor", "color"], unbounded: ["matRippleUnbounded", "unbounded"], centered: ["matRippleCentered", "centered"], radius: ["matRippleRadius", "radius"], animation: ["matRippleAnimation", "animation"], disabled: ["matRippleDisabled", "disabled"], trigger: ["matRippleTrigger", "trigger"] }, exportAs: ["matRipple"] }), n })(), uS = (() => { class n { } return n.\u0275fac = function(e) { return new (e || n) }, n.\u0275mod = se({ type: n }), n.\u0275inj = te({ imports: [[ur], ur] }), n })(); const il = { schedule(n) { let t = requestAnimationFrame, e = cancelAnimationFrame; const { delegate: i } = il; i && (t = i.requestAnimationFrame, e = i.cancelAnimationFrame); const r = t(o => { e = void 0, n(o) }); return new Ze(() => null == e ? void 0 : e(r)) }, requestAnimationFrame(...n) { const { delegate: t } = il; return ((null == t ? void 0 : t.requestAnimationFrame) || requestAnimationFrame)(...n) }, cancelAnimationFrame(...n) { const { delegate: t } = il; return ((null == t ? void 0 : t.cancelAnimationFrame) || cancelAnimationFrame)(...n) }, delegate: void 0 }; new class q5 extends Ip { flush(t) { this._active = !0, this._scheduled = void 0; const { actions: e } = this; let i, r = -1; t = t || e.shift(); const o = e.length; do { if (i = t.execute(t.state, t.delay)) break } while (++r < o && (t = e.shift())); if (this._active = !1, i) { for (; ++r < o && (t = e.shift());)t.unsubscribe(); throw i } } }(class K5 extends Np { constructor(t, e) { super(t, e), this.scheduler = t, this.work = e } requestAsyncId(t, e, i = 0) { return null !== i && i > 0 ? super.requestAsyncId(t, e, i) : (t.actions.push(this), t._scheduled || (t._scheduled = il.requestAnimationFrame(() => t.flush(void 0)))) } recycleAsyncId(t, e, i = 0) { if (null != i && i > 0 || null == i && this.delay > 0) return super.recycleAsyncId(t, e, i); 0 === t.actions.length && (il.cancelAnimationFrame(e), t._scheduled = void 0) } }); let c_, Q5 = 1; const Vu = {}; function dS(n) { return n in Vu && (delete Vu[n], !0) } const J5 = { setImmediate(n) { const t = Q5++; return Vu[t] = !0, c_ || (c_ = Promise.resolve()), c_.then(() => dS(t) && n()), t }, clearImmediate(n) { dS(n) } }, { setImmediate: Z5, clearImmediate: X5 } = J5, Hu = { setImmediate(...n) { const { delegate: t } = Hu; return ((null == t ? void 0 : t.setImmediate) || Z5)(...n) }, clearImmediate(n) { const { delegate: t } = Hu; return ((null == t ? void 0 : t.clearImmediate) || X5)(n) }, delegate: void 0 }; new class tG extends Ip { flush(t) { this._active = !0, this._scheduled = void 0; const { actions: e } = this; let i, r = -1; t = t || e.shift(); const o = e.length; do { if (i = t.execute(t.state, t.delay)) break } while (++r < o && (t = e.shift())); if (this._active = !1, i) { for (; ++r < o && (t = e.shift());)t.unsubscribe(); throw i } } }(class eG extends Np { constructor(t, e) { super(t, e), this.scheduler = t, this.work = e } requestAsyncId(t, e, i = 0) { return null !== i && i > 0 ? super.requestAsyncId(t, e, i) : (t.actions.push(this), t._scheduled || (t._scheduled = Hu.setImmediate(t.flush.bind(t, void 0)))) } recycleAsyncId(t, e, i = 0) { if (null != i && i > 0 || null == i && this.delay > 0) return super.recycleAsyncId(t, e, i); 0 === t.actions.length && (Hu.clearImmediate(e), t._scheduled = void 0) } }); let u_ = (() => { class n { constructor(e, i, r) { this._platform = e, this._change = new be, this._changeListener = o => { this._change.next(o) }, this._document = r, i.runOutsideAngular(() => { if (e.isBrowser) { const o = this._getWindow(); o.addEventListener("resize", this._changeListener), o.addEventListener("orientationchange", this._changeListener) } this.change().subscribe(() => this._viewportSize = null) }) } ngOnDestroy() { if (this._platform.isBrowser) { const e = this._getWindow(); e.removeEventListener("resize", this._changeListener), e.removeEventListener("orientationchange", this._changeListener) } this._change.complete() } getViewportSize() { this._viewportSize || this._updateViewportSize(); const e = { width: this._viewportSize.width, height: this._viewportSize.height }; return this._platform.isBrowser || (this._viewportSize = null), e } getViewportRect() { const e = this.getViewportScrollPosition(), { width: i, height: r } = this.getViewportSize(); return { top: e.top, left: e.left, bottom: e.top + r, right: e.left + i, height: r, width: i } } getViewportScrollPosition() { if (!this._platform.isBrowser) return { top: 0, left: 0 }; const e = this._document, i = this._getWindow(), r = e.documentElement, o = r.getBoundingClientRect(); return { top: -o.top || e.body.scrollTop || i.scrollY || r.scrollTop || 0, left: -o.left || e.body.scrollLeft || i.scrollX || r.scrollLeft || 0 } } change(e = 20) { return e > 0 ? this._change.pipe(function rG(n, t = CC) { return function iG(n) { return Ge((t, e) => { let i = !1, r = null, o = null, s = !1; const a = () => { if (null == o || o.unsubscribe(), o = null, i) { i = !1; const c = r; r = null, e.next(c) } s && e.complete() }, l = () => { o = null, s && e.complete() }; t.subscribe(new Ie(e, c => { i = !0, r = c, o || Et(n(c)).subscribe(o = new Ie(e, a, l)) }, () => { s = !0, (!i || !o || o.closed) && e.complete() })) }) }(() => Ra(n, t)) }(e)) : this._change } _getWindow() { return this._document.defaultView || window } _updateViewportSize() { const e = this._getWindow(); this._viewportSize = this._platform.isBrowser ? { width: e.innerWidth, height: e.innerHeight } : { width: 0, height: 0 } } } return n.\u0275fac = function(e) { return new (e || n)(E(ar), E(he), E(De, 8)) }, n.\u0275prov = R({ token: n, factory: n.\u0275fac, providedIn: "root" }), n })(); function sG(n, t) { 1 & n && ko(0) } const hS = ["*"]; function aG(n, t) { } const lG = function(n) { return { animationDuration: n } }, cG = function(n, t) { return { value: n, params: t } }, uG = ["tabListContainer"], dG = ["tabList"], hG = ["tabListInner"], fG = ["nextPaginator"], pG = ["previousPaginator"], gG = ["tabBodyWrapper"], _G = ["tabHeader"]; function mG(n, t) { } function yG(n, t) { 1 & n && j(0, mG, 0, 0, "ng-template", 10), 2 & n && F("cdkPortalOutlet", K().$implicit.templateLabel) } function bG(n, t) { 1 & n && q(0), 2 & n && Vn(K().$implicit.textLabel) } function vG(n, t) { if (1 & n) { const e = Dt(); v(0, "div", 6), B("click", function() { const r = ze(e), o = r.$implicit, s = r.index, a = K(), l = ht(1); return a._handleClick(o, l, s) })("cdkFocusChange", function(r) { const s = ze(e).index; return K()._tabFocusChanged(r, s) }), v(1, "div", 7), j(2, yG, 1, 1, "ng-template", 8), j(3, bG, 1, 1, "ng-template", null, 9, jn), D(), D() } if (2 & n) { const e = t.$implicit, i = t.index, r = ht(4), o = K(); de("mat-tab-label-active", o.selectedIndex === i), F("id", o._getTabLabelId(i))("ngClass", e.labelClass)("disabled", e.disabled)("matRippleDisabled", e.disabled || o.disableRipple), ve("tabIndex", o._getTabIndex(e, i))("aria-posinset", i + 1)("aria-setsize", o._tabs.length)("aria-controls", o._getTabContentId(i))("aria-selected", o.selectedIndex === i)("aria-label", e.ariaLabel || null)("aria-labelledby", !e.ariaLabel && e.ariaLabelledby ? e.ariaLabelledby : null), O(2), F("ngIf", e.templateLabel)("ngIfElse", r) } } function DG(n, t) { if (1 & n) { const e = Dt(); v(0, "mat-tab-body", 11), B("_onCentered", function() { return ze(e), K()._removeTabBodyWrapperHeight() })("_onCentering", function(r) { return ze(e), K()._setTabBodyWrapperHeight(r) }), D() } if (2 & n) { const e = t.$implicit, i = t.index, r = K(); de("mat-tab-body-active", r.selectedIndex === i), F("id", r._getTabContentId(i))("ngClass", e.bodyClass)("content", e.content)("position", e.position)("origin", e.origin)("animationDuration", r.animationDuration), ve("tabindex", null != r.contentTabIndex && r.selectedIndex === i ? r.contentTabIndex : null)("aria-labelledby", r._getTabLabelId(i)) } } const CG = new P("MatInkBarPositioner", { providedIn: "root", factory: function EG() { return t => ({ left: t ? (t.offsetLeft || 0) + "px" : "0", width: t ? (t.offsetWidth || 0) + "px" : "0" }) } }); let fS = (() => { class n { constructor(e, i, r, o) { this._elementRef = e, this._ngZone = i, this._inkBarPositioner = r, this._animationMode = o } alignToElement(e) { this.show(), this._ngZone.onStable.pipe(ct(1)).subscribe(() => { const i = this._inkBarPositioner(e), r = this._elementRef.nativeElement; r.style.left = i.left, r.style.width = i.width }) } show() { this._elementRef.nativeElement.style.visibility = "visible" } hide() { this._elementRef.nativeElement.style.visibility = "hidden" } } return n.\u0275fac = function(e) { return new (e || n)(g(X), g(he), g(CG), g(pi, 8)) }, n.\u0275dir = S({ type: n, selectors: [["mat-ink-bar"]], hostAttrs: [1, "mat-ink-bar"], hostVars: 2, hostBindings: function(e, i) { 2 & e && de("_mat-animation-noopable", "NoopAnimations" === i._animationMode) } }), n })(); const wG = new P("MatTabContent"), pS = new P("MatTabLabel"), gS = new P("MAT_TAB"); let TG = (() => { class n extends i8 { constructor(e, i, r) { super(e, i), this._closestTab = r } } return n.\u0275fac = function(e) { return new (e || n)(g(ke), g(Rt), g(gS, 8)) }, n.\u0275dir = S({ type: n, selectors: [["", "mat-tab-label", ""], ["", "matTabLabel", ""]], features: [Se([{ provide: pS, useExisting: n }]), ie] }), n })(); const SG = s_(class { }), _S = new P("MAT_TAB_GROUP"); let mS = (() => { class n extends SG { constructor(e, i) { super(), this._viewContainerRef = e, this._closestTabGroup = i, this.textLabel = "", this._contentPortal = null, this._stateChanges = new be, this.position = null, this.origin = null, this.isActive = !1 } get templateLabel() { return this._templateLabel } set templateLabel(e) { this._setTemplateLabelInput(e) } get content() { return this._contentPortal } ngOnChanges(e) { (e.hasOwnProperty("textLabel") || e.hasOwnProperty("disabled")) && this._stateChanges.next() } ngOnDestroy() { this._stateChanges.complete() } ngOnInit() { this._contentPortal = new Tg(this._explicitContent || this._implicitContent, this._viewContainerRef) } _setTemplateLabelInput(e) { e && e._closestTab === this && (this._templateLabel = e) } } return n.\u0275fac = function(e) { return new (e || n)(g(Rt), g(_S, 8)) }, n.\u0275cmp = We({ type: n, selectors: [["mat-tab"]], contentQueries: function(e, i, r) { if (1 & e && (Ve(r, pS, 5), Ve(r, wG, 7, ke)), 2 & e) { let o; le(o = ce()) && (i.templateLabel = o.first), le(o = ce()) && (i._explicitContent = o.first) } }, viewQuery: function(e, i) { if (1 & e && qt(ke, 7), 2 & e) { let r; le(r = ce()) && (i._implicitContent = r.first) } }, inputs: { disabled: "disabled", textLabel: ["label", "textLabel"], ariaLabel: ["aria-label", "ariaLabel"], ariaLabelledby: ["aria-labelledby", "ariaLabelledby"], labelClass: "labelClass", bodyClass: "bodyClass" }, exportAs: ["matTab"], features: [Se([{ provide: gS, useExisting: n }]), ie, wt], ngContentSelectors: hS, decls: 1, vars: 0, template: function(e, i) { 1 & e && (Po(), j(0, sG, 1, 0, "ng-template")) }, encapsulation: 2 }), n })(); const AG = { translateTab: u8("translateTab", [Mg("center, void, left-origin-center, right-origin-center", Ur({ transform: "none" })), Mg("left", Ur({ transform: "translate3d(-100%, 0, 0)", minHeight: "1px" })), Mg("right", Ur({ transform: "translate3d(100%, 0, 0)", minHeight: "1px" })), Ng("* => left, * => right, left => center, right => center", Ag("{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)")), Ng("void => left-origin-center", [Ur({ transform: "translate3d(-100%, 0, 0)" }), Ag("{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)")]), Ng("void => right-origin-center", [Ur({ transform: "translate3d(100%, 0, 0)" }), Ag("{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)")])]) }; let MG = (() => { class n extends Sg { constructor(e, i, r, o) { super(e, i, o), this._host = r, this._centeringSub = Ze.EMPTY, this._leavingSub = Ze.EMPTY } ngOnInit() { super.ngOnInit(), this._centeringSub = this._host._beforeCentering.pipe(Qo(this._host._isCenterPosition(this._host._position))).subscribe(e => { e && !this.hasAttached() && this.attach(this._host._content) }), this._leavingSub = this._host._afterLeavingCenter.subscribe(() => { this.detach() }) } ngOnDestroy() { super.ngOnDestroy(), this._centeringSub.unsubscribe(), this._leavingSub.unsubscribe() } } return n.\u0275fac = function(e) { return new (e || n)(g(wi), g(Rt), g(ge(() => yS)), g(De)) }, n.\u0275dir = S({ type: n, selectors: [["", "matTabBodyHost", ""]], features: [ie] }), n })(), NG = (() => { class n { constructor(e, i, r) { this._elementRef = e, this._dir = i, this._dirChangeSubscription = Ze.EMPTY, this._translateTabComplete = new be, this._onCentering = new L, this._beforeCentering = new L, this._afterLeavingCenter = new L, this._onCentered = new L(!0), this.animationDuration = "500ms", i && (this._dirChangeSubscription = i.change.subscribe(o => { this._computePositionAnimationState(o), r.markForCheck() })), this._translateTabComplete.pipe(Oa((o, s) => o.fromState === s.fromState && o.toState === s.toState)).subscribe(o => { this._isCenterPosition(o.toState) && this._isCenterPosition(this._position) && this._onCentered.emit(), this._isCenterPosition(o.fromState) && !this._isCenterPosition(this._position) && this._afterLeavingCenter.emit() }) } set position(e) { this._positionIndex = e, this._computePositionAnimationState() } ngOnInit() { "center" == this._position && null != this.origin && (this._position = this._computePositionFromOrigin(this.origin)) } ngOnDestroy() { this._dirChangeSubscription.unsubscribe(), this._translateTabComplete.complete() } _onTranslateTabStarted(e) { const i = this._isCenterPosition(e.toState); this._beforeCentering.emit(i), i && this._onCentering.emit(this._elementRef.nativeElement.clientHeight) } _getLayoutDirection() { return this._dir && "rtl" === this._dir.value ? "rtl" : "ltr" } _isCenterPosition(e) { return "center" == e || "left-origin-center" == e || "right-origin-center" == e } _computePositionAnimationState(e = this._getLayoutDirection()) { this._position = this._positionIndex < 0 ? "ltr" == e ? "left" : "right" : this._positionIndex > 0 ? "ltr" == e ? "right" : "left" : "center" } _computePositionFromOrigin(e) { const i = this._getLayoutDirection(); return "ltr" == i && e <= 0 || "rtl" == i && e > 0 ? "left-origin-center" : "right-origin-center" } } return n.\u0275fac = function(e) { return new (e || n)(g(X), g(Xa, 8), g(Tt)) }, n.\u0275dir = S({ type: n, inputs: { _content: ["content", "_content"], origin: "origin", animationDuration: "animationDuration", position: "position" }, outputs: { _onCentering: "_onCentering", _beforeCentering: "_beforeCentering", _afterLeavingCenter: "_afterLeavingCenter", _onCentered: "_onCentered" } }), n })(), yS = (() => { class n extends NG { constructor(e, i, r) { super(e, i, r) } } return n.\u0275fac = function(e) { return new (e || n)(g(X), g(Xa, 8), g(Tt)) }, n.\u0275cmp = We({ type: n, selectors: [["mat-tab-body"]], viewQuery: function(e, i) { if (1 & e && qt(Sg, 5), 2 & e) { let r; le(r = ce()) && (i._portalHost = r.first) } }, hostAttrs: [1, "mat-tab-body"], features: [ie], decls: 3, vars: 6, consts: [["cdkScrollable", "", 1, "mat-tab-body-content"], ["content", ""], ["matTabBodyHost", ""]], template: function(e, i) { 1 & e && (v(0, "div", 0, 1), B("@translateTab.start", function(o) { return i._onTranslateTabStarted(o) })("@translateTab.done", function(o) { return i._translateTabComplete.next(o) }), j(2, aG, 0, 0, "ng-template", 2), D()), 2 & e && F("@translateTab", Uo(3, cG, i._position, oa(1, lG, i.animationDuration))) }, directives: [MG], styles: ['.mat-tab-body-content{height:100%;overflow:auto}.mat-tab-group-dynamic-height .mat-tab-body-content{overflow:hidden}.mat-tab-body-content[style*="visibility: hidden"]{display:none}\n'], encapsulation: 2, data: { animation: [AG.translateTab] } }), n })(); const bS = new P("MAT_TABS_CONFIG"), IG = s_(class { }); let vS = (() => { class n extends IG { constructor(e) { super(), this.elementRef = e } focus() { this.elementRef.nativeElement.focus() } getOffsetLeft() { return this.elementRef.nativeElement.offsetLeft } getOffsetWidth() { return this.elementRef.nativeElement.offsetWidth } } return n.\u0275fac = function(e) { return new (e || n)(g(X)) }, n.\u0275dir = S({ type: n, selectors: [["", "matTabLabelWrapper", ""]], hostVars: 3, hostBindings: function(e, i) { 2 & e && (ve("aria-disabled", !!i.disabled), de("mat-tab-disabled", i.disabled)) }, inputs: { disabled: "disabled" }, features: [ie] }), n })(); const DS = mu({ passive: !0 }); let xG = (() => { class n { constructor(e, i, r, o, s, a, l) { this._elementRef = e, this._changeDetectorRef = i, this._viewportRuler = r, this._dir = o, this._ngZone = s, this._platform = a, this._animationMode = l, this._scrollDistance = 0, this._selectedIndexChanged = !1, this._destroyed = new be, this._showPaginationControls = !1, this._disableScrollAfter = !0, this._disableScrollBefore = !0, this._stopScrolling = new be, this.disablePagination = !1, this._selectedIndex = 0, this.selectFocusedIndex = new L, this.indexFocused = new L, s.runOutsideAngular(() => { Ct(e.nativeElement, "mouseleave").pipe(Le(this._destroyed)).subscribe(() => { this._stopInterval() }) }) } get selectedIndex() { return this._selectedIndex } set selectedIndex(e) { e = bu(e), this._selectedIndex != e && (this._selectedIndexChanged = !0, this._selectedIndex = e, this._keyManager && this._keyManager.updateActiveItem(e)) } ngAfterViewInit() { Ct(this._previousPaginator.nativeElement, "touchstart", DS).pipe(Le(this._destroyed)).subscribe(() => { this._handlePaginatorPress("before") }), Ct(this._nextPaginator.nativeElement, "touchstart", DS).pipe(Le(this._destroyed)).subscribe(() => { this._handlePaginatorPress("after") }) } ngAfterContentInit() { const e = this._dir ? this._dir.change : U("ltr"), i = this._viewportRuler.change(150), r = () => { this.updatePagination(), this._alignInkBarToSelectedTab() }; this._keyManager = new j3(this._items).withHorizontalOrientation(this._getLayoutDirection()).withHomeAndEnd().withWrap(), this._keyManager.updateActiveItem(this._selectedIndex), this._ngZone.onStable.pipe(ct(1)).subscribe(r), ul(e, i, this._items.changes).pipe(Le(this._destroyed)).subscribe(() => { this._ngZone.run(() => Promise.resolve().then(r)), this._keyManager.withHorizontalOrientation(this._getLayoutDirection()) }), this._keyManager.change.pipe(Le(this._destroyed)).subscribe(o => { this.indexFocused.emit(o), this._setTabFocus(o) }) } ngAfterContentChecked() { this._tabLabelCount != this._items.length && (this.updatePagination(), this._tabLabelCount = this._items.length, this._changeDetectorRef.markForCheck()), this._selectedIndexChanged && (this._scrollToLabel(this._selectedIndex), this._checkScrollingControls(), this._alignInkBarToSelectedTab(), this._selectedIndexChanged = !1, this._changeDetectorRef.markForCheck()), this._scrollDistanceChanged && (this._updateTabScrollPosition(), this._scrollDistanceChanged = !1, this._changeDetectorRef.markForCheck()) } ngOnDestroy() { this._destroyed.next(), this._destroyed.complete(), this._stopScrolling.complete() } _handleKeydown(e) { if (!Kw(e)) switch (e.keyCode) { case 13: case 32: this.focusIndex !== this.selectedIndex && (this.selectFocusedIndex.emit(this.focusIndex), this._itemSelected(e)); break; default: this._keyManager.onKeydown(e) } } _onContentChanges() { const e = this._elementRef.nativeElement.textContent; e !== this._currentTextContent && (this._currentTextContent = e || "", this._ngZone.run(() => { this.updatePagination(), this._alignInkBarToSelectedTab(), this._changeDetectorRef.markForCheck() })) } updatePagination() { this._checkPaginationEnabled(), this._checkScrollingControls(), this._updateTabScrollPosition() } get focusIndex() { return this._keyManager ? this._keyManager.activeItemIndex : 0 } set focusIndex(e) { !this._isValidIndex(e) || this.focusIndex === e || !this._keyManager || this._keyManager.setActiveItem(e) } _isValidIndex(e) { if (!this._items) return !0; const i = this._items ? this._items.toArray()[e] : null; return !!i && !i.disabled } _setTabFocus(e) { if (this._showPaginationControls && this._scrollToLabel(e), this._items && this._items.length) { this._items.toArray()[e].focus(); const i = this._tabListContainer.nativeElement; i.scrollLeft = "ltr" == this._getLayoutDirection() ? 0 : i.scrollWidth - i.offsetWidth } } _getLayoutDirection() { return this._dir && "rtl" === this._dir.value ? "rtl" : "ltr" } _updateTabScrollPosition() { if (this.disablePagination) return; const e = this.scrollDistance, i = "ltr" === this._getLayoutDirection() ? -e : e; this._tabList.nativeElement.style.transform = `translateX(${Math.round(i)}px)`, (this._platform.TRIDENT || this._platform.EDGE) && (this._tabListContainer.nativeElement.scrollLeft = 0) } get scrollDistance() { return this._scrollDistance } set scrollDistance(e) { this._scrollTo(e) } _scrollHeader(e) { return this._scrollTo(this._scrollDistance + ("before" == e ? -1 : 1) * this._tabListContainer.nativeElement.offsetWidth / 3) } _handlePaginatorClick(e) { this._stopInterval(), this._scrollHeader(e) } _scrollToLabel(e) { if (this.disablePagination) return; const i = this._items ? this._items.toArray()[e] : null; if (!i) return; const r = this._tabListContainer.nativeElement.offsetWidth, { offsetLeft: o, offsetWidth: s } = i.elementRef.nativeElement; let a, l; "ltr" == this._getLayoutDirection() ? (a = o, l = a + s) : (l = this._tabListInner.nativeElement.offsetWidth - o, a = l - s); const c = this.scrollDistance, u = this.scrollDistance + r; a < c ? this.scrollDistance -= c - a + 60 : l > u && (this.scrollDistance += l - u + 60) } _checkPaginationEnabled() { if (this.disablePagination) this._showPaginationControls = !1; else { const e = this._tabListInner.nativeElement.scrollWidth > this._elementRef.nativeElement.offsetWidth; e || (this.scrollDistance = 0), e !== this._showPaginationControls && this._changeDetectorRef.markForCheck(), this._showPaginationControls = e } } _checkScrollingControls() { this.disablePagination ? this._disableScrollAfter = this._disableScrollBefore = !0 : (this._disableScrollBefore = 0 == this.scrollDistance, this._disableScrollAfter = this.scrollDistance == this._getMaxScrollDistance(), this._changeDetectorRef.markForCheck()) } _getMaxScrollDistance() { return this._tabListInner.nativeElement.scrollWidth - this._tabListContainer.nativeElement.offsetWidth || 0 } _alignInkBarToSelectedTab() { const e = this._items && this._items.length ? this._items.toArray()[this.selectedIndex] : null, i = e ? e.elementRef.nativeElement : null; i ? this._inkBar.alignToElement(i) : this._inkBar.hide() } _stopInterval() { this._stopScrolling.next() } _handlePaginatorPress(e, i) { i && null != i.button && 0 !== i.button || (this._stopInterval(), Ra(650, 100).pipe(Le(ul(this._stopScrolling, this._destroyed))).subscribe(() => { const { maxScrollDistance: r, distance: o } = this._scrollHeader(e); (0 === o || o >= r) && this._stopInterval() })) } _scrollTo(e) { if (this.disablePagination) return { maxScrollDistance: 0, distance: 0 }; const i = this._getMaxScrollDistance(); return this._scrollDistance = Math.max(0, Math.min(i, e)), this._scrollDistanceChanged = !0, this._checkScrollingControls(), { maxScrollDistance: i, distance: this._scrollDistance } } } return n.\u0275fac = function(e) { return new (e || n)(g(X), g(Tt), g(u_), g(Xa, 8), g(he), g(ar), g(pi, 8)) }, n.\u0275dir = S({ type: n, inputs: { disablePagination: "disablePagination" } }), n })(), PG = (() => { class n extends xG { constructor(e, i, r, o, s, a, l) { super(e, i, r, o, s, a, l), this._disableRipple = !1 } get disableRipple() { return this._disableRipple } set disableRipple(e) { this._disableRipple = gs(e) } _itemSelected(e) { e.preventDefault() } } return n.\u0275fac = function(e) { return new (e || n)(g(X), g(Tt), g(u_), g(Xa, 8), g(he), g(ar), g(pi, 8)) }, n.\u0275dir = S({ type: n, inputs: { disableRipple: "disableRipple" }, features: [ie] }), n })(), kG = (() => { class n extends PG { constructor(e, i, r, o, s, a, l) { super(e, i, r, o, s, a, l) } } return n.\u0275fac = function(e) { return new (e || n)(g(X), g(Tt), g(u_), g(Xa, 8), g(he), g(ar), g(pi, 8)) }, n.\u0275cmp = We({ type: n, selectors: [["mat-tab-header"]], contentQueries: function(e, i, r) { if (1 & e && Ve(r, vS, 4), 2 & e) { let o; le(o = ce()) && (i._items = o) } }, viewQuery: function(e, i) { if (1 & e && (qt(fS, 7), qt(uG, 7), qt(dG, 7), qt(hG, 7), qt(fG, 5), qt(pG, 5)), 2 & e) { let r; le(r = ce()) && (i._inkBar = r.first), le(r = ce()) && (i._tabListContainer = r.first), le(r = ce()) && (i._tabList = r.first), le(r = ce()) && (i._tabListInner = r.first), le(r = ce()) && (i._nextPaginator = r.first), le(r = ce()) && (i._previousPaginator = r.first) } }, hostAttrs: [1, "mat-tab-header"], hostVars: 4, hostBindings: function(e, i) { 2 & e && de("mat-tab-header-pagination-controls-enabled", i._showPaginationControls)("mat-tab-header-rtl", "rtl" == i._getLayoutDirection()) }, inputs: { selectedIndex: "selectedIndex" }, outputs: { selectFocusedIndex: "selectFocusedIndex", indexFocused: "indexFocused" }, features: [ie], ngContentSelectors: hS, decls: 14, vars: 10, consts: [["aria-hidden", "true", "type", "button", "mat-ripple", "", "tabindex", "-1", 1, "mat-tab-header-pagination", "mat-tab-header-pagination-before", "mat-elevation-z4", 3, "matRippleDisabled", "disabled", "click", "mousedown", "touchend"], ["previousPaginator", ""], [1, "mat-tab-header-pagination-chevron"], [1, "mat-tab-label-container", 3, "keydown"], ["tabListContainer", ""], ["role", "tablist", 1, "mat-tab-list", 3, "cdkObserveContent"], ["tabList", ""], [1, "mat-tab-labels"], ["tabListInner", ""], ["aria-hidden", "true", "type", "button", "mat-ripple", "", "tabindex", "-1", 1, "mat-tab-header-pagination", "mat-tab-header-pagination-after", "mat-elevation-z4", 3, "matRippleDisabled", "disabled", "mousedown", "click", "touchend"], ["nextPaginator", ""]], template: function(e, i) { 1 & e && (Po(), v(0, "button", 0, 1), B("click", function() { return i._handlePaginatorClick("before") })("mousedown", function(o) { return i._handlePaginatorPress("before", o) })("touchend", function() { return i._stopInterval() }), Ue(2, "div", 2), D(), v(3, "div", 3, 4), B("keydown", function(o) { return i._handleKeydown(o) }), v(5, "div", 5, 6), B("cdkObserveContent", function() { return i._onContentChanges() }), v(7, "div", 7, 8), ko(9), D(), Ue(10, "mat-ink-bar"), D(), D(), v(11, "button", 9, 10), B("mousedown", function(o) { return i._handlePaginatorPress("after", o) })("click", function() { return i._handlePaginatorClick("after") })("touchend", function() { return i._stopInterval() }), Ue(13, "div", 2), D()), 2 & e && (de("mat-tab-header-pagination-disabled", i._disableScrollBefore), F("matRippleDisabled", i._disableScrollBefore || i.disableRipple)("disabled", i._disableScrollBefore || null), O(5), de("_mat-animation-noopable", "NoopAnimations" === i._animationMode), O(6), de("mat-tab-header-pagination-disabled", i._disableScrollAfter), F("matRippleDisabled", i._disableScrollAfter || i.disableRipple)("disabled", i._disableScrollAfter || null)) }, directives: [Bu, L3, fS], styles: [".mat-tab-header{display:flex;overflow:hidden;position:relative;flex-shrink:0}.mat-tab-header-pagination{-webkit-user-select:none;user-select:none;position:relative;display:none;justify-content:center;align-items:center;min-width:32px;cursor:pointer;z-index:2;-webkit-tap-highlight-color:transparent;touch-action:none;box-sizing:content-box;background:none;border:none;outline:0;padding:0}.mat-tab-header-pagination::-moz-focus-inner{border:0}.mat-tab-header-pagination-controls-enabled .mat-tab-header-pagination{display:flex}.mat-tab-header-pagination-before,.mat-tab-header-rtl .mat-tab-header-pagination-after{padding-left:4px}.mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(-135deg)}.mat-tab-header-rtl .mat-tab-header-pagination-before,.mat-tab-header-pagination-after{padding-right:4px}.mat-tab-header-rtl .mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(45deg)}.mat-tab-header-pagination-chevron{border-style:solid;border-width:2px 2px 0 0;height:8px;width:8px}.mat-tab-header-pagination-disabled{box-shadow:none;cursor:default}.mat-tab-list{flex-grow:1;position:relative;transition:transform 500ms cubic-bezier(0.35, 0, 0.25, 1)}.mat-ink-bar{position:absolute;bottom:0;height:2px;transition:500ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable.mat-ink-bar{transition:none;animation:none}.mat-tab-group-inverted-header .mat-ink-bar{bottom:auto;top:0}.cdk-high-contrast-active .mat-ink-bar{outline:solid 2px;height:0}.mat-tab-labels{display:flex}[mat-align-tabs=center]>.mat-tab-header .mat-tab-labels{justify-content:center}[mat-align-tabs=end]>.mat-tab-header .mat-tab-labels{justify-content:flex-end}.mat-tab-label-container{display:flex;flex-grow:1;overflow:hidden;z-index:1}._mat-animation-noopable.mat-tab-list{transition:none;animation:none}.mat-tab-label{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;position:relative}.mat-tab-label:focus{outline:none}.mat-tab-label:focus:not(.mat-tab-disabled){opacity:1}.cdk-high-contrast-active .mat-tab-label:focus{outline:dotted 2px;outline-offset:-2px}.mat-tab-label.mat-tab-disabled{cursor:default}.cdk-high-contrast-active .mat-tab-label.mat-tab-disabled{opacity:.5}.mat-tab-label .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}.cdk-high-contrast-active .mat-tab-label{opacity:1}@media(max-width: 599px){.mat-tab-label{min-width:72px}}\n"], encapsulation: 2 }), n })(), FG = 0; class LG { } const BG = a_(sS(class { constructor(n) { this._elementRef = n } }), "primary"); let VG = (() => { class n extends BG { constructor(e, i, r, o) { var s; super(e), this._changeDetectorRef = i, this._animationMode = o, this._tabs = new $o, this._indexToSelect = 0, this._tabBodyWrapperHeight = 0, this._tabsSubscription = Ze.EMPTY, this._tabLabelSubscription = Ze.EMPTY, this._selectedIndex = null, this.headerPosition = "above", this.selectedIndexChange = new L, this.focusChange = new L, this.animationDone = new L, this.selectedTabChange = new L(!0), this._groupId = FG++, this.animationDuration = r && r.animationDuration ? r.animationDuration : "500ms", this.disablePagination = !(!r || null == r.disablePagination) && r.disablePagination, this.dynamicHeight = !(!r || null == r.dynamicHeight) && r.dynamicHeight, this.contentTabIndex = null !== (s = null == r ? void 0 : r.contentTabIndex) && void 0 !== s ? s : null } get dynamicHeight() { return this._dynamicHeight } set dynamicHeight(e) { this._dynamicHeight = gs(e) } get selectedIndex() { return this._selectedIndex } set selectedIndex(e) { this._indexToSelect = bu(e, null) } get animationDuration() { return this._animationDuration } set animationDuration(e) { this._animationDuration = /^\d+$/.test(e + "") ? e + "ms" : e } get contentTabIndex() { return this._contentTabIndex } set contentTabIndex(e) { this._contentTabIndex = bu(e, null) } get backgroundColor() { return this._backgroundColor } set backgroundColor(e) { const i = this._elementRef.nativeElement; i.classList.remove(`mat-background-${this.backgroundColor}`), e && i.classList.add(`mat-background-${e}`), this._backgroundColor = e } ngAfterContentChecked() { const e = this._indexToSelect = this._clampTabIndex(this._indexToSelect); if (this._selectedIndex != e) { const i = null == this._selectedIndex; if (!i) { this.selectedTabChange.emit(this._createChangeEvent(e)); const r = this._tabBodyWrapper.nativeElement; r.style.minHeight = r.clientHeight + "px" } Promise.resolve().then(() => { this._tabs.forEach((r, o) => r.isActive = o === e), i || (this.selectedIndexChange.emit(e), this._tabBodyWrapper.nativeElement.style.minHeight = "") }) } this._tabs.forEach((i, r) => { i.position = r - e, null != this._selectedIndex && 0 == i.position && !i.origin && (i.origin = e - this._selectedIndex) }), this._selectedIndex !== e && (this._selectedIndex = e, this._changeDetectorRef.markForCheck()) } ngAfterContentInit() { this._subscribeToAllTabChanges(), this._subscribeToTabLabels(), this._tabsSubscription = this._tabs.changes.subscribe(() => { if (this._clampTabIndex(this._indexToSelect) === this._selectedIndex) { const i = this._tabs.toArray(); for (let r = 0; r < i.length; r++)if (i[r].isActive) { this._indexToSelect = this._selectedIndex = r; break } } this._changeDetectorRef.markForCheck() }) } _subscribeToAllTabChanges() { this._allTabs.changes.pipe(Qo(this._allTabs)).subscribe(e => { this._tabs.reset(e.filter(i => i._closestTabGroup === this || !i._closestTabGroup)), this._tabs.notifyOnChanges() }) } ngOnDestroy() { this._tabs.destroy(), this._tabsSubscription.unsubscribe(), this._tabLabelSubscription.unsubscribe() } realignInkBar() { this._tabHeader && this._tabHeader._alignInkBarToSelectedTab() } updatePagination() { this._tabHeader && this._tabHeader.updatePagination() } focusTab(e) { const i = this._tabHeader; i && (i.focusIndex = e) } _focusChanged(e) { this.focusChange.emit(this._createChangeEvent(e)) } _createChangeEvent(e) { const i = new LG; return i.index = e, this._tabs && this._tabs.length && (i.tab = this._tabs.toArray()[e]), i } _subscribeToTabLabels() { this._tabLabelSubscription && this._tabLabelSubscription.unsubscribe(), this._tabLabelSubscription = ul(...this._tabs.map(e => e._stateChanges)).subscribe(() => this._changeDetectorRef.markForCheck()) } _clampTabIndex(e) { return Math.min(this._tabs.length - 1, Math.max(e || 0, 0)) } _getTabLabelId(e) { return `mat-tab-label-${this._groupId}-${e}` } _getTabContentId(e) { return `mat-tab-content-${this._groupId}-${e}` } _setTabBodyWrapperHeight(e) { if (!this._dynamicHeight || !this._tabBodyWrapperHeight) return; const i = this._tabBodyWrapper.nativeElement; i.style.height = this._tabBodyWrapperHeight + "px", this._tabBodyWrapper.nativeElement.offsetHeight && (i.style.height = e + "px") } _removeTabBodyWrapperHeight() { const e = this._tabBodyWrapper.nativeElement; this._tabBodyWrapperHeight = e.clientHeight, e.style.height = "", this.animationDone.emit() } _handleClick(e, i, r) { e.disabled || (this.selectedIndex = i.focusIndex = r) } _getTabIndex(e, i) { return e.disabled ? null : this.selectedIndex === i ? 0 : -1 } _tabFocusChanged(e, i) { e && "mouse" !== e && "touch" !== e && (this._tabHeader.focusIndex = i) } } return n.\u0275fac = function(e) { return new (e || n)(g(X), g(Tt), g(bS, 8), g(pi, 8)) }, n.\u0275dir = S({ type: n, inputs: { dynamicHeight: "dynamicHeight", selectedIndex: "selectedIndex", headerPosition: "headerPosition", animationDuration: "animationDuration", contentTabIndex: "contentTabIndex", disablePagination: "disablePagination", backgroundColor: "backgroundColor" }, outputs: { selectedIndexChange: "selectedIndexChange", focusChange: "focusChange", animationDone: "animationDone", selectedTabChange: "selectedTabChange" }, features: [ie] }), n })(), HG = (() => { class n extends VG { constructor(e, i, r, o) { super(e, i, r, o) } } return n.\u0275fac = function(e) { return new (e || n)(g(X), g(Tt), g(bS, 8), g(pi, 8)) }, n.\u0275cmp = We({ type: n, selectors: [["mat-tab-group"]], contentQueries: function(e, i, r) { if (1 & e && Ve(r, mS, 5), 2 & e) { let o; le(o = ce()) && (i._allTabs = o) } }, viewQuery: function(e, i) { if (1 & e && (qt(gG, 5), qt(_G, 5)), 2 & e) { let r; le(r = ce()) && (i._tabBodyWrapper = r.first), le(r = ce()) && (i._tabHeader = r.first) } }, hostAttrs: [1, "mat-tab-group"], hostVars: 4, hostBindings: function(e, i) { 2 & e && de("mat-tab-group-dynamic-height", i.dynamicHeight)("mat-tab-group-inverted-header", "below" === i.headerPosition) }, inputs: { color: "color", disableRipple: "disableRipple" }, exportAs: ["matTabGroup"], features: [Se([{ provide: _S, useExisting: n }]), ie], decls: 6, vars: 7, consts: [[3, "selectedIndex", "disableRipple", "disablePagination", "indexFocused", "selectFocusedIndex"], ["tabHeader", ""], ["class", "mat-tab-label mat-focus-indicator", "role", "tab", "matTabLabelWrapper", "", "mat-ripple", "", "cdkMonitorElementFocus", "", 3, "id", "mat-tab-label-active", "ngClass", "disabled", "matRippleDisabled", "click", "cdkFocusChange", 4, "ngFor", "ngForOf"], [1, "mat-tab-body-wrapper"], ["tabBodyWrapper", ""], ["role", "tabpanel", 3, "id", "mat-tab-body-active", "ngClass", "content", "position", "origin", "animationDuration", "_onCentered", "_onCentering", 4, "ngFor", "ngForOf"], ["role", "tab", "matTabLabelWrapper", "", "mat-ripple", "", "cdkMonitorElementFocus", "", 1, "mat-tab-label", "mat-focus-indicator", 3, "id", "ngClass", "disabled", "matRippleDisabled", "click", "cdkFocusChange"], [1, "mat-tab-label-content"], [3, "ngIf", "ngIfElse"], ["tabTextLabel", ""], [3, "cdkPortalOutlet"], ["role", "tabpanel", 3, "id", "ngClass", "content", "position", "origin", "animationDuration", "_onCentered", "_onCentering"]], template: function(e, i) { 1 & e && (v(0, "mat-tab-header", 0, 1), B("indexFocused", function(o) { return i._focusChanged(o) })("selectFocusedIndex", function(o) { return i.selectedIndex = o }), j(2, vG, 5, 15, "div", 2), D(), v(3, "div", 3, 4), j(5, DG, 1, 10, "mat-tab-body", 5), D()), 2 & e && (F("selectedIndex", i.selectedIndex || 0)("disableRipple", i.disableRipple)("disablePagination", i.disablePagination), O(2), F("ngForOf", i._tabs), O(1), de("_mat-animation-noopable", "NoopAnimations" === i._animationMode), O(2), F("ngForOf", i._tabs)) }, directives: [kG, yS, Qi, vS, Bu, Z3, xD, Ni, Sg], styles: [".mat-tab-group{display:flex;flex-direction:column;max-width:100%}.mat-tab-group.mat-tab-group-inverted-header{flex-direction:column-reverse}.mat-tab-label{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;position:relative}.mat-tab-label:focus{outline:none}.mat-tab-label:focus:not(.mat-tab-disabled){opacity:1}.cdk-high-contrast-active .mat-tab-label:focus{outline:dotted 2px;outline-offset:-2px}.mat-tab-label.mat-tab-disabled{cursor:default}.cdk-high-contrast-active .mat-tab-label.mat-tab-disabled{opacity:.5}.mat-tab-label .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}.cdk-high-contrast-active .mat-tab-label{opacity:1}@media(max-width: 599px){.mat-tab-label{padding:0 12px}}@media(max-width: 959px){.mat-tab-label{padding:0 12px}}.mat-tab-group[mat-stretch-tabs]>.mat-tab-header .mat-tab-label{flex-basis:0;flex-grow:1}.mat-tab-body-wrapper{position:relative;overflow:hidden;display:flex;transition:height 500ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable.mat-tab-body-wrapper{transition:none;animation:none}.mat-tab-body{top:0;left:0;right:0;bottom:0;position:absolute;display:block;overflow:hidden;outline:0;flex-basis:100%}.mat-tab-body.mat-tab-body-active{position:relative;overflow-x:hidden;overflow-y:auto;z-index:1;flex-grow:1}.mat-tab-group.mat-tab-group-dynamic-height .mat-tab-body.mat-tab-body-active{overflow-y:hidden}\n"], encapsulation: 2 }), n })(), jG = (() => { class n { } return n.\u0275fac = function(e) { return new (e || n) }, n.\u0275mod = se({ type: n }), n.\u0275inj = te({ imports: [[Qt, ur, r8, uS, Qw, X3], ur] }), n })(), rl = (() => { class n { constructor(e) { this.http = e, this.onPostAdded = new L } getPost() { const e = new xt({ "Content-Type": "application/json", Accept: "application/json", "Access-Control-Allow-Headers": "Content-Type", responseType: "json", Authorization: "Bearer " + sessionStorage.getItem("token") }); return this.http.get("/api/posts", { headers: e }) } searchPost(e) { const i = new xt({ "Content-Type": "application/json", Accept: "application/json", "Access-Control-Allow-Headers": "Content-Type", responseType: "json", Authorization: "Bearer " + sessionStorage.getItem("token") }); return this.http.get(null == e ? "/api/posts" : "/api/posts/search/" + e, { headers: i }) } getMyPosts() { const e = new xt({ "Content-Type": "application/json", Accept: "application/json", "Access-Control-Allow-Headers": "Content-Type", responseType: "json", Authorization: "Bearer " + sessionStorage.getItem("token") }); return this.http.get(`/api/posts/myPosts/${sessionStorage.getItem("user")}`, { headers: e }) } addPost(e) { return this.http.post("/api/posts", e) } editPost(e) { return this.http.post("/api/posts/", e) } deletePost(e) { const i = new xt({ "Content-Type": "application/json", Accept: "application/json", "Access-Control-Allow-Headers": "Content-Type", responseType: "json", Authorization: "Bearer " + sessionStorage.getItem("token") }); return this.http.post(`/api/posts/delete/${e}`, { headers: i }) } } return n.\u0275fac = function(e) { return new (e || n)(E(ns)) }, n.\u0275prov = R({ token: n, factory: n.\u0275fac }), n })(); function UG(n, t) { if (1 & n && (v(0, "div", 5), v(1, "div", 6), v(2, "div", 7), v(3, "h2", 8), q(4), D(), v(5, "p"), q(6), D(), D(), v(7, "div", 9), v(8, "p"), q(9), D(), D(), D(), v(10, "div", 6), v(11, "p"), q(12), D(), D(), D()), 2 & n) { const e = t.$implicit; O(4), Vn(e.heading), O(2), qi("posted: ", e.date, ""), O(3), qi("by: ", e.author, ""), O(3), Vn(e.body) } } let $G = (() => { class n { constructor(e) { this.postService = e, this.posts = [] } ngOnInit() { this.postService.getPost().subscribe(e => { this.posts = e }, e => console.log(e)), this.postService.onPostAdded.subscribe(e => this.posts.push(e)) } search(e) { this.postService.searchPost(e).subscribe(i => { this.posts = i }, i => console.log(i)) } } return n.\u0275fac = function(e) { return new (e || n)(g(rl)) }, n.\u0275cmp = We({ type: n, selectors: [["app-post-list"]], decls: 5, vars: 1, consts: [[1, "form", "animate__animated", "animate__slideInDown", "d-flex", "justify-content-center"], [1, "input-group", "input-group-md", "w-50"], ["type", "text", "placeholder", "Search by keyword", "aria-label", "Sizing example input", "aria-describedby", "inputGroup-sizing-lg", 1, "form-control", "mt-4", 3, "keyup.enter"], ["keyword", ""], ["class", "card mx-auto animate__animated animate__slideInDown", 4, "ngFor", "ngForOf"], [1, "card", "mx-auto", "animate__animated", "animate__slideInDown"], [1, "row"], [1, "col-md-8"], [1, "title"], [1, "col-md-4", "text-end"]], template: function(e, i) { if (1 & e) { const r = Dt(); v(0, "form", 0), v(1, "div", 1), v(2, "input", 2, 3), B("keyup.enter", function() { ze(r); const s = ht(3); return i.search(s.value) }), D(), D(), D(), j(4, UG, 13, 4, "div", 4) } 2 & e && (O(4), F("ngForOf", i.posts)) }, directives: [ss, rs, rr, Qi], styles: [".card[_ngcontent-%COMP%]{width:90%;justify-content:center;height:auto;border-radius:30px;background:#e0e0e0;box-shadow:15px 15px 30px #bebebe,-15px -15px 30px #fff;padding:20px;margin-top:40px}.form-control[_ngcontent-%COMP%]{border-radius:500px!important}"] }), n })(); class GG { constructor(t, e, i, r, o) { this.id = t, this.author = e, this.heading = i, this.body = r, this.date = new Date(o) } } class WG { constructor(t, e, i, r) { this.author = t, this.heading = e, this.body = i, this.date = new Date(r) } } const zG = ["mat-button", ""], KG = ["*"], YG = ["mat-button", "mat-flat-button", "mat-icon-button", "mat-raised-button", "mat-stroked-button", "mat-mini-fab", "mat-fab"], QG = a_(s_(sS(class { constructor(n) { this._elementRef = n } }))); let JG = (() => { class n extends QG { constructor(e, i, r) { super(e), this._focusMonitor = i, this._animationMode = r, this.isRoundButton = this._hasHostAttributes("mat-fab", "mat-mini-fab"), this.isIconButton = this._hasHostAttributes("mat-icon-button"); for (const o of YG) this._hasHostAttributes(o) && this._getHostElement().classList.add(o); e.nativeElement.classList.add("mat-button-base"), this.isRoundButton && (this.color = "accent") } ngAfterViewInit() { this._focusMonitor.monitor(this._elementRef, !0) } ngOnDestroy() { this._focusMonitor.stopMonitoring(this._elementRef) } focus(e, i) { e ? this._focusMonitor.focusVia(this._getHostElement(), e, i) : this._getHostElement().focus(i) } _getHostElement() { return this._elementRef.nativeElement } _isRippleDisabled() { return this.disableRipple || this.disabled } _hasHostAttributes(...e) { return e.some(i => this._getHostElement().hasAttribute(i)) } } return n.\u0275fac = function(e) { return new (e || n)(g(X), g(iT), g(pi, 8)) }, n.\u0275cmp = We({ type: n, selectors: [["button", "mat-button", ""], ["button", "mat-raised-button", ""], ["button", "mat-icon-button", ""], ["button", "mat-fab", ""], ["button", "mat-mini-fab", ""], ["button", "mat-stroked-button", ""], ["button", "mat-flat-button", ""]], viewQuery: function(e, i) { if (1 & e && qt(Bu, 5), 2 & e) { let r; le(r = ce()) && (i.ripple = r.first) } }, hostAttrs: [1, "mat-focus-indicator"], hostVars: 5, hostBindings: function(e, i) { 2 & e && (ve("disabled", i.disabled || null), de("_mat-animation-noopable", "NoopAnimations" === i._animationMode)("mat-button-disabled", i.disabled)) }, inputs: { disabled: "disabled", disableRipple: "disableRipple", color: "color" }, exportAs: ["matButton"], features: [ie], attrs: zG, ngContentSelectors: KG, decls: 4, vars: 5, consts: [[1, "mat-button-wrapper"], ["matRipple", "", 1, "mat-button-ripple", 3, "matRippleDisabled", "matRippleCentered", "matRippleTrigger"], [1, "mat-button-focus-overlay"]], template: function(e, i) { 1 & e && (Po(), v(0, "span", 0), ko(1), D(), Ue(2, "span", 1), Ue(3, "span", 2)), 2 & e && (O(2), de("mat-button-ripple-round", i.isRoundButton || i.isIconButton), F("matRippleDisabled", i._isRippleDisabled())("matRippleCentered", i.isIconButton)("matRippleTrigger", i._getHostElement())) }, directives: [Bu], styles: [".mat-button .mat-button-focus-overlay,.mat-icon-button .mat-button-focus-overlay{opacity:0}.mat-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay,.mat-stroked-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay{opacity:.04}@media(hover: none){.mat-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay,.mat-stroked-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay{opacity:0}}.mat-button,.mat-icon-button,.mat-stroked-button,.mat-flat-button{box-sizing:border-box;position:relative;-webkit-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-button.mat-button-disabled,.mat-icon-button.mat-button-disabled,.mat-stroked-button.mat-button-disabled,.mat-flat-button.mat-button-disabled{cursor:default}.mat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-button.cdk-program-focused .mat-button-focus-overlay,.mat-icon-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-icon-button.cdk-program-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-program-focused .mat-button-focus-overlay,.mat-flat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-flat-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-raised-button{box-sizing:border-box;position:relative;-webkit-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-raised-button::-moz-focus-inner{border:0}.mat-raised-button.mat-button-disabled{cursor:default}.mat-raised-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-raised-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-raised-button::-moz-focus-inner{border:0}._mat-animation-noopable.mat-raised-button{transition:none;animation:none}.mat-stroked-button{border:1px solid currentColor;padding:0 15px;line-height:34px}.mat-stroked-button .mat-button-ripple.mat-ripple,.mat-stroked-button .mat-button-focus-overlay{top:-1px;left:-1px;right:-1px;bottom:-1px}.mat-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:56px;height:56px;padding:0;flex-shrink:0}.mat-fab::-moz-focus-inner{border:0}.mat-fab.mat-button-disabled{cursor:default}.mat-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-fab{transition:none;animation:none}.mat-fab .mat-button-wrapper{padding:16px 0;display:inline-block;line-height:24px}.mat-mini-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:40px;height:40px;padding:0;flex-shrink:0}.mat-mini-fab::-moz-focus-inner{border:0}.mat-mini-fab.mat-button-disabled{cursor:default}.mat-mini-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-mini-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-mini-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-mini-fab{transition:none;animation:none}.mat-mini-fab .mat-button-wrapper{padding:8px 0;display:inline-block;line-height:24px}.mat-icon-button{padding:0;min-width:0;width:40px;height:40px;flex-shrink:0;line-height:40px;border-radius:50%}.mat-icon-button i,.mat-icon-button .mat-icon{line-height:24px}.mat-button-ripple.mat-ripple,.mat-button-focus-overlay{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-button-ripple.mat-ripple:not(:empty){transform:translateZ(0)}.mat-button-focus-overlay{opacity:0;transition:opacity 200ms cubic-bezier(0.35, 0, 0.25, 1),background-color 200ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable .mat-button-focus-overlay{transition:none}.mat-button-ripple-round{border-radius:50%;z-index:1}.mat-button .mat-button-wrapper>*,.mat-flat-button .mat-button-wrapper>*,.mat-stroked-button .mat-button-wrapper>*,.mat-raised-button .mat-button-wrapper>*,.mat-icon-button .mat-button-wrapper>*,.mat-fab .mat-button-wrapper>*,.mat-mini-fab .mat-button-wrapper>*{vertical-align:middle}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button{display:inline-flex;justify-content:center;align-items:center;font-size:inherit;width:2.5em;height:2.5em}.cdk-high-contrast-active .mat-button,.cdk-high-contrast-active .mat-flat-button,.cdk-high-contrast-active .mat-raised-button,.cdk-high-contrast-active .mat-icon-button,.cdk-high-contrast-active .mat-fab,.cdk-high-contrast-active .mat-mini-fab{outline:solid 1px}.cdk-high-contrast-active .mat-button-base.cdk-keyboard-focused,.cdk-high-contrast-active .mat-button-base.cdk-program-focused{outline:solid 3px}\n"], encapsulation: 2, changeDetection: 0 }), n })(), ZG = (() => { class n { } return n.\u0275fac = function(e) { return new (e || n) }, n.\u0275mod = se({ type: n }), n.\u0275inj = te({ imports: [[uS, ur], ur] }), n })(); function ES(n, t) { const e = ye(n) ? n : () => n, i = r => r.error(e()); return new Ce(t ? r => t.schedule(i, 0, r) : i) } const XG = ["*"]; let ju; function ol(n) { var t; return (null === (t = function eW() { if (void 0 === ju && (ju = null, "undefined" != typeof window)) { const n = window; void 0 !== n.trustedTypes && (ju = n.trustedTypes.createPolicy("angular#components", { createHTML: t => t })) } return ju }()) || void 0 === t ? void 0 : t.createHTML(n)) || n } function wS(n) { return Error(`Unable to find icon with the name "${n}"`) } function TS(n) { return Error(`The URL provided to MatIconRegistry was not trusted as a resource URL via Angular's DomSanitizer. Attempted URL was "${n}".`) } function SS(n) { return Error(`The literal provided to MatIconRegistry was not trusted as safe HTML by Angular's DomSanitizer. Attempted literal was "${n}".`) } class Kr { constructor(t, e, i) { this.url = t, this.svgText = e, this.options = i } } let Uu = (() => { class n { constructor(e, i, r, o) { this._httpClient = e, this._sanitizer = i, this._errorHandler = o, this._svgIconConfigs = new Map, this._iconSetConfigs = new Map, this._cachedIconsByUrl = new Map, this._inProgressUrlFetches = new Map, this._fontCssClassesByAlias = new Map, this._resolvers = [], this._defaultFontSetClass = "material-icons", this._document = r } addSvgIcon(e, i, r) { return this.addSvgIconInNamespace("", e, i, r) } addSvgIconLiteral(e, i, r) { return this.addSvgIconLiteralInNamespace("", e, i, r) } addSvgIconInNamespace(e, i, r, o) { return this._addSvgIconConfig(e, i, new Kr(r, null, o)) } addSvgIconResolver(e) { return this._resolvers.push(e), this } addSvgIconLiteralInNamespace(e, i, r, o) { const s = this._sanitizer.sanitize(Ee.HTML, r); if (!s) throw SS(r); const a = ol(s); return this._addSvgIconConfig(e, i, new Kr("", a, o)) } addSvgIconSet(e, i) { return this.addSvgIconSetInNamespace("", e, i) } addSvgIconSetLiteral(e, i) { return this.addSvgIconSetLiteralInNamespace("", e, i) } addSvgIconSetInNamespace(e, i, r) { return this._addSvgIconSetConfig(e, new Kr(i, null, r)) } addSvgIconSetLiteralInNamespace(e, i, r) { const o = this._sanitizer.sanitize(Ee.HTML, i); if (!o) throw SS(i); const s = ol(o); return this._addSvgIconSetConfig(e, new Kr("", s, r)) } registerFontClassAlias(e, i = e) { return this._fontCssClassesByAlias.set(e, i), this } classNameForFontAlias(e) { return this._fontCssClassesByAlias.get(e) || e } setDefaultFontSetClass(e) { return this._defaultFontSetClass = e, this } getDefaultFontSetClass() { return this._defaultFontSetClass } getSvgIconFromUrl(e) { const i = this._sanitizer.sanitize(Ee.RESOURCE_URL, e); if (!i) throw TS(e); const r = this._cachedIconsByUrl.get(i); return r ? U($u(r)) : this._loadSvgIconFromConfig(new Kr(e, null)).pipe(_t(o => this._cachedIconsByUrl.set(i, o)), W(o => $u(o))) } getNamedSvgIcon(e, i = "") { const r = AS(i, e); let o = this._svgIconConfigs.get(r); if (o) return this._getSvgFromConfig(o); if (o = this._getIconConfigFromResolvers(i, e), o) return this._svgIconConfigs.set(r, o), this._getSvgFromConfig(o); const s = this._iconSetConfigs.get(i); return s ? this._getSvgFromIconSetConfigs(e, s) : ES(wS(r)) } ngOnDestroy() { this._resolvers = [], this._svgIconConfigs.clear(), this._iconSetConfigs.clear(), this._cachedIconsByUrl.clear() } _getSvgFromConfig(e) { return e.svgText ? U($u(this._svgElementFromConfig(e))) : this._loadSvgIconFromConfig(e).pipe(W(i => $u(i))) } _getSvgFromIconSetConfigs(e, i) { const r = this._extractIconWithNameFromAnySet(e, i); return r ? U(r) : MC(i.filter(s => !s.svgText).map(s => this._loadSvgIconSetFromConfig(s).pipe(ai(a => { const c = `Loading icon set URL: ${this._sanitizer.sanitize(Ee.RESOURCE_URL, s.url)} failed: ${a.message}`; return this._errorHandler.handleError(new Error(c)), U(null) })))).pipe(W(() => { const s = this._extractIconWithNameFromAnySet(e, i); if (!s) throw wS(e); return s })) } _extractIconWithNameFromAnySet(e, i) { for (let r = i.length - 1; r >= 0; r--) { const o = i[r]; if (o.svgText && o.svgText.toString().indexOf(e) > -1) { const s = this._svgElementFromConfig(o), a = this._extractSvgIconFromSet(s, e, o.options); if (a) return a } } return null } _loadSvgIconFromConfig(e) { return this._fetchIcon(e).pipe(_t(i => e.svgText = i), W(() => this._svgElementFromConfig(e))) } _loadSvgIconSetFromConfig(e) { return e.svgText ? U(null) : this._fetchIcon(e).pipe(_t(i => e.svgText = i)) } _extractSvgIconFromSet(e, i, r) { const o = e.querySelector(`[id="${i}"]`); if (!o) return null; const s = o.cloneNode(!0); if (s.removeAttribute("id"), "svg" === s.nodeName.toLowerCase()) return this._setSvgAttributes(s, r); if ("symbol" === s.nodeName.toLowerCase()) return this._setSvgAttributes(this._toSvgElement(s), r); const a = this._svgElementFromString(ol("<svg></svg>")); return a.appendChild(s), this._setSvgAttributes(a, r) } _svgElementFromString(e) { const i = this._document.createElement("DIV"); i.innerHTML = e; const r = i.querySelector("svg"); if (!r) throw Error("<svg> tag not found"); return r } _toSvgElement(e) { const i = this._svgElementFromString(ol("<svg></svg>")), r = e.attributes; for (let o = 0; o < r.length; o++) { const { name: s, value: a } = r[o]; "id" !== s && i.setAttribute(s, a) } for (let o = 0; o < e.childNodes.length; o++)e.childNodes[o].nodeType === this._document.ELEMENT_NODE && i.appendChild(e.childNodes[o].cloneNode(!0)); return i } _setSvgAttributes(e, i) { return e.setAttribute("fit", ""), e.setAttribute("height", "100%"), e.setAttribute("width", "100%"), e.setAttribute("preserveAspectRatio", "xMidYMid meet"), e.setAttribute("focusable", "false"), i && i.viewBox && e.setAttribute("viewBox", i.viewBox), e } _fetchIcon(e) { var i; const { url: r, options: o } = e, s = null !== (i = null == o ? void 0 : o.withCredentials) && void 0 !== i && i; if (!this._httpClient) throw function tW() { return Error("Could not find HttpClient provider for use with Angular Material icons. Please include the HttpClientModule from @angular/common/http in your app imports.") }(); if (null == r) throw Error(`Cannot fetch icon from URL "${r}".`); const a = this._sanitizer.sanitize(Ee.RESOURCE_URL, r); if (!a) throw TS(r); const l = this._inProgressUrlFetches.get(a); if (l) return l; const c = this._httpClient.get(a, { responseType: "text", withCredentials: s }).pipe(W(u => ol(u)), d1(() => this._inProgressUrlFetches.delete(a)), L_()); return this._inProgressUrlFetches.set(a, c), c } _addSvgIconConfig(e, i, r) { return this._svgIconConfigs.set(AS(e, i), r), this } _addSvgIconSetConfig(e, i) { const r = this._iconSetConfigs.get(e); return r ? r.push(i) : this._iconSetConfigs.set(e, [i]), this } _svgElementFromConfig(e) { if (!e.svgElement) { const i = this._svgElementFromString(e.svgText); this._setSvgAttributes(i, e.options), e.svgElement = i } return e.svgElement } _getIconConfigFromResolvers(e, i) { for (let r = 0; r < this._resolvers.length; r++) { const o = this._resolvers[r](i, e); if (o) return iW(o) ? new Kr(o.url, null, o.options) : new Kr(o, null) } } } return n.\u0275fac = function(e) { return new (e || n)(E(ns, 8), E(Qf), E(De, 8), E(Di)) }, n.\u0275prov = R({ token: n, factory: n.\u0275fac, providedIn: "root" }), n })(); function $u(n) { return n.cloneNode(!0) } function AS(n, t) { return n + ":" + t } function iW(n) { return !(!n.url || !n.options) } const rW = a_(class { constructor(n) { this._elementRef = n } }), oW = new P("mat-icon-location", { providedIn: "root", factory: function sW() { const n = Fd(De), t = n ? n.location : null; return { getPathname: () => t ? t.pathname + t.search : "" } } }), MS = ["clip-path", "color-profile", "src", "cursor", "fill", "filter", "marker", "marker-start", "marker-mid", "marker-end", "mask", "stroke"], aW = MS.map(n => `[${n}]`).join(", "), lW = /^url\(['"]?#(.*?)['"]?\)$/; let cW = (() => { class n extends rW { constructor(e, i, r, o, s) { super(e), this._iconRegistry = i, this._location = o, this._errorHandler = s, this._inline = !1, this._currentIconFetch = Ze.EMPTY, r || e.nativeElement.setAttribute("aria-hidden", "true") } get inline() { return this._inline } set inline(e) { this._inline = gs(e) } get svgIcon() { return this._svgIcon } set svgIcon(e) { e !== this._svgIcon && (e ? this._updateSvgIcon(e) : this._svgIcon && this._clearSvgElement(), this._svgIcon = e) } get fontSet() { return this._fontSet } set fontSet(e) { const i = this._cleanupFontValue(e); i !== this._fontSet && (this._fontSet = i, this._updateFontIconClasses()) } get fontIcon() { return this._fontIcon } set fontIcon(e) { const i = this._cleanupFontValue(e); i !== this._fontIcon && (this._fontIcon = i, this._updateFontIconClasses()) } _splitIconName(e) { if (!e) return ["", ""]; const i = e.split(":"); switch (i.length) { case 1: return ["", i[0]]; case 2: return i; default: throw Error(`Invalid icon name: "${e}"`) } } ngOnInit() { this._updateFontIconClasses() } ngAfterViewChecked() { const e = this._elementsWithExternalReferences; if (e && e.size) { const i = this._location.getPathname(); i !== this._previousPath && (this._previousPath = i, this._prependPathToReferences(i)) } } ngOnDestroy() { this._currentIconFetch.unsubscribe(), this._elementsWithExternalReferences && this._elementsWithExternalReferences.clear() } _usingFontIcon() { return !this.svgIcon } _setSvgElement(e) { this._clearSvgElement(); const i = this._location.getPathname(); this._previousPath = i, this._cacheChildrenWithExternalReferences(e), this._prependPathToReferences(i), this._elementRef.nativeElement.appendChild(e) } _clearSvgElement() { const e = this._elementRef.nativeElement; let i = e.childNodes.length; for (this._elementsWithExternalReferences && this._elementsWithExternalReferences.clear(); i--;) { const r = e.childNodes[i]; (1 !== r.nodeType || "svg" === r.nodeName.toLowerCase()) && r.remove() } } _updateFontIconClasses() { if (!this._usingFontIcon()) return; const e = this._elementRef.nativeElement, i = this.fontSet ? this._iconRegistry.classNameForFontAlias(this.fontSet) : this._iconRegistry.getDefaultFontSetClass(); i != this._previousFontSetClass && (this._previousFontSetClass && e.classList.remove(this._previousFontSetClass), i && e.classList.add(i), this._previousFontSetClass = i), this.fontIcon != this._previousFontIconClass && (this._previousFontIconClass && e.classList.remove(this._previousFontIconClass), this.fontIcon && e.classList.add(this.fontIcon), this._previousFontIconClass = this.fontIcon) } _cleanupFontValue(e) { return "string" == typeof e ? e.trim().split(" ")[0] : e } _prependPathToReferences(e) { const i = this._elementsWithExternalReferences; i && i.forEach((r, o) => { r.forEach(s => { o.setAttribute(s.name, `url('${e}#${s.value}')`) }) }) } _cacheChildrenWithExternalReferences(e) { const i = e.querySelectorAll(aW), r = this._elementsWithExternalReferences = this._elementsWithExternalReferences || new Map; for (let o = 0; o < i.length; o++)MS.forEach(s => { const a = i[o], l = a.getAttribute(s), c = l ? l.match(lW) : null; if (c) { let u = r.get(a); u || (u = [], r.set(a, u)), u.push({ name: s, value: c[1] }) } }) } _updateSvgIcon(e) { if (this._svgNamespace = null, this._svgName = null, this._currentIconFetch.unsubscribe(), e) { const [i, r] = this._splitIconName(e); i && (this._svgNamespace = i), r && (this._svgName = r), this._currentIconFetch = this._iconRegistry.getNamedSvgIcon(r, i).pipe(ct(1)).subscribe(o => this._setSvgElement(o), o => { this._errorHandler.handleError(new Error(`Error retrieving icon ${i}:${r}! ${o.message}`)) }) } } } return n.\u0275fac = function(e) { return new (e || n)(g(X), g(Uu), Wi("aria-hidden"), g(oW), g(Di)) }, n.\u0275cmp = We({ type: n, selectors: [["mat-icon"]], hostAttrs: ["role", "img", 1, "mat-icon", "notranslate"], hostVars: 7, hostBindings: function(e, i) { 2 & e && (ve("data-mat-icon-type", i._usingFontIcon() ? "font" : "svg")("data-mat-icon-name", i._svgName || i.fontIcon)("data-mat-icon-namespace", i._svgNamespace || i.fontSet), de("mat-icon-inline", i.inline)("mat-icon-no-color", "primary" !== i.color && "accent" !== i.color && "warn" !== i.color)) }, inputs: { color: "color", inline: "inline", svgIcon: "svgIcon", fontSet: "fontSet", fontIcon: "fontIcon" }, exportAs: ["matIcon"], features: [ie], ngContentSelectors: XG, decls: 1, vars: 0, template: function(e, i) { 1 & e && (Po(), ko(0)) }, styles: [".mat-icon{-webkit-user-select:none;user-select:none;background-repeat:no-repeat;display:inline-block;fill:currentColor;height:24px;width:24px}.mat-icon.mat-icon-inline{font-size:inherit;height:inherit;line-height:inherit;width:inherit}[dir=rtl] .mat-icon-rtl-mirror{transform:scale(-1, 1)}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon{display:block}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-icon{margin:auto}\n"], encapsulation: 2, changeDetection: 0 }), n })(), uW = (() => { class n { } return n.\u0275fac = function(e) { return new (e || n) }, n.\u0275mod = se({ type: n }), n.\u0275inj = te({ imports: [[ur], ur] }), n })(); function dW(n, t) { if (1 & n) { const e = Dt(); v(0, "div", 2), v(1, "h4", 3), q(2, "Edit Post"), D(), v(3, "button", 4), B("click", function() { return ze(e).$implicit.close() }), D(), D(), v(4, "div", 5), v(5, "form", 6), B("submit", function() { ze(e); const r = ht(7), o = ht(9), s = ht(12), a = ht(15); return K().onPostEdit(r.value, o.value, s.value, a.value) }), Ue(6, "input", 7, 8), Ue(8, "input", 9, 10), Ue(10, "label", 11), Ue(11, "textarea", 12, 13), Ue(13, "label", 14), Ue(14, "input", 15, 16), D(), D(), v(16, "div", 17), v(17, "button", 18), q(18, "Update"), D(), v(19, "button", 19), B("click", function() { return ze(e).$implicit.close() }), q(20, "Cancel"), D(), D() } if (2 & n) { const e = K(); O(6), Er("value", e.editPostId), O(2), Er("value", e.editPostHeading), O(3), Er("value", e.editPostBody), O(3), Er("value", e.editPostDate) } } function hW(n, t) { if (1 & n) { const e = Dt(); v(0, "div", 20), v(1, "div", 21), v(2, "div", 22), v(3, "h2", 23), q(4), D(), v(5, "p"), q(6), D(), D(), v(7, "div", 24), v(8, "button", 25), B("click", function() { const o = ze(e).$implicit; return K().onPostDelete(o.id) }), v(9, "mat-icon", 26), q(10, "delete"), D(), D(), v(11, "button", 27), B("click", function() { const o = ze(e).$implicit, s = K(), a = ht(1); return s.open(a, o.id.toString(), o.heading, o.body, o.date.toString()) }), v(12, "mat-icon", 26), q(13, "edit"), D(), D(), D(), D(), v(14, "div", 21), v(15, "p"), q(16), D(), D(), D() } if (2 & n) { const e = t.$implicit; O(4), Vn(e.heading), O(2), qi("posted: ", e.date, ""), O(10), Vn(e.body) } } let fW = (() => { class n { constructor(e, i) { this.postService = e, this.modalService = i, this.posts = [], this.editPostHeading = "", this.editPostBody = "", this.editPostDate = "" } ngOnInit() { this.postService.getMyPosts().subscribe(e => { this.posts = e }, e => console.log(e)) } onPostDelete(e) { this.postService.deletePost(e).subscribe(i => { window.location.reload() }) } refresh() { window.location.reload() } open(e, i, r, o, s) { this.editPostId = i, this.editPostHeading = r, this.editPostBody = o, this.editPostDate = s, this.modalService.open(e) } onPostEdit(e, i, r, o) { let s = new GG(Number(e), sessionStorage.getItem("user"), i, r, o); console.log(e), this.postService.addPost(s).subscribe(a => { this.postService.onPostAdded.emit(a), window.location.reload() }) } } return n.\u0275fac = function(e) { return new (e || n)(g(rl), g(ww)) }, n.\u0275cmp = We({ type: n, selectors: [["app-post-myposts"]], decls: 3, vars: 1, consts: [["content", ""], ["class", "card mx-auto animate__animated animate__slideInDown", 4, "ngFor", "ngForOf"], [1, "modal-header"], ["id", "modal-basic-title", 1, "modal-title"], ["type", "button", "aria-label", "Close", 1, "btn-close", 3, "click"], [1, "modal-body"], ["id", "editPostForm", 3, "submit"], ["id", "postId", "name", "id", "type", "hidden", 1, "form-control", 3, "value"], ["id", ""], ["id", "postHeading", "name", "heading", "type", "text", "placeholder", "title", 1, "form-control", 3, "value"], ["heading", ""], ["for", "postHeading"], ["id", "postBody", "name", "body", "type", "text", "placeholder", "body", "rows", "15", 1, "form-control", 3, "value"], ["body", ""], ["for", "postBody"], ["id", "postDate", "name", "date", "type", "hidden", "placeholder", "date", 1, "form-control", 3, "value"], ["date", ""], [1, "modal-footer"], ["form", "editPostForm", "type", "button", "type", "submit", 1, "btn", "btn-outline-dark"], ["type", "button", 1, "btn", "btn-outline-dark", 3, "click"], [1, "card", "mx-auto", "animate__animated", "animate__slideInDown"], [1, "row"], [1, "col-md-8"], [1, "title"], [1, "col-md-4", "text-end"], ["type", "button", "mat-fab", "", "color", "warn", 3, "click"], ["aria-hidden", "false", "aria-label", "Delete"], ["type", "button", "mat-fab", "", "color", "primary", 3, "click"]], template: function(e, i) { 1 & e && (j(0, dW, 21, 4, "ng-template", null, 0, jn), j(2, hW, 17, 3, "div", 1)), 2 & e && (O(2), F("ngForOf", i.posts)) }, directives: [ss, rs, rr, Qi, JG, cW], styles: [".card[_ngcontent-%COMP%]{width:90%;justify-content:center;height:auto;border-radius:30px;background:#e0e0e0;box-shadow:15px 15px 30px #bebebe,-15px -15px 30px #fff;padding:20px;margin:50px}"] }), n })(), pW = (() => { class n { constructor(e) { this.postService = e, this.addPostAuthor = "", this.addPostHeading = "", this.addPostBody = "", this.addPostDate = "" } onPostAdd(e, i, r) { let o = new WG(sessionStorage.getItem("user"), e, i, r); this.postService.addPost(o).subscribe(s => { this.addPostAuthor = "", this.postService.onPostAdded.emit(s), window.location.reload() }) } refresh() { window.location.reload() } ngOnInit() { } } return n.\u0275fac = function(e) { return new (e || n)(g(rl)) }, n.\u0275cmp = We({ type: n, selectors: [["app-post-add"]], decls: 11, vars: 2, consts: [[1, "form-group", "py-3"], [3, "submit"], ["id", "postHeading", "name", "heading", "type", "text", "placeholder", "title", 1, "form-control", 3, "ngModel", "ngModelChange"], ["heading", ""], ["for", "postHeading"], ["id", "postBody", "name", "body", "type", "text", "placeholder", "body", "rows", "20", 1, "form-control", 3, "ngModel", "ngModelChange"], ["body", ""], ["for", "postBody"], [1, "text-center"], ["type", "submit", 1, "customButton", "my-2"]], template: function(e, i) { if (1 & e) { const r = Dt(); v(0, "div", 0), v(1, "form", 1), B("submit", function() { ze(r); const s = ht(3), a = ht(6); return i.onPostAdd(s.value, a.value, "") }), v(2, "input", 2, 3), B("ngModelChange", function(s) { return i.addPostHeading = s }), D(), Ue(4, "label", 4), v(5, "textarea", 5, 6), B("ngModelChange", function(s) { return i.addPostBody = s }), D(), Ue(7, "label", 7), v(8, "div", 8), v(9, "button", 9), q(10, " Add "), D(), D(), D(), D() } 2 & e && (O(2), F("ngModel", i.addPostHeading), O(3), F("ngModel", i.addPostBody)) }, directives: [ss, rs, rr, is, Qc, Ba], styles: [".customButton[_ngcontent-%COMP%]{border:none;color:#090909;padding:.7em 1.7em;font-size:18px;border-radius:.5em;background:#e8e8e8;border:1px solid #e8e8e8;transition:all .3s;box-shadow:6px 6px 12px #c5c5c5,-6px -6px 12px #fff}.customButton[_ngcontent-%COMP%]:active{color:#666;box-shadow:inset 4px 4px 12px #c5c5c5,inset -4px -4px 12px #fff}"] }), n })(); function gW(n, t) { if (1 & n) { const e = Dt(); v(0, "span", 10), B("click", function() { return ze(e), K().refresh() }), q(1, "All Posts"), D() } } let _W = (() => { class n { constructor() { } ngOnInit() { } refresh() { window.location.reload() } } return n.\u0275fac = function(e) { return new (e || n) }, n.\u0275cmp = We({ type: n, selectors: [["app-posts"]], decls: 18, vars: 0, consts: [[1, "row"], [1, "col-md-2"], [1, "col-md-8"], ["id", "postsPanel py-0", 1, "panel", "panel-default"], [1, "panel-body"], [1, "col-md-12"], ["mat-align-tabs", "center", "color", "transparent"], ["mat-tab-label", ""], ["label", "My posts"], ["label", "Add post"], [3, "click"]], template: function(e, i) { 1 & e && (v(0, "div", 0), v(1, "div", 1), q(2, "\xa0"), D(), v(3, "div", 2), v(4, "div", 3), v(5, "div", 4), v(6, "div", 0), v(7, "div", 5), v(8, "mat-tab-group", 6), v(9, "mat-tab"), j(10, gW, 2, 0, "ng-template", 7), Ue(11, "app-post-list"), D(), v(12, "mat-tab", 8), Ue(13, "app-post-myposts"), D(), v(14, "mat-tab", 9), Ue(15, "app-post-add"), D(), D(), D(), D(), D(), D(), D(), v(16, "div", 1), q(17, "\xa0"), D(), D()) }, directives: [HG, mS, TG, $G, fW, pW], styles: ["h3[_ngcontent-%COMP%]{color:#00f}#postsPanel[_ngcontent-%COMP%]{margin-top:50px}.row[_ngcontent-%COMP%]{margin:0;font-family:Ramaraja,serif!important;font-size:12px}"] }), n })(); function mW(n, t) { if (1 & n) { const e = Dt(); v(0, "ul", 5), v(1, "li", 6), v(2, "a", 7), B("click", function() { return ze(e), K().doLogout() }), q(3, "Logout"), D(), D(), v(4, "li", 6), v(5, "a", 8), q(6), D(), D(), D() } if (2 & n) { const e = K(); O(6), Vn(e.loggedInUser) } } let NS = (() => { class n { constructor(e, i, r, o) { this.route = e, this.router = i, this.http = r, this.authService = o, this.isLoggedIn = !1, this.loggedInUser = "", this.greeting = [] } ngOnInit() { this.isLoggedIn = this.authService.isUserLoggedIn(), this.loggedInUser = this.authService.getLoggedInUser(), this.authService.isUserLoggedIn() || this.router.navigateByUrl("login") } doLogout() { this.authService.logout() } home() { this.router.navigateByUrl("home") } } return n.\u0275fac = function(e) { return new (e || n)(g(Zi), g(Ot), g(ns), g(zc)) }, n.\u0275cmp = We({ type: n, selectors: [["app-home"]], decls: 7, vars: 1, consts: [[1, "navbar", "navbar-light"], [1, "container", "py-3"], ["href", "#", 1, "navbar-brand", "px-2", "py-3"], ["class", "nav justify-content-end", 4, "ngIf"], [1, "container"], [1, "nav", "justify-content-end"], [1, "nav-item"], [1, "nav-link", "accent-color", 2, "cursor", "pointer", 3, "click"], [1, "nav-link", "disabled"]], template: function(e, i) { 1 & e && (v(0, "nav", 0), v(1, "div", 1), v(2, "a", 2), q(3, "Lampp"), D(), j(4, mW, 7, 1, "ul", 3), D(), D(), v(5, "div", 4), Ue(6, "app-posts"), D()), 2 & e && (O(4), F("ngIf", i.isLoggedIn)) }, directives: [mg, Ni, _W], styles: [".accent-color[_ngcontent-%COMP%]{color:teal}"] }), n })(); function yW(n, t) { if (1 & n && (v(0, "div", 17), q(1), D()), 2 & n) { const e = K(); O(1), Vn(e.error) } } let IS = (() => { class n { constructor(e, i, r) { this.route = e, this.router = i, this.authService = r, this.username = "", this.password = "", this.isSignedin = !1, this.error = "" } ngOnInit() { this.isSignedin = this.authService.isUserLoggedIn(), this.isSignedin && this.router.navigateByUrl("home") } doLogin() { "" !== this.username && null !== this.username && "" !== this.password && null !== this.password ? this.authService.login({ username: this.username, password: this.password }).subscribe(i => { this.router.navigateByUrl("home") }, () => { this.error = "Either invalid credentials or something went wrong" }) : this.error = "Invalid Credentials" } } return n.\u0275fac = function(e) { return new (e || n)(g(Zi), g(Ot), g(zc)) }, n.\u0275cmp = We({ type: n, selectors: [["app-login"]], decls: 31, vars: 3, consts: [[1, "sidenav", "animate__animated", "animate__backInLeft"], [1, "login-main-text"], [1, "main", "text-center"], [1, "col-md-6", "col-sm-12", "animate__animated", "animate__slideInUp"], [1, "form-signin", "container", "py-5", "w-100", "h-100"], ["name", "signinForm", 3, "submit"], [1, "h3", "mb-3", "fw-normal"], ["style", "color: red", 4, "ngIf"], [1, "form-floating"], ["type", "text", "name", "username", "id", "floatingInput", "placeholder", "JohnDoe", 1, "form-control", 3, "ngModel", "ngModelChange"], ["for", "floatingInput"], ["type", "password", "name", "password", "id", "floatingPassword", "placeholder", "Password", 1, "form-control", 3, "ngModel", "ngModelChange"], ["for", "floatingPassword"], ["type", "submit", 1, "w-100", "btn", "btn-lg", "btn-primary"], [1, "mt-5", "mb-3"], ["href", "/register", "routerLink", "/register"], [1, "text-muted"], [2, "color", "red"]], template: function(e, i) { 1 & e && (v(0, "div", 0), v(1, "div", 1), v(2, "h1"), q(3, " Lampp "), D(), v(4, "p"), v(5, "i"), q(6, "Welcome. This is an Angular web application running with Spring Boot in the backend. Feel free to post some development news."), D(), D(), D(), D(), v(7, "div", 2), v(8, "div", 3), v(9, "div", 4), v(10, "form", 5), B("submit", function() { return i.doLogin() }), v(11, "h2", 6), q(12, "Please sign in"), D(), j(13, yW, 2, 1, "div", 7), v(14, "div", 8), v(15, "input", 9), B("ngModelChange", function(o) { return i.username = o }), D(), v(16, "label", 10), q(17, "Username"), D(), D(), v(18, "div", 8), v(19, "input", 11), B("ngModelChange", function(o) { return i.password = o }), D(), v(20, "label", 12), q(21, "Password"), D(), D(), Ue(22, "br"), v(23, "button", 13), q(24, "Sign in"), D(), v(25, "p", 14), q(26, " Don't have account? "), v(27, "a", 15), q(28, "Register"), D(), D(), v(29, "p", 16), q(30, "\xa9 2022"), D(), D(), D(), D(), D()), 2 & e && (O(13), F("ngIf", i.error), O(2), F("ngModel", i.username), O(4), F("ngModel", i.password)) }, directives: [ss, rs, rr, Ni, is, Qc, Ba, Ma], styles: ["html[_ngcontent-%COMP%], body[_ngcontent-%COMP%]{height:100%}body[_ngcontent-%COMP%]{display:flex;align-items:center;padding-top:40px;padding-bottom:40px;background-color:#f5f5f5}.form-signin[_ngcontent-%COMP%]{width:100%;max-width:330px;padding:15px;margin:auto}.form-signin[_ngcontent-%COMP%]   .form-floating[_ngcontent-%COMP%]:focus-within{z-index:2}.form-signin[_ngcontent-%COMP%]   input[type=email][_ngcontent-%COMP%]{margin-bottom:-1px;border-bottom-right-radius:0;border-bottom-left-radius:0}.form-signin[_ngcontent-%COMP%]   input[type=password][_ngcontent-%COMP%]{margin-bottom:10px;border-top-left-radius:0;border-top-right-radius:0}h1[_ngcontent-%COMP%]{font-family:EB Garamond,serif!important;font-size:2em!important}.main-head[_ngcontent-%COMP%]{height:100%;background:#FFF}.sidenav[_ngcontent-%COMP%]{height:100%;background-color:#000;overflow-x:hidden;padding-top:20px;font-size:20px!important}.main[_ngcontent-%COMP%]{padding:0%;height:100%;display:flex;flex-wrap:wrap;align-content:center;width:100%}@media screen and (max-height: 450px){.sidenav[_ngcontent-%COMP%]{padding-top:15px}}@media screen and (max-width: 450px){.login-form[_ngcontent-%COMP%], .register-form[_ngcontent-%COMP%]{margin-top:10%}}@media screen and (min-width: 768px){.main[_ngcontent-%COMP%]{margin-left:40%}.sidenav[_ngcontent-%COMP%]{width:40%;position:fixed;z-index:1;top:0;left:0}.login-form[_ngcontent-%COMP%]{margin-top:80%}.register-form[_ngcontent-%COMP%]{margin-top:20%}}.login-main-text[_ngcontent-%COMP%]{margin-top:20%;padding:150px;color:#fff}.login-main-text[_ngcontent-%COMP%]   h2[_ngcontent-%COMP%]{font-weight:300}.btn-black[_ngcontent-%COMP%]{background-color:#000!important;color:#fff}"] }), n })(); function bW(n, t) { if (1 & n && (v(0, "div", 18), q(1), D()), 2 & n) { const e = K(); O(1), Vn(e.error) } } function vW(n, t) { if (1 & n && (v(0, "div", 19), q(1), D()), 2 & n) { const e = K(); O(1), Vn(e.success) } } let RS = (() => { class n { constructor(e) { this.authService = e, this.username = "", this.password = "", this.error = "", this.success = "" } ngOnInit() { } doRegister() { "" !== this.username && null !== this.username && "" !== this.password && null !== this.password ? this.authService.register({ username: this.username, password: this.password }).subscribe(i => { this.success = i }, i => { console.log(i), this.error = `${i.name}: Username already in use.` }) : this.error = "All fields are mandatory" } } return n.\u0275fac = function(e) { return new (e || n)(g(zc)) }, n.\u0275cmp = We({ type: n, selectors: [["app-register"]], decls: 32, vars: 4, consts: [[1, "sidenav", "animate__animated", "animate__backInLeft"], [1, "login-main-text"], [1, "main", "text-center"], [1, "col-md-6", "col-sm-12", "animate__animated", "animate__slideInUp"], [1, "form-signin", "container", "py-5", "w-50"], ["name", "signinForm", 3, "submit"], [1, "h3", "mb-3", "fw-normal"], ["style", "color: red", 4, "ngIf"], ["style", "color: green", 4, "ngIf"], [1, "form-floating"], ["type", "email", "name", "username", "id", "floatingInput", "placeholder", "JohnDoe", 1, "form-control", 3, "ngModel", "ngModelChange"], ["for", "floatingInput"], ["type", "password", "name", "password", "id", "floatingPassword", "placeholder", "Password", 1, "form-control", 3, "ngModel", "ngModelChange"], ["for", "floatingPassword"], ["type", "submit", 1, "w-100", "btn", "btn-lg", "btn-primary"], [1, "mt-5", "mb-3"], ["href", "/login", "routerLink", "/login"], [1, "text-muted"], [2, "color", "red"], [2, "color", "green"]], template: function(e, i) { 1 & e && (v(0, "div", 0), v(1, "div", 1), v(2, "h1"), q(3, " Lampp "), D(), v(4, "p"), v(5, "i"), q(6, "Welcome. This is an Angular web application running with Spring Boot in the backend. Feel free to post some development news."), D(), D(), D(), D(), v(7, "div", 2), v(8, "div", 3), v(9, "div", 4), v(10, "form", 5), B("submit", function() { return i.doRegister() }), v(11, "h2", 6), q(12, "Please sign up"), D(), j(13, bW, 2, 1, "div", 7), j(14, vW, 2, 1, "div", 8), v(15, "div", 9), v(16, "input", 10), B("ngModelChange", function(o) { return i.username = o }), D(), v(17, "label", 11), q(18, "Username"), D(), D(), v(19, "div", 9), v(20, "input", 12), B("ngModelChange", function(o) { return i.password = o }), D(), v(21, "label", 13), q(22, "Password"), D(), D(), Ue(23, "br"), v(24, "button", 14), q(25, "Sign up"), D(), v(26, "p", 15), q(27, " Have an account? "), v(28, "a", 16), q(29, "Sign In"), D(), D(), v(30, "p", 17), q(31, "\xa9 2022"), D(), D(), D(), D(), D()), 2 & e && (O(13), F("ngIf", i.error), O(1), F("ngIf", i.success), O(2), F("ngModel", i.username), O(4), F("ngModel", i.password)) }, directives: [ss, rs, rr, Ni, is, Qc, Ba, Ma], styles: ["html[_ngcontent-%COMP%], body[_ngcontent-%COMP%]{height:100%}body[_ngcontent-%COMP%]{display:flex;align-items:center;padding-top:40px;padding-bottom:40px;background-color:#f5f5f5}.form-signin[_ngcontent-%COMP%]{width:100%;max-width:330px;padding:15px;margin:auto}.form-signin[_ngcontent-%COMP%]   .form-floating[_ngcontent-%COMP%]:focus-within{z-index:2}.form-signin[_ngcontent-%COMP%]   input[type=email][_ngcontent-%COMP%]{margin-bottom:-1px;border-bottom-right-radius:0;border-bottom-left-radius:0}.form-signin[_ngcontent-%COMP%]   input[type=password][_ngcontent-%COMP%]{margin-bottom:10px;border-top-left-radius:0;border-top-right-radius:0}body[_ngcontent-%COMP%]{font-family:Lato,sans-serif}h1[_ngcontent-%COMP%]{font-family:EB Garamond,serif!important;font-size:2em!important}.main-head[_ngcontent-%COMP%]{height:100%;background:#FFF}.sidenav[_ngcontent-%COMP%]{height:100%;background-color:#000;overflow-x:hidden;padding-top:20px;font-size:20px!important}.main[_ngcontent-%COMP%]{padding:0%;height:100%;display:flex;flex-wrap:wrap;align-content:center;width:100%}@media screen and (max-height: 450px){.sidenav[_ngcontent-%COMP%]{padding-top:15px}}@media screen and (max-width: 450px){.login-form[_ngcontent-%COMP%], .register-form[_ngcontent-%COMP%]{margin-top:10%}}@media screen and (min-width: 768px){.main[_ngcontent-%COMP%]{margin-left:40%}.sidenav[_ngcontent-%COMP%]{width:40%;position:fixed;z-index:1;top:0;left:0}.login-form[_ngcontent-%COMP%]{margin-top:80%}.register-form[_ngcontent-%COMP%]{margin-top:20%}}.login-main-text[_ngcontent-%COMP%]{margin-top:20%;padding:150px;color:#fff}.login-main-text[_ngcontent-%COMP%]   h2[_ngcontent-%COMP%]{font-weight:300}.btn-black[_ngcontent-%COMP%]{background-color:#000!important;color:#fff}"] }), n })(); const DW = [{ path: "", redirectTo: "home", pathMatch: "full" }, { path: "home", component: NS }, { path: "login", component: IS }, { path: "register", component: RS }]; let CW = (() => { class n { } return n.\u0275fac = function(e) { return new (e || n) }, n.\u0275mod = se({ type: n }), n.\u0275inj = te({ imports: [[bp.forRoot(DW)], bp] }), n })(), EW = (() => { class n { } return n.\u0275fac = function(e) { return new (e || n) }, n.\u0275cmp = We({ type: n, selectors: [["app-root"]], decls: 1, vars: 0, template: function(e, i) { 1 & e && Ue(0, "router-outlet") }, directives: [hp], styles: [""] }), n })(), wW = (() => { class n { constructor(e, i) { this.authService = e, this.postService = i } intercept(e, i) { if (this.authService.isUserLoggedIn() && this.authService.getToken()) { const r = e.clone({ headers: new xt({ Authorization: this.authService.getToken() }) }); return i.handle(r).pipe(ai(o => (o instanceof Ep && 401 === o.status && this.authService.logout(), ES(o)))) } return i.handle(e) } } return n.\u0275fac = function(e) { return new (e || n)(E(zc), E(rl)) }, n.\u0275prov = R({ token: n, factory: n.\u0275fac }), n })(); const TW = [{ path: "home", component: NS }, { path: "login", component: IS }, { path: "register", component: RS }, { path: "", redirectTo: "home", pathMatch: "full" }]; let SW = (() => { class n { } return n.\u0275fac = function(e) { return new (e || n) }, n.\u0275mod = se({ type: n, bootstrap: [EW] }), n.\u0275inj = te({ providers: [{ provide: Tp, useClass: wW, multi: !0 }, rl], imports: [[ZD, CW, xE, vV, L5, jG, uW, ZG, h3, [bp.forRoot(TW)]]] }), n })(); (function hk() { sD = !1 })(), RL().bootstrapModule(SW).catch(n => console.error(n)) } }, ye => { ye(ye.s = 6) }]);